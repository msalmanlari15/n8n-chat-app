"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/n8n-client.ts":
/*!***************************!*\
  !*** ./lib/n8n-client.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   N8NClient: () => (/* binding */ N8NClient),\n/* harmony export */   N8NError: () => (/* binding */ N8NError),\n/* harmony export */   createN8NClient: () => (/* binding */ createN8NClient),\n/* harmony export */   n8nClientExample: () => (/* binding */ n8nClientExample),\n/* harmony export */   n8nUtils: () => (/* binding */ n8nUtils)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * n8n Webhook Client\n * Handles communication with n8n workflows via webhook and streaming endpoints\n */ class N8NError extends Error {\n    constructor(message, type, details){\n        super(message), this.type = type, this.details = details;\n        this.name = 'N8NError';\n    }\n}\nclass N8NClient {\n    /**\n   * Send a message to n8n webhook\n   */ async sendMessage(request) {\n        const { webhookUrl, timeout } = this.config;\n        try {\n            console.log('=== N8N WEBHOOK DEBUG ===');\n            console.log('Webhook URL:', webhookUrl);\n            console.log('Request payload:', JSON.stringify(request, null, 2));\n            const response = await fetch(webhookUrl, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Accept': 'application/json'\n                },\n                body: JSON.stringify(request)\n            });\n            console.log('Response status:', response.status);\n            console.log('Response headers:', Object.fromEntries(response.headers.entries()));\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('Error response body:', errorText);\n                throw new N8NError(\"HTTP \".concat(response.status, \": \").concat(response.statusText), 'server', {\n                    status: response.status,\n                    statusText: response.statusText,\n                    body: errorText\n                });\n            }\n            const responseText = await response.text();\n            console.log('Raw response:', responseText);\n            let data;\n            try {\n                data = JSON.parse(responseText);\n            } catch (parseError) {\n                console.log('Response is not JSON, treating as plain text');\n                data = responseText;\n            }\n            console.log('Parsed response data:', data);\n            const validatedResponse = this.validateResponse(data);\n            console.log('Validated response:', validatedResponse);\n            console.log('=== END N8N WEBHOOK DEBUG ===');\n            return validatedResponse;\n        } catch (error) {\n            console.error('=== N8N WEBHOOK ERROR ===');\n            console.error('Error details:', error);\n            console.error('Error type:', error instanceof Error ? error.constructor.name : typeof error);\n            console.error('Error message:', error instanceof Error ? error.message : String(error));\n            console.error('=== END N8N WEBHOOK ERROR ===');\n            if (error instanceof Error) {\n                if (error.name === 'TimeoutError' || error.name === 'AbortError') {\n                    throw new N8NError('Request timeout', 'timeout');\n                }\n                if (error.message.includes('fetch') || error.message.includes('network')) {\n                    throw new N8NError('Network error', 'network', error);\n                }\n            }\n            throw error;\n        }\n    }\n    /**\n   * Set up streaming connection for real-time updates\n   */ async *streamMessages(sessionId) {\n        const { streamingUrl } = this.config;\n        const url = new URL(streamingUrl);\n        url.searchParams.set('sessionId', sessionId);\n        try {\n            var _response_body;\n            const response = await fetch(url.toString(), {\n                headers: {\n                    'Accept': 'text/event-stream',\n                    'Cache-Control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                throw new N8NError(\"Streaming failed: \".concat(response.status), 'server', {\n                    status: response.status\n                });\n            }\n            const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n            if (!reader) {\n                throw new N8NError('No response body', 'server');\n            }\n            const decoder = new TextDecoder();\n            let buffer = '';\n            try {\n                while(true){\n                    const { done, value } = await reader.read();\n                    if (done) break;\n                    buffer += decoder.decode(value, {\n                        stream: true\n                    });\n                    const lines = buffer.split('\\n');\n                    // Keep the last incomplete line in buffer\n                    buffer = lines.pop() || '';\n                    for (const line of lines){\n                        if (line.trim() === '') continue;\n                        if (line.startsWith('data: ')) {\n                            const data = line.slice(6);\n                            if (data === '[DONE]') {\n                                return;\n                            }\n                            try {\n                                const parsed = JSON.parse(data);\n                                const response = this.validateResponse(parsed);\n                                yield response;\n                            } catch (error) {\n                                console.warn('Failed to parse streaming data:', error);\n                            }\n                        }\n                    }\n                }\n            } finally{\n                reader.releaseLock();\n            }\n        } catch (error) {\n            if (error instanceof N8NError) {\n                throw error;\n            }\n            throw new N8NError('Streaming connection failed', 'network', error);\n        }\n    }\n    /**\n   * Send message with retry logic\n   */ async sendMessageWithRetry(request) {\n        const { retryAttempts, retryDelay } = this.config;\n        for(let attempt = 1; attempt <= retryAttempts; attempt++){\n            try {\n                return await this.sendMessage(request);\n            } catch (error) {\n                if (error instanceof N8NError) {\n                    // Don't retry validation errors\n                    if (error.type === 'validation') {\n                        throw error;\n                    }\n                    // Don't retry on final attempt\n                    if (attempt === retryAttempts) {\n                        throw error;\n                    }\n                    // Wait before retry\n                    await new Promise((resolve)=>setTimeout(resolve, retryDelay * attempt));\n                } else {\n                    throw error;\n                }\n            }\n        }\n        throw new N8NError('Max retry attempts reached', 'network');\n    }\n    /**\n   * Remove duplicate content from response\n   */ deduplicateContent(content) {\n        if (typeof content !== 'string') {\n            return content;\n        }\n        // Split content into lines\n        const lines = content.split('\\n');\n        const seenLines = new Set();\n        const deduplicatedLines = [];\n        for (const line of lines){\n            const trimmedLine = line.trim();\n            // Skip empty lines for deduplication check\n            if (trimmedLine === '') {\n                deduplicatedLines.push(line);\n                continue;\n            }\n            // If we haven't seen this line before, add it\n            if (!seenLines.has(trimmedLine)) {\n                seenLines.add(trimmedLine);\n                deduplicatedLines.push(line);\n            }\n        }\n        return deduplicatedLines.join('\\n');\n    }\n    /**\n   * Detect if content is mixed format (contains text and chart keys)\n   */ isMixedContent(content) {\n        if (!Array.isArray(content)) return false;\n        return content.some((item)=>{\n            if (!item || typeof item !== 'object') return false;\n            const keys = Object.keys(item);\n            const hasText = keys.some((key)=>key.startsWith('text'));\n            const hasChart = keys.some((key)=>key.startsWith('chart'));\n            return hasText || hasChart;\n        });\n    }\n    /**\n   * Validate n8n response format\n   */ validateResponse(data) {\n        if (!data || typeof data !== 'object') {\n            // If we get a simple response, wrap it in our expected format\n            return {\n                type: 'final',\n                messageType: 'text',\n                content: String(data),\n                metadata: {\n                    timestamp: new Date()\n                }\n            };\n        }\n        // Check if response already has our expected format\n        if (data.type && data.messageType && data.content !== undefined) {\n            return {\n                type: data.type,\n                messageType: data.messageType,\n                content: data.messageType === 'text' ? this.deduplicateContent(data.content) : data.content,\n                metadata: data.metadata || {\n                    timestamp: new Date()\n                }\n            };\n        }\n        // Handle various possible n8n response formats\n        let content = data.content || data.message || data.response || data.text || data.output || data;\n        let messageType = data.messageType || data.format || 'text';\n        let type = data.type || 'final';\n        // Special handling for n8n output field that contains JSON string\n        if (data.output && typeof data.output === 'string') {\n            try {\n                const parsedOutput = JSON.parse(data.output);\n                if (parsedOutput && typeof parsedOutput === 'object') {\n                    // If the output contains a valid JSON object, use it as the base\n                    content = parsedOutput.content || parsedOutput;\n                    messageType = parsedOutput.messageType || messageType;\n                    type = parsedOutput.type || type;\n                }\n            } catch (error) {\n                // If parsing fails, treat output as regular text content\n                console.warn('Failed to parse n8n output as JSON:', error);\n            }\n        }\n        // Check if this is a mixed content response (array with text/chart combinations)\n        if (this.isMixedContent(content)) {\n            messageType = 'mixed';\n        } else if (Array.isArray(content)) {\n            // If it's an array but not mixed content, treat as JSON\n            messageType = 'json';\n        }\n        // Validate messageType\n        if (![\n            'text',\n            'json',\n            'image',\n            'chart',\n            'error',\n            'mixed'\n        ].includes(messageType)) {\n            messageType = 'text';\n        }\n        // Validate type\n        if (![\n            'interim',\n            'final'\n        ].includes(type)) {\n            type = 'final';\n        }\n        return {\n            type,\n            messageType,\n            content: messageType === 'text' ? this.deduplicateContent(content) : content,\n            metadata: data.metadata || {\n                timestamp: new Date(),\n                source: 'n8n-webhook',\n                originalResponse: data\n            }\n        };\n    }\n    /**\n   * Cancel ongoing request\n   */ cancel() {\n        // Requests now use AbortSignal.timeout() which auto-cancels\n        console.log('Cancel requested - using timeout-based cancellation');\n    }\n    /**\n   * Health check endpoint\n   */ async healthCheck() {\n        try {\n            const response = await fetch(\"\".concat(this.config.webhookUrl, \"/health\"), {\n                method: 'GET',\n                signal: AbortSignal.timeout(5000)\n            });\n            return response.ok;\n        } catch (e) {\n            return false;\n        }\n    }\n    constructor(config){\n        this.config = {\n            timeout: 120000,\n            retryAttempts: 3,\n            retryDelay: 1000,\n            ...config\n        };\n    }\n}\n// Factory function for creating client instances\nfunction createN8NClient(config) {\n    return new N8NClient(config);\n}\n// Example usage\nconst n8nClientExample = ()=>{\n    const client = createN8NClient({\n        webhookUrl: process.env.N8N_WEBHOOK_URL,\n        streamingUrl: process.env.N8N_STREAMING_URL,\n        timeout: 30000,\n        retryAttempts: 3,\n        retryDelay: 1000\n    });\n    // Example: Send message\n    const sendMessage = async ()=>{\n        try {\n            const request = {\n                username: 'user123',\n                message: 'Hello, can you analyze this data?',\n                sessionId: 'session-123',\n                timestamp: new Date()\n            };\n            const response = await client.sendMessageWithRetry(request);\n            console.log('Response:', response);\n        } catch (error) {\n            if (error instanceof N8NError) {\n                console.error('N8N Error:', error.message, error.type);\n            } else {\n                console.error('Unexpected error:', error);\n            }\n        }\n    };\n    // Example: Stream messages\n    const streamMessages = async ()=>{\n        try {\n            const sessionId = 'session-123';\n            for await (const response of client.streamMessages(sessionId)){\n                console.log('Streaming response:', response);\n                if (response.type === 'final') {\n                    break;\n                }\n            }\n        } catch (error) {\n            console.error('Streaming error:', error);\n        }\n    };\n    return {\n        sendMessage,\n        streamMessages\n    };\n};\n// Utility functions for common operations\nconst n8nUtils = {\n    /**\n   * Format error for user display\n   */ formatError (error) {\n        switch(error.type){\n            case 'network':\n                return 'Network connection failed. Please check your internet connection.';\n            case 'timeout':\n                return 'Request timed out. The workflow may be taking longer than expected.';\n            case 'server':\n                return 'Server error occurred. Please try again later.';\n            case 'validation':\n                return 'Invalid data format. Please contact support.';\n            default:\n                return 'An unexpected error occurred. Please try again.';\n        }\n    },\n    /**\n   * Check if response is interim message\n   */ isInterimMessage (response) {\n        return response.type === 'interim';\n    },\n    /**\n   * Check if response is final message\n   */ isFinalMessage (response) {\n        return response.type === 'final';\n    },\n    /**\n   * Extract processing time from metadata\n   */ getProcessingTime (response) {\n        var _response_metadata;\n        return ((_response_metadata = response.metadata) === null || _response_metadata === void 0 ? void 0 : _response_metadata.processingTime) || null;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9uOG4tY2xpZW50LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQUlNLE1BQU1BLGlCQUFpQkM7SUFDNUIsWUFDRUMsT0FBZSxFQUNmLElBQTRELEVBQzVELE9BQW9CLENBQ3BCO1FBQ0EsS0FBSyxDQUFDQSxlQUhDQyxPQUFBQSxXQUNBQyxVQUFBQTtRQUdQLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQVVPLE1BQU1DO0lBWVg7O0dBRUMsR0FDRCxNQUFNQyxZQUFZQyxPQUFtQixFQUF3QjtRQUMzRCxNQUFNLEVBQUVDLFVBQVUsRUFBRUMsT0FBTyxFQUFFLEdBQUcsSUFBSSxDQUFDQyxNQUFNO1FBRTNDLElBQUk7WUFDRkMsUUFBUUMsR0FBRyxDQUFDO1lBQ1pELFFBQVFDLEdBQUcsQ0FBQyxnQkFBZ0JKO1lBQzVCRyxRQUFRQyxHQUFHLENBQUMsb0JBQW9CQyxLQUFLQyxTQUFTLENBQUNQLFNBQVMsTUFBTTtZQUU5RCxNQUFNUSxXQUFXLE1BQU1DLE1BQU1SLFlBQVk7Z0JBQ3ZDUyxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsVUFBVTtnQkFDWjtnQkFDQUMsTUFBTU4sS0FBS0MsU0FBUyxDQUFDUDtZQUN2QjtZQUVBSSxRQUFRQyxHQUFHLENBQUMsb0JBQW9CRyxTQUFTSyxNQUFNO1lBQy9DVCxRQUFRQyxHQUFHLENBQUMscUJBQXFCUyxPQUFPQyxXQUFXLENBQUNQLFNBQVNHLE9BQU8sQ0FBQ0ssT0FBTztZQUU1RSxJQUFJLENBQUNSLFNBQVNTLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsWUFBWSxNQUFNVixTQUFTVyxJQUFJO2dCQUNyQ2YsUUFBUWdCLEtBQUssQ0FBQyx3QkFBd0JGO2dCQUN0QyxNQUFNLElBQUkxQixTQUNSLFFBQTRCZ0IsT0FBcEJBLFNBQVNLLE1BQU0sRUFBQyxNQUF3QixPQUFwQkwsU0FBU2EsVUFBVSxHQUMvQyxVQUNBO29CQUFFUixRQUFRTCxTQUFTSyxNQUFNO29CQUFFUSxZQUFZYixTQUFTYSxVQUFVO29CQUFFVCxNQUFNTTtnQkFBVTtZQUVoRjtZQUVBLE1BQU1JLGVBQWUsTUFBTWQsU0FBU1csSUFBSTtZQUN4Q2YsUUFBUUMsR0FBRyxDQUFDLGlCQUFpQmlCO1lBRTdCLElBQUlDO1lBQ0osSUFBSTtnQkFDRkEsT0FBT2pCLEtBQUtrQixLQUFLLENBQUNGO1lBQ3BCLEVBQUUsT0FBT0csWUFBWTtnQkFDbkJyQixRQUFRQyxHQUFHLENBQUM7Z0JBQ1prQixPQUFPRDtZQUNUO1lBRUFsQixRQUFRQyxHQUFHLENBQUMseUJBQXlCa0I7WUFDckMsTUFBTUcsb0JBQW9CLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNKO1lBQ2hEbkIsUUFBUUMsR0FBRyxDQUFDLHVCQUF1QnFCO1lBQ25DdEIsUUFBUUMsR0FBRyxDQUFDO1lBRVosT0FBT3FCO1FBQ1QsRUFBRSxPQUFPTixPQUFPO1lBQ2RoQixRQUFRZ0IsS0FBSyxDQUFDO1lBQ2RoQixRQUFRZ0IsS0FBSyxDQUFDLGtCQUFrQkE7WUFDaENoQixRQUFRZ0IsS0FBSyxDQUFDLGVBQWVBLGlCQUFpQjNCLFFBQVEyQixNQUFNLFdBQVcsQ0FBQ3ZCLElBQUksR0FBRyxPQUFPdUI7WUFDdEZoQixRQUFRZ0IsS0FBSyxDQUFDLGtCQUFrQkEsaUJBQWlCM0IsUUFBUTJCLE1BQU0xQixPQUFPLEdBQUdrQyxPQUFPUjtZQUNoRmhCLFFBQVFnQixLQUFLLENBQUM7WUFFZCxJQUFJQSxpQkFBaUIzQixPQUFPO2dCQUMxQixJQUFJMkIsTUFBTXZCLElBQUksS0FBSyxrQkFBa0J1QixNQUFNdkIsSUFBSSxLQUFLLGNBQWM7b0JBQ2hFLE1BQU0sSUFBSUwsU0FBUyxtQkFBbUI7Z0JBQ3hDO2dCQUVBLElBQUk0QixNQUFNMUIsT0FBTyxDQUFDbUMsUUFBUSxDQUFDLFlBQVlULE1BQU0xQixPQUFPLENBQUNtQyxRQUFRLENBQUMsWUFBWTtvQkFDeEUsTUFBTSxJQUFJckMsU0FBUyxpQkFBaUIsV0FBVzRCO2dCQUNqRDtZQUNGO1lBRUEsTUFBTUE7UUFDUjtJQUNGO0lBRUE7O0dBRUMsR0FDRCxPQUFPVSxlQUFlQyxTQUFpQixFQUE4QztRQUNuRixNQUFNLEVBQUVDLFlBQVksRUFBRSxHQUFHLElBQUksQ0FBQzdCLE1BQU07UUFDcEMsTUFBTThCLE1BQU0sSUFBSUMsSUFBSUY7UUFDcEJDLElBQUlFLFlBQVksQ0FBQ0MsR0FBRyxDQUFDLGFBQWFMO1FBRWxDLElBQUk7Z0JBZ0JhdkI7WUFmZixNQUFNQSxXQUFXLE1BQU1DLE1BQU13QixJQUFJSSxRQUFRLElBQUk7Z0JBQzNDMUIsU0FBUztvQkFDUCxVQUFVO29CQUNWLGlCQUFpQjtnQkFDbkI7WUFDRjtZQUVBLElBQUksQ0FBQ0gsU0FBU1MsRUFBRSxFQUFFO2dCQUNoQixNQUFNLElBQUl6QixTQUNSLHFCQUFxQyxPQUFoQmdCLFNBQVNLLE1BQU0sR0FDcEMsVUFDQTtvQkFBRUEsUUFBUUwsU0FBU0ssTUFBTTtnQkFBQztZQUU5QjtZQUVBLE1BQU15QixVQUFTOUIsaUJBQUFBLFNBQVNJLElBQUksY0FBYkoscUNBQUFBLGVBQWUrQixTQUFTO1lBQ3ZDLElBQUksQ0FBQ0QsUUFBUTtnQkFDWCxNQUFNLElBQUk5QyxTQUFTLG9CQUFvQjtZQUN6QztZQUVBLE1BQU1nRCxVQUFVLElBQUlDO1lBQ3BCLElBQUlDLFNBQVM7WUFFYixJQUFJO2dCQUNGLE1BQU8sS0FBTTtvQkFDWCxNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTU4sT0FBT08sSUFBSTtvQkFFekMsSUFBSUYsTUFBTTtvQkFFVkQsVUFBVUYsUUFBUU0sTUFBTSxDQUFDRixPQUFPO3dCQUFFRyxRQUFRO29CQUFLO29CQUMvQyxNQUFNQyxRQUFRTixPQUFPTyxLQUFLLENBQUM7b0JBRTNCLDBDQUEwQztvQkFDMUNQLFNBQVNNLE1BQU1FLEdBQUcsTUFBTTtvQkFFeEIsS0FBSyxNQUFNQyxRQUFRSCxNQUFPO3dCQUN4QixJQUFJRyxLQUFLQyxJQUFJLE9BQU8sSUFBSTt3QkFFeEIsSUFBSUQsS0FBS0UsVUFBVSxDQUFDLFdBQVc7NEJBQzdCLE1BQU05QixPQUFPNEIsS0FBS0csS0FBSyxDQUFDOzRCQUV4QixJQUFJL0IsU0FBUyxVQUFVO2dDQUNyQjs0QkFDRjs0QkFFQSxJQUFJO2dDQUNGLE1BQU1nQyxTQUFTakQsS0FBS2tCLEtBQUssQ0FBQ0Q7Z0NBQzFCLE1BQU1mLFdBQVcsSUFBSSxDQUFDbUIsZ0JBQWdCLENBQUM0QjtnQ0FDdkMsTUFBTS9DOzRCQUNSLEVBQUUsT0FBT1ksT0FBTztnQ0FDZGhCLFFBQVFvRCxJQUFJLENBQUMsbUNBQW1DcEM7NEJBQ2xEO3dCQUNGO29CQUNGO2dCQUNGO1lBQ0YsU0FBVTtnQkFDUmtCLE9BQU9tQixXQUFXO1lBQ3BCO1FBQ0YsRUFBRSxPQUFPckMsT0FBTztZQUNkLElBQUlBLGlCQUFpQjVCLFVBQVU7Z0JBQzdCLE1BQU00QjtZQUNSO1lBRUEsTUFBTSxJQUFJNUIsU0FDUiwrQkFDQSxXQUNBNEI7UUFFSjtJQUNGO0lBRUE7O0dBRUMsR0FDRCxNQUFNc0MscUJBQXFCMUQsT0FBbUIsRUFBd0I7UUFDcEUsTUFBTSxFQUFFMkQsYUFBYSxFQUFFQyxVQUFVLEVBQUUsR0FBRyxJQUFJLENBQUN6RCxNQUFNO1FBRWpELElBQUssSUFBSTBELFVBQVUsR0FBR0EsV0FBV0YsZUFBZUUsVUFBVztZQUN6RCxJQUFJO2dCQUNGLE9BQU8sTUFBTSxJQUFJLENBQUM5RCxXQUFXLENBQUNDO1lBQ2hDLEVBQUUsT0FBT29CLE9BQU87Z0JBQ2QsSUFBSUEsaUJBQWlCNUIsVUFBVTtvQkFDN0IsZ0NBQWdDO29CQUNoQyxJQUFJNEIsTUFBTXpCLElBQUksS0FBSyxjQUFjO3dCQUMvQixNQUFNeUI7b0JBQ1I7b0JBRUEsK0JBQStCO29CQUMvQixJQUFJeUMsWUFBWUYsZUFBZTt3QkFDN0IsTUFBTXZDO29CQUNSO29CQUVBLG9CQUFvQjtvQkFDcEIsTUFBTSxJQUFJMEMsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBU0gsYUFBYUM7Z0JBQ2hFLE9BQU87b0JBQ0wsTUFBTXpDO2dCQUNSO1lBQ0Y7UUFDRjtRQUVBLE1BQU0sSUFBSTVCLFNBQVMsOEJBQThCO0lBQ25EO0lBRUE7O0dBRUMsR0FDRCxtQkFBMkIwRSxPQUFlLEVBQVU7UUFDbEQsSUFBSSxPQUFPQSxZQUFZLFVBQVU7WUFDL0IsT0FBT0E7UUFDVDtRQUVBLDJCQUEyQjtRQUMzQixNQUFNbEIsUUFBUWtCLFFBQVFqQixLQUFLLENBQUM7UUFDNUIsTUFBTWtCLFlBQVksSUFBSUM7UUFDdEIsTUFBTUMsb0JBQThCLEVBQUU7UUFFdEMsS0FBSyxNQUFNbEIsUUFBUUgsTUFBTztZQUN4QixNQUFNc0IsY0FBY25CLEtBQUtDLElBQUk7WUFFN0IsMkNBQTJDO1lBQzNDLElBQUlrQixnQkFBZ0IsSUFBSTtnQkFDdEJELGtCQUFrQkUsSUFBSSxDQUFDcEI7Z0JBQ3ZCO1lBQ0Y7WUFFQSw4Q0FBOEM7WUFDOUMsSUFBSSxDQUFDZ0IsVUFBVUssR0FBRyxDQUFDRixjQUFjO2dCQUMvQkgsVUFBVU0sR0FBRyxDQUFDSDtnQkFDZEQsa0JBQWtCRSxJQUFJLENBQUNwQjtZQUN6QjtRQUNGO1FBRUEsT0FBT2tCLGtCQUFrQkssSUFBSSxDQUFDO0lBQ2hDO0lBRUE7O0dBRUMsR0FDRCxlQUF1QlIsT0FBWSxFQUFXO1FBQzVDLElBQUksQ0FBQ1UsTUFBTUMsT0FBTyxDQUFDWCxVQUFVLE9BQU87UUFFcEMsT0FBT0EsUUFBUVksSUFBSSxDQUFDQyxDQUFBQTtZQUNsQixJQUFJLENBQUNBLFFBQVEsT0FBT0EsU0FBUyxVQUFVLE9BQU87WUFFOUMsTUFBTUMsT0FBT2xFLE9BQU9rRSxJQUFJLENBQUNEO1lBQ3pCLE1BQU1FLFVBQVVELEtBQUtGLElBQUksQ0FBQ0ksQ0FBQUEsTUFBT0EsSUFBSTdCLFVBQVUsQ0FBQztZQUNoRCxNQUFNOEIsV0FBV0gsS0FBS0YsSUFBSSxDQUFDSSxDQUFBQSxNQUFPQSxJQUFJN0IsVUFBVSxDQUFDO1lBRWpELE9BQU80QixXQUFXRTtRQUNwQjtJQUNGO0lBRUE7O0dBRUMsR0FDRCxpQkFBeUI1RCxJQUFTLEVBQWU7UUFDL0MsSUFBSSxDQUFDQSxRQUFRLE9BQU9BLFNBQVMsVUFBVTtZQUNyQyw4REFBOEQ7WUFDOUQsT0FBTztnQkFDTDVCLE1BQU07Z0JBQ055RixhQUFhO2dCQUNibEIsU0FBU3RDLE9BQU9MO2dCQUNoQjhELFVBQVU7b0JBQUVDLFdBQVcsSUFBSUM7Z0JBQU87WUFDcEM7UUFDRjtRQUVBLG9EQUFvRDtRQUNwRCxJQUFJaEUsS0FBSzVCLElBQUksSUFBSTRCLEtBQUs2RCxXQUFXLElBQUk3RCxLQUFLMkMsT0FBTyxLQUFLc0IsV0FBVztZQUMvRCxPQUFPO2dCQUNMN0YsTUFBTTRCLEtBQUs1QixJQUFJO2dCQUNmeUYsYUFBYTdELEtBQUs2RCxXQUFXO2dCQUM3QmxCLFNBQVMzQyxLQUFLNkQsV0FBVyxLQUFLLFNBQVMsSUFBSSxDQUFDbkIsa0JBQWtCLENBQUMxQyxLQUFLMkMsT0FBTyxJQUFJM0MsS0FBSzJDLE9BQU87Z0JBQzNGbUIsVUFBVTlELEtBQUs4RCxRQUFRLElBQUk7b0JBQUVDLFdBQVcsSUFBSUM7Z0JBQU87WUFDckQ7UUFDRjtRQUVBLCtDQUErQztRQUMvQyxJQUFJckIsVUFBVTNDLEtBQUsyQyxPQUFPLElBQUkzQyxLQUFLN0IsT0FBTyxJQUFJNkIsS0FBS2YsUUFBUSxJQUFJZSxLQUFLSixJQUFJLElBQUlJLEtBQUtrRSxNQUFNLElBQUlsRTtRQUMzRixJQUFJNkQsY0FBYzdELEtBQUs2RCxXQUFXLElBQUk3RCxLQUFLbUUsTUFBTSxJQUFJO1FBQ3JELElBQUkvRixPQUFPNEIsS0FBSzVCLElBQUksSUFBSTtRQUV4QixrRUFBa0U7UUFDbEUsSUFBSTRCLEtBQUtrRSxNQUFNLElBQUksT0FBT2xFLEtBQUtrRSxNQUFNLEtBQUssVUFBVTtZQUNsRCxJQUFJO2dCQUNGLE1BQU1FLGVBQWVyRixLQUFLa0IsS0FBSyxDQUFDRCxLQUFLa0UsTUFBTTtnQkFDM0MsSUFBSUUsZ0JBQWdCLE9BQU9BLGlCQUFpQixVQUFVO29CQUNwRCxpRUFBaUU7b0JBQ2pFekIsVUFBVXlCLGFBQWF6QixPQUFPLElBQUl5QjtvQkFDbENQLGNBQWNPLGFBQWFQLFdBQVcsSUFBSUE7b0JBQzFDekYsT0FBT2dHLGFBQWFoRyxJQUFJLElBQUlBO2dCQUM5QjtZQUNGLEVBQUUsT0FBT3lCLE9BQU87Z0JBQ2QseURBQXlEO2dCQUN6RGhCLFFBQVFvRCxJQUFJLENBQUMsdUNBQXVDcEM7WUFDdEQ7UUFDRjtRQUVBLGlGQUFpRjtRQUNqRixJQUFJLElBQUksQ0FBQ3VELGNBQWMsQ0FBQ1QsVUFBVTtZQUNoQ2tCLGNBQWM7UUFDaEIsT0FBTyxJQUFJUixNQUFNQyxPQUFPLENBQUNYLFVBQVU7WUFDakMsd0RBQXdEO1lBQ3hEa0IsY0FBYztRQUNoQjtRQUVBLHVCQUF1QjtRQUN2QixJQUFJLENBQUM7WUFBQztZQUFRO1lBQVE7WUFBUztZQUFTO1lBQVM7U0FBUSxDQUFDdkQsUUFBUSxDQUFDdUQsY0FBYztZQUMvRUEsY0FBYztRQUNoQjtRQUVBLGdCQUFnQjtRQUNoQixJQUFJLENBQUM7WUFBQztZQUFXO1NBQVEsQ0FBQ3ZELFFBQVEsQ0FBQ2xDLE9BQU87WUFDeENBLE9BQU87UUFDVDtRQUVBLE9BQU87WUFDTEE7WUFDQXlGO1lBQ0FsQixTQUFTa0IsZ0JBQWdCLFNBQVMsSUFBSSxDQUFDbkIsa0JBQWtCLENBQUNDLFdBQVdBO1lBQ3JFbUIsVUFBVTlELEtBQUs4RCxRQUFRLElBQUk7Z0JBQ3pCQyxXQUFXLElBQUlDO2dCQUNmSyxRQUFRO2dCQUNSQyxrQkFBa0J0RTtZQUNwQjtRQUNGO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEdUUsU0FBZTtRQUNiLDREQUE0RDtRQUM1RDFGLFFBQVFDLEdBQUcsQ0FBQztJQUNkO0lBRUE7O0dBRUMsR0FDRCxNQUFNMEYsY0FBZ0M7UUFDcEMsSUFBSTtZQUNGLE1BQU12RixXQUFXLE1BQU1DLE1BQU0sR0FBMEIsT0FBdkIsSUFBSSxDQUFDTixNQUFNLENBQUNGLFVBQVUsRUFBQyxZQUFVO2dCQUMvRFMsUUFBUTtnQkFDUnNGLFFBQVFDLFlBQVkvRixPQUFPLENBQUM7WUFDOUI7WUFFQSxPQUFPTSxTQUFTUyxFQUFFO1FBQ3BCLEVBQUUsVUFBTTtZQUNOLE9BQU87UUFDVDtJQUNGO0lBbFZBLFlBQVlkLE1BQXVCLENBQUU7UUFDbkMsSUFBSSxDQUFDQSxNQUFNLEdBQUc7WUFDWkQsU0FBUztZQUNUeUQsZUFBZTtZQUNmQyxZQUFZO1lBQ1osR0FBR3pELE1BQU07UUFDWDtJQUNGO0FBNFVGO0FBRUEsaURBQWlEO0FBQzFDLFNBQVMrRixnQkFBZ0IvRixNQUF1QjtJQUNyRCxPQUFPLElBQUlMLFVBQVVLO0FBQ3ZCO0FBRUEsZ0JBQWdCO0FBQ1QsTUFBTWdHLG1CQUFtQjtJQUM5QixNQUFNQyxTQUFTRixnQkFBZ0I7UUFDN0JqRyxZQUFZb0csT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxlQUFlO1FBQ3ZDdkUsY0FBY3FFLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0UsaUJBQWlCO1FBQzNDdEcsU0FBUztRQUNUeUQsZUFBZTtRQUNmQyxZQUFZO0lBQ2Q7SUFFQSx3QkFBd0I7SUFDeEIsTUFBTTdELGNBQWM7UUFDbEIsSUFBSTtZQUNGLE1BQU1DLFVBQXNCO2dCQUMxQnlHLFVBQVU7Z0JBQ1YvRyxTQUFTO2dCQUNUcUMsV0FBVztnQkFDWHVELFdBQVcsSUFBSUM7WUFDakI7WUFFQSxNQUFNL0UsV0FBVyxNQUFNNEYsT0FBTzFDLG9CQUFvQixDQUFDMUQ7WUFDbkRJLFFBQVFDLEdBQUcsQ0FBQyxhQUFhRztRQUMzQixFQUFFLE9BQU9ZLE9BQU87WUFDZCxJQUFJQSxpQkFBaUI1QixVQUFVO2dCQUM3QlksUUFBUWdCLEtBQUssQ0FBQyxjQUFjQSxNQUFNMUIsT0FBTyxFQUFFMEIsTUFBTXpCLElBQUk7WUFDdkQsT0FBTztnQkFDTFMsUUFBUWdCLEtBQUssQ0FBQyxxQkFBcUJBO1lBQ3JDO1FBQ0Y7SUFDRjtJQUVBLDJCQUEyQjtJQUMzQixNQUFNVSxpQkFBaUI7UUFDckIsSUFBSTtZQUNGLE1BQU1DLFlBQVk7WUFFbEIsV0FBVyxNQUFNdkIsWUFBWTRGLE9BQU90RSxjQUFjLENBQUNDLFdBQVk7Z0JBQzdEM0IsUUFBUUMsR0FBRyxDQUFDLHVCQUF1Qkc7Z0JBRW5DLElBQUlBLFNBQVNiLElBQUksS0FBSyxTQUFTO29CQUM3QjtnQkFDRjtZQUNGO1FBQ0YsRUFBRSxPQUFPeUIsT0FBTztZQUNkaEIsUUFBUWdCLEtBQUssQ0FBQyxvQkFBb0JBO1FBQ3BDO0lBQ0Y7SUFFQSxPQUFPO1FBQUVyQjtRQUFhK0I7SUFBZTtBQUN2QyxFQUFFO0FBRUYsMENBQTBDO0FBQ25DLE1BQU00RSxXQUFXO0lBQ3RCOztHQUVDLEdBQ0RDLGFBQVl2RixLQUFlO1FBQ3pCLE9BQVFBLE1BQU16QixJQUFJO1lBQ2hCLEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNUO2dCQUNFLE9BQU87UUFDWDtJQUNGO0lBRUE7O0dBRUMsR0FDRGlILGtCQUFpQnBHLFFBQXFCO1FBQ3BDLE9BQU9BLFNBQVNiLElBQUksS0FBSztJQUMzQjtJQUVBOztHQUVDLEdBQ0RrSCxnQkFBZXJHLFFBQXFCO1FBQ2xDLE9BQU9BLFNBQVNiLElBQUksS0FBSztJQUMzQjtJQUVBOztHQUVDLEdBQ0RtSCxtQkFBa0J0RyxRQUFxQjtZQUM5QkE7UUFBUCxPQUFPQSxFQUFBQSxxQkFBQUEsU0FBUzZFLFFBQVEsY0FBakI3RSx5Q0FBQUEsbUJBQW1CdUcsY0FBYyxLQUFJO0lBQzlDO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiQzpcXEVidHRpa2FyIEludGVsbGlnZW5jZSBQcm9qZWN0c1xcVGVzdC1DaGF0LUFwcFxcbGliXFxuOG4tY2xpZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbjhuIFdlYmhvb2sgQ2xpZW50XG4gKiBIYW5kbGVzIGNvbW11bmljYXRpb24gd2l0aCBuOG4gd29ya2Zsb3dzIHZpYSB3ZWJob29rIGFuZCBzdHJlYW1pbmcgZW5kcG9pbnRzXG4gKi9cblxuaW1wb3J0IHsgTjhOUmVxdWVzdCwgTjhOUmVzcG9uc2UsIENoYXRFcnJvciB9IGZyb20gJ0AvdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgTjhORXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U6IHN0cmluZyxcbiAgICBwdWJsaWMgdHlwZTogJ25ldHdvcmsnIHwgJ3RpbWVvdXQnIHwgJ3NlcnZlcicgfCAndmFsaWRhdGlvbicsXG4gICAgcHVibGljIGRldGFpbHM/OiBhbnlcbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ044TkVycm9yJztcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE44TkNsaWVudENvbmZpZyB7XG4gIHdlYmhvb2tVcmw6IHN0cmluZztcbiAgc3RyZWFtaW5nVXJsOiBzdHJpbmc7XG4gIHRpbWVvdXQ/OiBudW1iZXI7XG4gIHJldHJ5QXR0ZW1wdHM/OiBudW1iZXI7XG4gIHJldHJ5RGVsYXk/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBOOE5DbGllbnQge1xuICBwcml2YXRlIGNvbmZpZzogUmVxdWlyZWQ8TjhOQ2xpZW50Q29uZmlnPjtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IE44TkNsaWVudENvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgdGltZW91dDogMTIwMDAwLCAvLyBJbmNyZWFzZWQgdG8gMiBtaW51dGVzIGZvciBBSSBwcm9jZXNzaW5nXG4gICAgICByZXRyeUF0dGVtcHRzOiAzLFxuICAgICAgcmV0cnlEZWxheTogMTAwMCxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIG1lc3NhZ2UgdG8gbjhuIHdlYmhvb2tcbiAgICovXG4gIGFzeW5jIHNlbmRNZXNzYWdlKHJlcXVlc3Q6IE44TlJlcXVlc3QpOiBQcm9taXNlPE44TlJlc3BvbnNlPiB7XG4gICAgY29uc3QgeyB3ZWJob29rVXJsLCB0aW1lb3V0IH0gPSB0aGlzLmNvbmZpZztcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJz09PSBOOE4gV0VCSE9PSyBERUJVRyA9PT0nKTtcbiAgICAgIGNvbnNvbGUubG9nKCdXZWJob29rIFVSTDonLCB3ZWJob29rVXJsKTtcbiAgICAgIGNvbnNvbGUubG9nKCdSZXF1ZXN0IHBheWxvYWQ6JywgSlNPTi5zdHJpbmdpZnkocmVxdWVzdCwgbnVsbCwgMikpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHdlYmhvb2tVcmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZSBoZWFkZXJzOicsIE9iamVjdC5mcm9tRW50cmllcyhyZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKSkpO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVzcG9uc2UgYm9keTonLCBlcnJvclRleHQpO1xuICAgICAgICB0aHJvdyBuZXcgTjhORXJyb3IoXG4gICAgICAgICAgYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCxcbiAgICAgICAgICAnc2VydmVyJyxcbiAgICAgICAgICB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLCBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LCBib2R5OiBlcnJvclRleHQgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZVRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBjb25zb2xlLmxvZygnUmF3IHJlc3BvbnNlOicsIHJlc3BvbnNlVGV4dCk7XG4gICAgICBcbiAgICAgIGxldCBkYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KTtcbiAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1Jlc3BvbnNlIGlzIG5vdCBKU09OLCB0cmVhdGluZyBhcyBwbGFpbiB0ZXh0Jyk7XG4gICAgICAgIGRhdGEgPSByZXNwb25zZVRleHQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdQYXJzZWQgcmVzcG9uc2UgZGF0YTonLCBkYXRhKTtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFJlc3BvbnNlID0gdGhpcy52YWxpZGF0ZVJlc3BvbnNlKGRhdGEpO1xuICAgICAgY29uc29sZS5sb2coJ1ZhbGlkYXRlZCByZXNwb25zZTonLCB2YWxpZGF0ZWRSZXNwb25zZSk7XG4gICAgICBjb25zb2xlLmxvZygnPT09IEVORCBOOE4gV0VCSE9PSyBERUJVRyA9PT0nKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHZhbGlkYXRlZFJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCc9PT0gTjhOIFdFQkhPT0sgRVJST1IgPT09Jyk7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZXRhaWxzOicsIGVycm9yKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHR5cGU6JywgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLmNvbnN0cnVjdG9yLm5hbWUgOiB0eXBlb2YgZXJyb3IpO1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbWVzc2FnZTonLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcikpO1xuICAgICAgY29uc29sZS5lcnJvcignPT09IEVORCBOOE4gV0VCSE9PSyBFUlJPUiA9PT0nKTtcbiAgICAgIFxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdUaW1lb3V0RXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgIHRocm93IG5ldyBOOE5FcnJvcignUmVxdWVzdCB0aW1lb3V0JywgJ3RpbWVvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2ZldGNoJykgfHwgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnbmV0d29yaycpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE44TkVycm9yKCdOZXR3b3JrIGVycm9yJywgJ25ldHdvcmsnLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCBzdHJlYW1pbmcgY29ubmVjdGlvbiBmb3IgcmVhbC10aW1lIHVwZGF0ZXNcbiAgICovXG4gIGFzeW5jICpzdHJlYW1NZXNzYWdlcyhzZXNzaW9uSWQ6IHN0cmluZyk6IEFzeW5jR2VuZXJhdG9yPE44TlJlc3BvbnNlLCB2b2lkLCB1bmtub3duPiB7XG4gICAgY29uc3QgeyBzdHJlYW1pbmdVcmwgfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoc3RyZWFtaW5nVXJsKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnc2Vzc2lvbklkJywgc2Vzc2lvbklkKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQWNjZXB0JzogJ3RleHQvZXZlbnQtc3RyZWFtJyxcbiAgICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZScsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgTjhORXJyb3IoXG4gICAgICAgICAgYFN0cmVhbWluZyBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWAsXG4gICAgICAgICAgJ3NlcnZlcicsXG4gICAgICAgICAgeyBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHk/LmdldFJlYWRlcigpO1xuICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IE44TkVycm9yKCdObyByZXNwb25zZSBib2R5JywgJ3NlcnZlcicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICBsZXQgYnVmZmVyID0gJyc7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICAgICAgXG4gICAgICAgICAgYnVmZmVyICs9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgICBjb25zdCBsaW5lcyA9IGJ1ZmZlci5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gS2VlcCB0aGUgbGFzdCBpbmNvbXBsZXRlIGxpbmUgaW4gYnVmZmVyXG4gICAgICAgICAgYnVmZmVyID0gbGluZXMucG9wKCkgfHwgJyc7XG4gICAgICAgICAgXG4gICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICBpZiAobGluZS50cmltKCkgPT09ICcnKSBjb250aW51ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnZGF0YTogJykpIHtcbiAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGxpbmUuc2xpY2UoNik7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gJ1tET05FXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMudmFsaWRhdGVSZXNwb25zZShwYXJzZWQpO1xuICAgICAgICAgICAgICAgIHlpZWxkIHJlc3BvbnNlO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIHN0cmVhbWluZyBkYXRhOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE44TkVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBuZXcgTjhORXJyb3IoXG4gICAgICAgICdTdHJlYW1pbmcgY29ubmVjdGlvbiBmYWlsZWQnLFxuICAgICAgICAnbmV0d29yaycsXG4gICAgICAgIGVycm9yXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIG1lc3NhZ2Ugd2l0aCByZXRyeSBsb2dpY1xuICAgKi9cbiAgYXN5bmMgc2VuZE1lc3NhZ2VXaXRoUmV0cnkocmVxdWVzdDogTjhOUmVxdWVzdCk6IFByb21pc2U8TjhOUmVzcG9uc2U+IHtcbiAgICBjb25zdCB7IHJldHJ5QXR0ZW1wdHMsIHJldHJ5RGVsYXkgfSA9IHRoaXMuY29uZmlnO1xuICAgIFxuICAgIGZvciAobGV0IGF0dGVtcHQgPSAxOyBhdHRlbXB0IDw9IHJldHJ5QXR0ZW1wdHM7IGF0dGVtcHQrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2UocmVxdWVzdCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBOOE5FcnJvcikge1xuICAgICAgICAgIC8vIERvbid0IHJldHJ5IHZhbGlkYXRpb24gZXJyb3JzXG4gICAgICAgICAgaWYgKGVycm9yLnR5cGUgPT09ICd2YWxpZGF0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIERvbid0IHJldHJ5IG9uIGZpbmFsIGF0dGVtcHRcbiAgICAgICAgICBpZiAoYXR0ZW1wdCA9PT0gcmV0cnlBdHRlbXB0cykge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFdhaXQgYmVmb3JlIHJldHJ5XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHJldHJ5RGVsYXkgKiBhdHRlbXB0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdGhyb3cgbmV3IE44TkVycm9yKCdNYXggcmV0cnkgYXR0ZW1wdHMgcmVhY2hlZCcsICduZXR3b3JrJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGR1cGxpY2F0ZSBjb250ZW50IGZyb20gcmVzcG9uc2VcbiAgICovXG4gIHByaXZhdGUgZGVkdXBsaWNhdGVDb250ZW50KGNvbnRlbnQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHR5cGVvZiBjb250ZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgLy8gU3BsaXQgY29udGVudCBpbnRvIGxpbmVzXG4gICAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCBzZWVuTGluZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBjb25zdCBkZWR1cGxpY2F0ZWRMaW5lczogc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIGNvbnN0IHRyaW1tZWRMaW5lID0gbGluZS50cmltKCk7XG4gICAgICBcbiAgICAgIC8vIFNraXAgZW1wdHkgbGluZXMgZm9yIGRlZHVwbGljYXRpb24gY2hlY2tcbiAgICAgIGlmICh0cmltbWVkTGluZSA9PT0gJycpIHtcbiAgICAgICAgZGVkdXBsaWNhdGVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIHdlIGhhdmVuJ3Qgc2VlbiB0aGlzIGxpbmUgYmVmb3JlLCBhZGQgaXRcbiAgICAgIGlmICghc2VlbkxpbmVzLmhhcyh0cmltbWVkTGluZSkpIHtcbiAgICAgICAgc2VlbkxpbmVzLmFkZCh0cmltbWVkTGluZSk7XG4gICAgICAgIGRlZHVwbGljYXRlZExpbmVzLnB1c2gobGluZSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBkZWR1cGxpY2F0ZWRMaW5lcy5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgaWYgY29udGVudCBpcyBtaXhlZCBmb3JtYXQgKGNvbnRhaW5zIHRleHQgYW5kIGNoYXJ0IGtleXMpXG4gICAqL1xuICBwcml2YXRlIGlzTWl4ZWRDb250ZW50KGNvbnRlbnQ6IGFueSk6IGJvb2xlYW4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjb250ZW50KSkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIHJldHVybiBjb250ZW50LnNvbWUoaXRlbSA9PiB7XG4gICAgICBpZiAoIWl0ZW0gfHwgdHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gICAgICBcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpdGVtKTtcbiAgICAgIGNvbnN0IGhhc1RleHQgPSBrZXlzLnNvbWUoa2V5ID0+IGtleS5zdGFydHNXaXRoKCd0ZXh0JykpO1xuICAgICAgY29uc3QgaGFzQ2hhcnQgPSBrZXlzLnNvbWUoa2V5ID0+IGtleS5zdGFydHNXaXRoKCdjaGFydCcpKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGhhc1RleHQgfHwgaGFzQ2hhcnQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgbjhuIHJlc3BvbnNlIGZvcm1hdFxuICAgKi9cbiAgcHJpdmF0ZSB2YWxpZGF0ZVJlc3BvbnNlKGRhdGE6IGFueSk6IE44TlJlc3BvbnNlIHtcbiAgICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBJZiB3ZSBnZXQgYSBzaW1wbGUgcmVzcG9uc2UsIHdyYXAgaXQgaW4gb3VyIGV4cGVjdGVkIGZvcm1hdFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2ZpbmFsJyxcbiAgICAgICAgbWVzc2FnZVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgY29udGVudDogU3RyaW5nKGRhdGEpLFxuICAgICAgICBtZXRhZGF0YTogeyB0aW1lc3RhbXA6IG5ldyBEYXRlKCkgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiByZXNwb25zZSBhbHJlYWR5IGhhcyBvdXIgZXhwZWN0ZWQgZm9ybWF0XG4gICAgaWYgKGRhdGEudHlwZSAmJiBkYXRhLm1lc3NhZ2VUeXBlICYmIGRhdGEuY29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBkYXRhLnR5cGUsXG4gICAgICAgIG1lc3NhZ2VUeXBlOiBkYXRhLm1lc3NhZ2VUeXBlLFxuICAgICAgICBjb250ZW50OiBkYXRhLm1lc3NhZ2VUeXBlID09PSAndGV4dCcgPyB0aGlzLmRlZHVwbGljYXRlQ29udGVudChkYXRhLmNvbnRlbnQpIDogZGF0YS5jb250ZW50LFxuICAgICAgICBtZXRhZGF0YTogZGF0YS5tZXRhZGF0YSB8fCB7IHRpbWVzdGFtcDogbmV3IERhdGUoKSB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB2YXJpb3VzIHBvc3NpYmxlIG44biByZXNwb25zZSBmb3JtYXRzXG4gICAgbGV0IGNvbnRlbnQgPSBkYXRhLmNvbnRlbnQgfHwgZGF0YS5tZXNzYWdlIHx8IGRhdGEucmVzcG9uc2UgfHwgZGF0YS50ZXh0IHx8IGRhdGEub3V0cHV0IHx8IGRhdGE7XG4gICAgbGV0IG1lc3NhZ2VUeXBlID0gZGF0YS5tZXNzYWdlVHlwZSB8fCBkYXRhLmZvcm1hdCB8fCAndGV4dCc7XG4gICAgbGV0IHR5cGUgPSBkYXRhLnR5cGUgfHwgJ2ZpbmFsJztcbiAgICBcbiAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBuOG4gb3V0cHV0IGZpZWxkIHRoYXQgY29udGFpbnMgSlNPTiBzdHJpbmdcbiAgICBpZiAoZGF0YS5vdXRwdXQgJiYgdHlwZW9mIGRhdGEub3V0cHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyc2VkT3V0cHV0ID0gSlNPTi5wYXJzZShkYXRhLm91dHB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRPdXRwdXQgJiYgdHlwZW9mIHBhcnNlZE91dHB1dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgb3V0cHV0IGNvbnRhaW5zIGEgdmFsaWQgSlNPTiBvYmplY3QsIHVzZSBpdCBhcyB0aGUgYmFzZVxuICAgICAgICAgIGNvbnRlbnQgPSBwYXJzZWRPdXRwdXQuY29udGVudCB8fCBwYXJzZWRPdXRwdXQ7XG4gICAgICAgICAgbWVzc2FnZVR5cGUgPSBwYXJzZWRPdXRwdXQubWVzc2FnZVR5cGUgfHwgbWVzc2FnZVR5cGU7XG4gICAgICAgICAgdHlwZSA9IHBhcnNlZE91dHB1dC50eXBlIHx8IHR5cGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIElmIHBhcnNpbmcgZmFpbHMsIHRyZWF0IG91dHB1dCBhcyByZWd1bGFyIHRleHQgY29udGVudFxuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBuOG4gb3V0cHV0IGFzIEpTT046JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBtaXhlZCBjb250ZW50IHJlc3BvbnNlIChhcnJheSB3aXRoIHRleHQvY2hhcnQgY29tYmluYXRpb25zKVxuICAgIGlmICh0aGlzLmlzTWl4ZWRDb250ZW50KGNvbnRlbnQpKSB7XG4gICAgICBtZXNzYWdlVHlwZSA9ICdtaXhlZCc7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnQpKSB7XG4gICAgICAvLyBJZiBpdCdzIGFuIGFycmF5IGJ1dCBub3QgbWl4ZWQgY29udGVudCwgdHJlYXQgYXMgSlNPTlxuICAgICAgbWVzc2FnZVR5cGUgPSAnanNvbic7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgbWVzc2FnZVR5cGVcbiAgICBpZiAoIVsndGV4dCcsICdqc29uJywgJ2ltYWdlJywgJ2NoYXJ0JywgJ2Vycm9yJywgJ21peGVkJ10uaW5jbHVkZXMobWVzc2FnZVR5cGUpKSB7XG4gICAgICBtZXNzYWdlVHlwZSA9ICd0ZXh0JztcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSB0eXBlXG4gICAgaWYgKCFbJ2ludGVyaW0nLCAnZmluYWwnXS5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgdHlwZSA9ICdmaW5hbCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGUsXG4gICAgICBtZXNzYWdlVHlwZSxcbiAgICAgIGNvbnRlbnQ6IG1lc3NhZ2VUeXBlID09PSAndGV4dCcgPyB0aGlzLmRlZHVwbGljYXRlQ29udGVudChjb250ZW50KSA6IGNvbnRlbnQsXG4gICAgICBtZXRhZGF0YTogZGF0YS5tZXRhZGF0YSB8fCB7IFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIHNvdXJjZTogJ244bi13ZWJob29rJyxcbiAgICAgICAgb3JpZ2luYWxSZXNwb25zZTogZGF0YVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIG9uZ29pbmcgcmVxdWVzdFxuICAgKi9cbiAgY2FuY2VsKCk6IHZvaWQge1xuICAgIC8vIFJlcXVlc3RzIG5vdyB1c2UgQWJvcnRTaWduYWwudGltZW91dCgpIHdoaWNoIGF1dG8tY2FuY2Vsc1xuICAgIGNvbnNvbGUubG9nKCdDYW5jZWwgcmVxdWVzdGVkIC0gdXNpbmcgdGltZW91dC1iYXNlZCBjYW5jZWxsYXRpb24nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWFsdGggY2hlY2sgZW5kcG9pbnRcbiAgICovXG4gIGFzeW5jIGhlYWx0aENoZWNrKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuY29uZmlnLndlYmhvb2tVcmx9L2hlYWx0aGAsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KDUwMDApLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiByZXNwb25zZS5vaztcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgY2xpZW50IGluc3RhbmNlc1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU44TkNsaWVudChjb25maWc6IE44TkNsaWVudENvbmZpZyk6IE44TkNsaWVudCB7XG4gIHJldHVybiBuZXcgTjhOQ2xpZW50KGNvbmZpZyk7XG59XG5cbi8vIEV4YW1wbGUgdXNhZ2VcbmV4cG9ydCBjb25zdCBuOG5DbGllbnRFeGFtcGxlID0gKCkgPT4ge1xuICBjb25zdCBjbGllbnQgPSBjcmVhdGVOOE5DbGllbnQoe1xuICAgIHdlYmhvb2tVcmw6IHByb2Nlc3MuZW52Lk44Tl9XRUJIT09LX1VSTCEsXG4gICAgc3RyZWFtaW5nVXJsOiBwcm9jZXNzLmVudi5OOE5fU1RSRUFNSU5HX1VSTCEsXG4gICAgdGltZW91dDogMzAwMDAsXG4gICAgcmV0cnlBdHRlbXB0czogMyxcbiAgICByZXRyeURlbGF5OiAxMDAwXG4gIH0pO1xuXG4gIC8vIEV4YW1wbGU6IFNlbmQgbWVzc2FnZVxuICBjb25zdCBzZW5kTWVzc2FnZSA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVxdWVzdDogTjhOUmVxdWVzdCA9IHtcbiAgICAgICAgdXNlcm5hbWU6ICd1c2VyMTIzJyxcbiAgICAgICAgbWVzc2FnZTogJ0hlbGxvLCBjYW4geW91IGFuYWx5emUgdGhpcyBkYXRhPycsXG4gICAgICAgIHNlc3Npb25JZDogJ3Nlc3Npb24tMTIzJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5zZW5kTWVzc2FnZVdpdGhSZXRyeShyZXF1ZXN0KTtcbiAgICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE44TkVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ044TiBFcnJvcjonLCBlcnJvci5tZXNzYWdlLCBlcnJvci50eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBFeGFtcGxlOiBTdHJlYW0gbWVzc2FnZXNcbiAgY29uc3Qgc3RyZWFtTWVzc2FnZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICdzZXNzaW9uLTEyMyc7XG4gICAgICBcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgcmVzcG9uc2Ugb2YgY2xpZW50LnN0cmVhbU1lc3NhZ2VzKHNlc3Npb25JZCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1N0cmVhbWluZyByZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ2ZpbmFsJykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1N0cmVhbWluZyBlcnJvcjonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7IHNlbmRNZXNzYWdlLCBzdHJlYW1NZXNzYWdlcyB9O1xufTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGNvbW1vbiBvcGVyYXRpb25zXG5leHBvcnQgY29uc3QgbjhuVXRpbHMgPSB7XG4gIC8qKlxuICAgKiBGb3JtYXQgZXJyb3IgZm9yIHVzZXIgZGlzcGxheVxuICAgKi9cbiAgZm9ybWF0RXJyb3IoZXJyb3I6IE44TkVycm9yKTogc3RyaW5nIHtcbiAgICBzd2l0Y2ggKGVycm9yLnR5cGUpIHtcbiAgICAgIGNhc2UgJ25ldHdvcmsnOlxuICAgICAgICByZXR1cm4gJ05ldHdvcmsgY29ubmVjdGlvbiBmYWlsZWQuIFBsZWFzZSBjaGVjayB5b3VyIGludGVybmV0IGNvbm5lY3Rpb24uJztcbiAgICAgIGNhc2UgJ3RpbWVvdXQnOlxuICAgICAgICByZXR1cm4gJ1JlcXVlc3QgdGltZWQgb3V0LiBUaGUgd29ya2Zsb3cgbWF5IGJlIHRha2luZyBsb25nZXIgdGhhbiBleHBlY3RlZC4nO1xuICAgICAgY2FzZSAnc2VydmVyJzpcbiAgICAgICAgcmV0dXJuICdTZXJ2ZXIgZXJyb3Igb2NjdXJyZWQuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJztcbiAgICAgIGNhc2UgJ3ZhbGlkYXRpb24nOlxuICAgICAgICByZXR1cm4gJ0ludmFsaWQgZGF0YSBmb3JtYXQuIFBsZWFzZSBjb250YWN0IHN1cHBvcnQuJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZC4gUGxlYXNlIHRyeSBhZ2Fpbi4nO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgcmVzcG9uc2UgaXMgaW50ZXJpbSBtZXNzYWdlXG4gICAqL1xuICBpc0ludGVyaW1NZXNzYWdlKHJlc3BvbnNlOiBOOE5SZXNwb25zZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiByZXNwb25zZS50eXBlID09PSAnaW50ZXJpbSc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHJlc3BvbnNlIGlzIGZpbmFsIG1lc3NhZ2VcbiAgICovXG4gIGlzRmluYWxNZXNzYWdlKHJlc3BvbnNlOiBOOE5SZXNwb25zZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiByZXNwb25zZS50eXBlID09PSAnZmluYWwnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHByb2Nlc3NpbmcgdGltZSBmcm9tIG1ldGFkYXRhXG4gICAqL1xuICBnZXRQcm9jZXNzaW5nVGltZShyZXNwb25zZTogTjhOUmVzcG9uc2UpOiBudW1iZXIgfCBudWxsIHtcbiAgICByZXR1cm4gcmVzcG9uc2UubWV0YWRhdGE/LnByb2Nlc3NpbmdUaW1lIHx8IG51bGw7XG4gIH1cbn07Il0sIm5hbWVzIjpbIk44TkVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwidHlwZSIsImRldGFpbHMiLCJuYW1lIiwiTjhOQ2xpZW50Iiwic2VuZE1lc3NhZ2UiLCJyZXF1ZXN0Iiwid2ViaG9va1VybCIsInRpbWVvdXQiLCJjb25maWciLCJjb25zb2xlIiwibG9nIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsInN0YXR1cyIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsIm9rIiwiZXJyb3JUZXh0IiwidGV4dCIsImVycm9yIiwic3RhdHVzVGV4dCIsInJlc3BvbnNlVGV4dCIsImRhdGEiLCJwYXJzZSIsInBhcnNlRXJyb3IiLCJ2YWxpZGF0ZWRSZXNwb25zZSIsInZhbGlkYXRlUmVzcG9uc2UiLCJTdHJpbmciLCJpbmNsdWRlcyIsInN0cmVhbU1lc3NhZ2VzIiwic2Vzc2lvbklkIiwic3RyZWFtaW5nVXJsIiwidXJsIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwic2V0IiwidG9TdHJpbmciLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJidWZmZXIiLCJkb25lIiwidmFsdWUiLCJyZWFkIiwiZGVjb2RlIiwic3RyZWFtIiwibGluZXMiLCJzcGxpdCIsInBvcCIsImxpbmUiLCJ0cmltIiwic3RhcnRzV2l0aCIsInNsaWNlIiwicGFyc2VkIiwid2FybiIsInJlbGVhc2VMb2NrIiwic2VuZE1lc3NhZ2VXaXRoUmV0cnkiLCJyZXRyeUF0dGVtcHRzIiwicmV0cnlEZWxheSIsImF0dGVtcHQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJkZWR1cGxpY2F0ZUNvbnRlbnQiLCJjb250ZW50Iiwic2VlbkxpbmVzIiwiU2V0IiwiZGVkdXBsaWNhdGVkTGluZXMiLCJ0cmltbWVkTGluZSIsInB1c2giLCJoYXMiLCJhZGQiLCJqb2luIiwiaXNNaXhlZENvbnRlbnQiLCJBcnJheSIsImlzQXJyYXkiLCJzb21lIiwiaXRlbSIsImtleXMiLCJoYXNUZXh0Iiwia2V5IiwiaGFzQ2hhcnQiLCJtZXNzYWdlVHlwZSIsIm1ldGFkYXRhIiwidGltZXN0YW1wIiwiRGF0ZSIsInVuZGVmaW5lZCIsIm91dHB1dCIsImZvcm1hdCIsInBhcnNlZE91dHB1dCIsInNvdXJjZSIsIm9yaWdpbmFsUmVzcG9uc2UiLCJjYW5jZWwiLCJoZWFsdGhDaGVjayIsInNpZ25hbCIsIkFib3J0U2lnbmFsIiwiY3JlYXRlTjhOQ2xpZW50IiwibjhuQ2xpZW50RXhhbXBsZSIsImNsaWVudCIsInByb2Nlc3MiLCJlbnYiLCJOOE5fV0VCSE9PS19VUkwiLCJOOE5fU1RSRUFNSU5HX1VSTCIsInVzZXJuYW1lIiwibjhuVXRpbHMiLCJmb3JtYXRFcnJvciIsImlzSW50ZXJpbU1lc3NhZ2UiLCJpc0ZpbmFsTWVzc2FnZSIsImdldFByb2Nlc3NpbmdUaW1lIiwicHJvY2Vzc2luZ1RpbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/n8n-client.ts\n"));

/***/ })

});