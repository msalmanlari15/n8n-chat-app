"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/n8n-client.ts":
/*!***************************!*\
  !*** ./lib/n8n-client.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   N8NClient: () => (/* binding */ N8NClient),\n/* harmony export */   N8NError: () => (/* binding */ N8NError),\n/* harmony export */   createN8NClient: () => (/* binding */ createN8NClient),\n/* harmony export */   n8nClientExample: () => (/* binding */ n8nClientExample),\n/* harmony export */   n8nUtils: () => (/* binding */ n8nUtils)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * n8n Webhook Client\n * Handles communication with n8n workflows via webhook and streaming endpoints\n */ class N8NError extends Error {\n    constructor(message, type, details){\n        super(message), this.type = type, this.details = details;\n        this.name = 'N8NError';\n    }\n}\nclass N8NClient {\n    /**\n   * Send a message to n8n webhook\n   */ async sendMessage(request) {\n        const { webhookUrl, timeout } = this.config;\n        this.abortController = new AbortController();\n        const timeoutId = setTimeout(()=>{\n            if (this.abortController) {\n                this.abortController.abort('Request timeout');\n            }\n        }, timeout);\n        try {\n            console.log('=== N8N WEBHOOK DEBUG ===');\n            console.log('Webhook URL:', webhookUrl);\n            console.log('Request payload:', JSON.stringify(request, null, 2));\n            const response = await fetch(webhookUrl, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Accept': 'application/json'\n                },\n                body: JSON.stringify(request),\n                signal: this.abortController.signal\n            });\n            clearTimeout(timeoutId);\n            console.log('Response status:', response.status);\n            console.log('Response headers:', Object.fromEntries(response.headers.entries()));\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('Error response body:', errorText);\n                throw new N8NError(\"HTTP \".concat(response.status, \": \").concat(response.statusText), 'server', {\n                    status: response.status,\n                    statusText: response.statusText,\n                    body: errorText\n                });\n            }\n            const responseText = await response.text();\n            console.log('Raw response:', responseText);\n            let data;\n            try {\n                data = JSON.parse(responseText);\n            } catch (parseError) {\n                console.log('Response is not JSON, treating as plain text');\n                data = responseText;\n            }\n            console.log('Parsed response data:', data);\n            const validatedResponse = this.validateResponse(data);\n            console.log('Validated response:', validatedResponse);\n            console.log('=== END N8N WEBHOOK DEBUG ===');\n            return validatedResponse;\n        } catch (error) {\n            clearTimeout(timeoutId);\n            console.error('=== N8N WEBHOOK ERROR ===');\n            console.error('Error details:', error);\n            console.error('Error type:', error instanceof Error ? error.constructor.name : typeof error);\n            console.error('Error message:', error instanceof Error ? error.message : String(error));\n            console.error('=== END N8N WEBHOOK ERROR ===');\n            if (error instanceof Error) {\n                if (error.name === 'AbortError') {\n                    throw new N8NError('Request timeout', 'timeout');\n                }\n                if (error.message.includes('fetch') || error.message.includes('network')) {\n                    throw new N8NError('Network error', 'network', error);\n                }\n            }\n            throw error;\n        }\n    }\n    /**\n   * Set up streaming connection for real-time updates\n   */ async *streamMessages(sessionId) {\n        const { streamingUrl } = this.config;\n        const url = new URL(streamingUrl);\n        url.searchParams.set('sessionId', sessionId);\n        try {\n            var _response_body;\n            const response = await fetch(url.toString(), {\n                headers: {\n                    'Accept': 'text/event-stream',\n                    'Cache-Control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                throw new N8NError(\"Streaming failed: \".concat(response.status), 'server', {\n                    status: response.status\n                });\n            }\n            const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n            if (!reader) {\n                throw new N8NError('No response body', 'server');\n            }\n            const decoder = new TextDecoder();\n            let buffer = '';\n            try {\n                while(true){\n                    const { done, value } = await reader.read();\n                    if (done) break;\n                    buffer += decoder.decode(value, {\n                        stream: true\n                    });\n                    const lines = buffer.split('\\n');\n                    // Keep the last incomplete line in buffer\n                    buffer = lines.pop() || '';\n                    for (const line of lines){\n                        if (line.trim() === '') continue;\n                        if (line.startsWith('data: ')) {\n                            const data = line.slice(6);\n                            if (data === '[DONE]') {\n                                return;\n                            }\n                            try {\n                                const parsed = JSON.parse(data);\n                                const response = this.validateResponse(parsed);\n                                yield response;\n                            } catch (error) {\n                                console.warn('Failed to parse streaming data:', error);\n                            }\n                        }\n                    }\n                }\n            } finally{\n                reader.releaseLock();\n            }\n        } catch (error) {\n            if (error instanceof N8NError) {\n                throw error;\n            }\n            throw new N8NError('Streaming connection failed', 'network', error);\n        }\n    }\n    /**\n   * Send message with retry logic\n   */ async sendMessageWithRetry(request) {\n        const { retryAttempts, retryDelay } = this.config;\n        for(let attempt = 1; attempt <= retryAttempts; attempt++){\n            try {\n                return await this.sendMessage(request);\n            } catch (error) {\n                if (error instanceof N8NError) {\n                    // Don't retry validation errors\n                    if (error.type === 'validation') {\n                        throw error;\n                    }\n                    // Don't retry on final attempt\n                    if (attempt === retryAttempts) {\n                        throw error;\n                    }\n                    // Wait before retry\n                    await new Promise((resolve)=>setTimeout(resolve, retryDelay * attempt));\n                } else {\n                    throw error;\n                }\n            }\n        }\n        throw new N8NError('Max retry attempts reached', 'network');\n    }\n    /**\n   * Remove duplicate content from response\n   */ deduplicateContent(content) {\n        if (typeof content !== 'string') {\n            return content;\n        }\n        // Split content into lines\n        const lines = content.split('\\n');\n        const seenLines = new Set();\n        const deduplicatedLines = [];\n        for (const line of lines){\n            const trimmedLine = line.trim();\n            // Skip empty lines for deduplication check\n            if (trimmedLine === '') {\n                deduplicatedLines.push(line);\n                continue;\n            }\n            // If we haven't seen this line before, add it\n            if (!seenLines.has(trimmedLine)) {\n                seenLines.add(trimmedLine);\n                deduplicatedLines.push(line);\n            }\n        }\n        return deduplicatedLines.join('\\n');\n    }\n    /**\n   * Detect if content is mixed format (contains text and chart keys)\n   */ isMixedContent(content) {\n        if (!Array.isArray(content)) return false;\n        return content.some((item)=>{\n            if (!item || typeof item !== 'object') return false;\n            const keys = Object.keys(item);\n            const hasText = keys.some((key)=>key.startsWith('text'));\n            const hasChart = keys.some((key)=>key.startsWith('chart'));\n            return hasText || hasChart;\n        });\n    }\n    /**\n   * Validate n8n response format\n   */ validateResponse(data) {\n        if (!data || typeof data !== 'object') {\n            // If we get a simple response, wrap it in our expected format\n            return {\n                type: 'final',\n                messageType: 'text',\n                content: String(data),\n                metadata: {\n                    timestamp: new Date()\n                }\n            };\n        }\n        // Check if response already has our expected format\n        if (data.type && data.messageType && data.content !== undefined) {\n            return {\n                type: data.type,\n                messageType: data.messageType,\n                content: data.messageType === 'text' ? this.deduplicateContent(data.content) : data.content,\n                metadata: data.metadata || {\n                    timestamp: new Date()\n                }\n            };\n        }\n        // Handle various possible n8n response formats\n        let content = data.content || data.message || data.response || data.text || data.output || data;\n        let messageType = data.messageType || data.format || 'text';\n        let type = data.type || 'final';\n        // Special handling for n8n output field that contains JSON string\n        if (data.output && typeof data.output === 'string') {\n            try {\n                const parsedOutput = JSON.parse(data.output);\n                if (parsedOutput && typeof parsedOutput === 'object') {\n                    // If the output contains a valid JSON object, use it as the base\n                    content = parsedOutput.content || parsedOutput;\n                    messageType = parsedOutput.messageType || messageType;\n                    type = parsedOutput.type || type;\n                }\n            } catch (error) {\n                // If parsing fails, treat output as regular text content\n                console.warn('Failed to parse n8n output as JSON:', error);\n            }\n        }\n        // Check if this is a mixed content response (array with text/chart combinations)\n        if (this.isMixedContent(content)) {\n            messageType = 'mixed';\n        } else if (Array.isArray(content)) {\n            // If it's an array but not mixed content, treat as JSON\n            messageType = 'json';\n        }\n        // Validate messageType\n        if (![\n            'text',\n            'json',\n            'image',\n            'chart',\n            'error',\n            'mixed'\n        ].includes(messageType)) {\n            messageType = 'text';\n        }\n        // Validate type\n        if (![\n            'interim',\n            'final'\n        ].includes(type)) {\n            type = 'final';\n        }\n        return {\n            type,\n            messageType,\n            content: messageType === 'text' ? this.deduplicateContent(content) : content,\n            metadata: data.metadata || {\n                timestamp: new Date(),\n                source: 'n8n-webhook',\n                originalResponse: data\n            }\n        };\n    }\n    /**\n   * Cancel ongoing request\n   */ cancel() {\n        if (this.abortController) {\n            this.abortController.abort();\n            this.abortController = null;\n        }\n    }\n    /**\n   * Health check endpoint\n   */ async healthCheck() {\n        try {\n            const response = await fetch(\"\".concat(this.config.webhookUrl, \"/health\"), {\n                method: 'GET',\n                signal: AbortSignal.timeout(5000)\n            });\n            return response.ok;\n        } catch (e) {\n            return false;\n        }\n    }\n    constructor(config){\n        this.abortController = null;\n        this.config = {\n            timeout: 120000,\n            retryAttempts: 3,\n            retryDelay: 1000,\n            ...config\n        };\n    }\n}\n// Factory function for creating client instances\nfunction createN8NClient(config) {\n    return new N8NClient(config);\n}\n// Example usage\nconst n8nClientExample = ()=>{\n    const client = createN8NClient({\n        webhookUrl: process.env.N8N_WEBHOOK_URL,\n        streamingUrl: process.env.N8N_STREAMING_URL,\n        timeout: 30000,\n        retryAttempts: 3,\n        retryDelay: 1000\n    });\n    // Example: Send message\n    const sendMessage = async ()=>{\n        try {\n            const request = {\n                username: 'user123',\n                message: 'Hello, can you analyze this data?',\n                sessionId: 'session-123',\n                timestamp: new Date()\n            };\n            const response = await client.sendMessageWithRetry(request);\n            console.log('Response:', response);\n        } catch (error) {\n            if (error instanceof N8NError) {\n                console.error('N8N Error:', error.message, error.type);\n            } else {\n                console.error('Unexpected error:', error);\n            }\n        }\n    };\n    // Example: Stream messages\n    const streamMessages = async ()=>{\n        try {\n            const sessionId = 'session-123';\n            for await (const response of client.streamMessages(sessionId)){\n                console.log('Streaming response:', response);\n                if (response.type === 'final') {\n                    break;\n                }\n            }\n        } catch (error) {\n            console.error('Streaming error:', error);\n        }\n    };\n    return {\n        sendMessage,\n        streamMessages\n    };\n};\n// Utility functions for common operations\nconst n8nUtils = {\n    /**\n   * Format error for user display\n   */ formatError (error) {\n        switch(error.type){\n            case 'network':\n                return 'Network connection failed. Please check your internet connection.';\n            case 'timeout':\n                return 'Request timed out. The workflow may be taking longer than expected.';\n            case 'server':\n                return 'Server error occurred. Please try again later.';\n            case 'validation':\n                return 'Invalid data format. Please contact support.';\n            default:\n                return 'An unexpected error occurred. Please try again.';\n        }\n    },\n    /**\n   * Check if response is interim message\n   */ isInterimMessage (response) {\n        return response.type === 'interim';\n    },\n    /**\n   * Check if response is final message\n   */ isFinalMessage (response) {\n        return response.type === 'final';\n    },\n    /**\n   * Extract processing time from metadata\n   */ getProcessingTime (response) {\n        var _response_metadata;\n        return ((_response_metadata = response.metadata) === null || _response_metadata === void 0 ? void 0 : _response_metadata.processingTime) || null;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OUM7QUFDRixFQUFFIiwic291cmNlcyI6WyJDOlxcRWJ0dGlrYXIgSW50ZWxsaWdlbmNlIFByb2plY3RzXFxUZXN0LUNoYXQtQXBwXFxsaWJcXG44bi1jbGllbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBuOG4gV2ViaG9vayBDbGllbnRcbiAqIEhhbmRsZXMgY29tbXVuaWNhdGlvbiB3aXRoIG44biB3b3JrZmxvd3MgdmlhIHdlYmhvb2sgYW5kIHN0cmVhbWluZyBlbmRwb2ludHNcbiAqL1xuXG5pbXBvcnQgeyBOOE5SZXF1ZXN0LCBOOE5SZXNwb25zZSwgQ2hhdEVycm9yIH0gZnJvbSAnQC90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBOOE5FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIHB1YmxpYyB0eXBlOiAnbmV0d29yaycgfCAndGltZW91dCcgfCAnc2VydmVyJyB8ICd2YWxpZGF0aW9uJyxcbiAgICBwdWJsaWMgZGV0YWlscz86IGFueVxuICApIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnTjhORXJyb3InO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTjhOQ2xpZW50Q29uZmlnIHtcbiAgd2ViaG9va1VybDogc3RyaW5nO1xuICBzdHJlYW1pbmdVcmw6IHN0cmluZztcbiAgdGltZW91dD86IG51bWJlcjtcbiAgcmV0cnlBdHRlbXB0cz86IG51bWJlcjtcbiAgcmV0cnlEZWxheT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIE44TkNsaWVudCB7XG4gIHByaXZhdGUgY29uZmlnOiBSZXF1aXJlZDxOOE5DbGllbnRDb25maWc+O1xuICBwcml2YXRlIGFib3J0Q29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBOOE5DbGllbnRDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIHRpbWVvdXQ6IDEyMDAwMCwgLy8gSW5jcmVhc2VkIHRvIDIgbWludXRlcyBmb3IgQUkgcHJvY2Vzc2luZ1xuICAgICAgcmV0cnlBdHRlbXB0czogMyxcbiAgICAgIHJldHJ5RGVsYXk6IDEwMDAsXG4gICAgICAuLi5jb25maWdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBtZXNzYWdlIHRvIG44biB3ZWJob29rXG4gICAqL1xuICBhc3luYyBzZW5kTWVzc2FnZShyZXF1ZXN0OiBOOE5SZXF1ZXN0KTogUHJvbWlzZTxOOE5SZXNwb25zZT4ge1xuICAgIGNvbnN0IHsgd2ViaG9va1VybCwgdGltZW91dCB9ID0gdGhpcy5jb25maWc7XG4gICAgXG4gICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5hYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoJ1JlcXVlc3QgdGltZW91dCcpO1xuICAgICAgfVxuICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCc9PT0gTjhOIFdFQkhPT0sgREVCVUcgPT09Jyk7XG4gICAgICBjb25zb2xlLmxvZygnV2ViaG9vayBVUkw6Jywgd2ViaG9va1VybCk7XG4gICAgICBjb25zb2xlLmxvZygnUmVxdWVzdCBwYXlsb2FkOicsIEpTT04uc3RyaW5naWZ5KHJlcXVlc3QsIG51bGwsIDIpKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh3ZWJob29rVXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSxcbiAgICAgICAgc2lnbmFsOiB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICB9KTtcblxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZSBoZWFkZXJzOicsIE9iamVjdC5mcm9tRW50cmllcyhyZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKSkpO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVzcG9uc2UgYm9keTonLCBlcnJvclRleHQpO1xuICAgICAgICB0aHJvdyBuZXcgTjhORXJyb3IoXG4gICAgICAgICAgYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCxcbiAgICAgICAgICAnc2VydmVyJyxcbiAgICAgICAgICB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLCBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LCBib2R5OiBlcnJvclRleHQgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZVRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBjb25zb2xlLmxvZygnUmF3IHJlc3BvbnNlOicsIHJlc3BvbnNlVGV4dCk7XG4gICAgICBcbiAgICAgIGxldCBkYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KTtcbiAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1Jlc3BvbnNlIGlzIG5vdCBKU09OLCB0cmVhdGluZyBhcyBwbGFpbiB0ZXh0Jyk7XG4gICAgICAgIGRhdGEgPSByZXNwb25zZVRleHQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdQYXJzZWQgcmVzcG9uc2UgZGF0YTonLCBkYXRhKTtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFJlc3BvbnNlID0gdGhpcy52YWxpZGF0ZVJlc3BvbnNlKGRhdGEpO1xuICAgICAgY29uc29sZS5sb2coJ1ZhbGlkYXRlZCByZXNwb25zZTonLCB2YWxpZGF0ZWRSZXNwb25zZSk7XG4gICAgICBjb25zb2xlLmxvZygnPT09IEVORCBOOE4gV0VCSE9PSyBERUJVRyA9PT0nKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHZhbGlkYXRlZFJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJz09PSBOOE4gV0VCSE9PSyBFUlJPUiA9PT0nKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6JywgZXJyb3IpO1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdHlwZTonLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IuY29uc3RydWN0b3IubmFtZSA6IHR5cGVvZiBlcnJvcik7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBtZXNzYWdlOicsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSk7XG4gICAgICBjb25zb2xlLmVycm9yKCc9PT0gRU5EIE44TiBXRUJIT09LIEVSUk9SID09PScpO1xuICAgICAgXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE44TkVycm9yKCdSZXF1ZXN0IHRpbWVvdXQnLCAndGltZW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZmV0Y2gnKSB8fCBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCduZXR3b3JrJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTjhORXJyb3IoJ05ldHdvcmsgZXJyb3InLCAnbmV0d29yaycsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIHN0cmVhbWluZyBjb25uZWN0aW9uIGZvciByZWFsLXRpbWUgdXBkYXRlc1xuICAgKi9cbiAgYXN5bmMgKnN0cmVhbU1lc3NhZ2VzKHNlc3Npb25JZDogc3RyaW5nKTogQXN5bmNHZW5lcmF0b3I8TjhOUmVzcG9uc2UsIHZvaWQsIHVua25vd24+IHtcbiAgICBjb25zdCB7IHN0cmVhbWluZ1VybCB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChzdHJlYW1pbmdVcmwpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdzZXNzaW9uSWQnLCBzZXNzaW9uSWQpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBY2NlcHQnOiAndGV4dC9ldmVudC1zdHJlYW0nLFxuICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBOOE5FcnJvcihcbiAgICAgICAgICBgU3RyZWFtaW5nIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9YCxcbiAgICAgICAgICAnc2VydmVyJyxcbiAgICAgICAgICB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzIH1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keT8uZ2V0UmVhZGVyKCk7XG4gICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgTjhORXJyb3IoJ05vIHJlc3BvbnNlIGJvZHknLCAnc2VydmVyJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgIGxldCBidWZmZXIgPSAnJztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgICAgICBcbiAgICAgICAgICBidWZmZXIgKz0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgIGNvbnN0IGxpbmVzID0gYnVmZmVyLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBLZWVwIHRoZSBsYXN0IGluY29tcGxldGUgbGluZSBpbiBidWZmZXJcbiAgICAgICAgICBidWZmZXIgPSBsaW5lcy5wb3AoKSB8fCAnJztcbiAgICAgICAgICBcbiAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICAgIGlmIChsaW5lLnRyaW0oKSA9PT0gJycpIGNvbnRpbnVlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKCdkYXRhOiAnKSkge1xuICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbGluZS5zbGljZSg2KTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChkYXRhID09PSAnW0RPTkVdJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy52YWxpZGF0ZVJlc3BvbnNlKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgeWllbGQgcmVzcG9uc2U7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtaW5nIGRhdGE6JywgZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgTjhORXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IG5ldyBOOE5FcnJvcihcbiAgICAgICAgJ1N0cmVhbWluZyBjb25uZWN0aW9uIGZhaWxlZCcsXG4gICAgICAgICduZXR3b3JrJyxcbiAgICAgICAgZXJyb3JcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgbWVzc2FnZSB3aXRoIHJldHJ5IGxvZ2ljXG4gICAqL1xuICBhc3luYyBzZW5kTWVzc2FnZVdpdGhSZXRyeShyZXF1ZXN0OiBOOE5SZXF1ZXN0KTogUHJvbWlzZTxOOE5SZXNwb25zZT4ge1xuICAgIGNvbnN0IHsgcmV0cnlBdHRlbXB0cywgcmV0cnlEZWxheSB9ID0gdGhpcy5jb25maWc7XG4gICAgXG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gcmV0cnlBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZShyZXF1ZXN0KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE44TkVycm9yKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgcmV0cnkgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICAgICAgICBpZiAoZXJyb3IudHlwZSA9PT0gJ3ZhbGlkYXRpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRG9uJ3QgcmV0cnkgb24gZmluYWwgYXR0ZW1wdFxuICAgICAgICAgIGlmIChhdHRlbXB0ID09PSByZXRyeUF0dGVtcHRzKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gV2FpdCBiZWZvcmUgcmV0cnlcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheSAqIGF0dGVtcHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aHJvdyBuZXcgTjhORXJyb3IoJ01heCByZXRyeSBhdHRlbXB0cyByZWFjaGVkJywgJ25ldHdvcmsnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgZHVwbGljYXRlIGNvbnRlbnQgZnJvbSByZXNwb25zZVxuICAgKi9cbiAgcHJpdmF0ZSBkZWR1cGxpY2F0ZUNvbnRlbnQoY29udGVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG5cbiAgICAvLyBTcGxpdCBjb250ZW50IGludG8gbGluZXNcbiAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IHNlZW5MaW5lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IGRlZHVwbGljYXRlZExpbmVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgY29uc3QgdHJpbW1lZExpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgIFxuICAgICAgLy8gU2tpcCBlbXB0eSBsaW5lcyBmb3IgZGVkdXBsaWNhdGlvbiBjaGVja1xuICAgICAgaWYgKHRyaW1tZWRMaW5lID09PSAnJykge1xuICAgICAgICBkZWR1cGxpY2F0ZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBzZWVuIHRoaXMgbGluZSBiZWZvcmUsIGFkZCBpdFxuICAgICAgaWYgKCFzZWVuTGluZXMuaGFzKHRyaW1tZWRMaW5lKSkge1xuICAgICAgICBzZWVuTGluZXMuYWRkKHRyaW1tZWRMaW5lKTtcbiAgICAgICAgZGVkdXBsaWNhdGVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGRlZHVwbGljYXRlZExpbmVzLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBjb250ZW50IGlzIG1peGVkIGZvcm1hdCAoY29udGFpbnMgdGV4dCBhbmQgY2hhcnQga2V5cylcbiAgICovXG4gIHByaXZhdGUgaXNNaXhlZENvbnRlbnQoY29udGVudDogYW55KTogYm9vbGVhbiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbnRlbnQpKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgcmV0dXJuIGNvbnRlbnQuc29tZShpdGVtID0+IHtcbiAgICAgIGlmICghaXRlbSB8fCB0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICAgIFxuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGl0ZW0pO1xuICAgICAgY29uc3QgaGFzVGV4dCA9IGtleXMuc29tZShrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ3RleHQnKSk7XG4gICAgICBjb25zdCBoYXNDaGFydCA9IGtleXMuc29tZShrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ2NoYXJ0JykpO1xuICAgICAgXG4gICAgICByZXR1cm4gaGFzVGV4dCB8fCBoYXNDaGFydDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBuOG4gcmVzcG9uc2UgZm9ybWF0XG4gICAqL1xuICBwcml2YXRlIHZhbGlkYXRlUmVzcG9uc2UoZGF0YTogYW55KTogTjhOUmVzcG9uc2Uge1xuICAgIGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIElmIHdlIGdldCBhIHNpbXBsZSByZXNwb25zZSwgd3JhcCBpdCBpbiBvdXIgZXhwZWN0ZWQgZm9ybWF0XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZmluYWwnLFxuICAgICAgICBtZXNzYWdlVHlwZTogJ3RleHQnLFxuICAgICAgICBjb250ZW50OiBTdHJpbmcoZGF0YSksXG4gICAgICAgIG1ldGFkYXRhOiB7IHRpbWVzdGFtcDogbmV3IERhdGUoKSB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHJlc3BvbnNlIGFscmVhZHkgaGFzIG91ciBleHBlY3RlZCBmb3JtYXRcbiAgICBpZiAoZGF0YS50eXBlICYmIGRhdGEubWVzc2FnZVR5cGUgJiYgZGF0YS5jb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGRhdGEudHlwZSxcbiAgICAgICAgbWVzc2FnZVR5cGU6IGRhdGEubWVzc2FnZVR5cGUsXG4gICAgICAgIGNvbnRlbnQ6IGRhdGEubWVzc2FnZVR5cGUgPT09ICd0ZXh0JyA/IHRoaXMuZGVkdXBsaWNhdGVDb250ZW50KGRhdGEuY29udGVudCkgOiBkYXRhLmNvbnRlbnQsXG4gICAgICAgIG1ldGFkYXRhOiBkYXRhLm1ldGFkYXRhIHx8IHsgdGltZXN0YW1wOiBuZXcgRGF0ZSgpIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHZhcmlvdXMgcG9zc2libGUgbjhuIHJlc3BvbnNlIGZvcm1hdHNcbiAgICBsZXQgY29udGVudCA9IGRhdGEuY29udGVudCB8fCBkYXRhLm1lc3NhZ2UgfHwgZGF0YS5yZXNwb25zZSB8fCBkYXRhLnRleHQgfHwgZGF0YS5vdXRwdXQgfHwgZGF0YTtcbiAgICBsZXQgbWVzc2FnZVR5cGUgPSBkYXRhLm1lc3NhZ2VUeXBlIHx8IGRhdGEuZm9ybWF0IHx8ICd0ZXh0JztcbiAgICBsZXQgdHlwZSA9IGRhdGEudHlwZSB8fCAnZmluYWwnO1xuICAgIFxuICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIG44biBvdXRwdXQgZmllbGQgdGhhdCBjb250YWlucyBKU09OIHN0cmluZ1xuICAgIGlmIChkYXRhLm91dHB1dCAmJiB0eXBlb2YgZGF0YS5vdXRwdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWRPdXRwdXQgPSBKU09OLnBhcnNlKGRhdGEub3V0cHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZE91dHB1dCAmJiB0eXBlb2YgcGFyc2VkT3V0cHV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIC8vIElmIHRoZSBvdXRwdXQgY29udGFpbnMgYSB2YWxpZCBKU09OIG9iamVjdCwgdXNlIGl0IGFzIHRoZSBiYXNlXG4gICAgICAgICAgY29udGVudCA9IHBhcnNlZE91dHB1dC5jb250ZW50IHx8IHBhcnNlZE91dHB1dDtcbiAgICAgICAgICBtZXNzYWdlVHlwZSA9IHBhcnNlZE91dHB1dC5tZXNzYWdlVHlwZSB8fCBtZXNzYWdlVHlwZTtcbiAgICAgICAgICB0eXBlID0gcGFyc2VkT3V0cHV0LnR5cGUgfHwgdHlwZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgcGFyc2luZyBmYWlscywgdHJlYXQgb3V0cHV0IGFzIHJlZ3VsYXIgdGV4dCBjb250ZW50XG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIG44biBvdXRwdXQgYXMgSlNPTjonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIG1peGVkIGNvbnRlbnQgcmVzcG9uc2UgKGFycmF5IHdpdGggdGV4dC9jaGFydCBjb21iaW5hdGlvbnMpXG4gICAgaWYgKHRoaXMuaXNNaXhlZENvbnRlbnQoY29udGVudCkpIHtcbiAgICAgIG1lc3NhZ2VUeXBlID0gJ21peGVkJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudCkpIHtcbiAgICAgIC8vIElmIGl0J3MgYW4gYXJyYXkgYnV0IG5vdCBtaXhlZCBjb250ZW50LCB0cmVhdCBhcyBKU09OXG4gICAgICBtZXNzYWdlVHlwZSA9ICdqc29uJztcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBtZXNzYWdlVHlwZVxuICAgIGlmICghWyd0ZXh0JywgJ2pzb24nLCAnaW1hZ2UnLCAnY2hhcnQnLCAnZXJyb3InLCAnbWl4ZWQnXS5pbmNsdWRlcyhtZXNzYWdlVHlwZSkpIHtcbiAgICAgIG1lc3NhZ2VUeXBlID0gJ3RleHQnO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHR5cGVcbiAgICBpZiAoIVsnaW50ZXJpbScsICdmaW5hbCddLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICB0eXBlID0gJ2ZpbmFsJztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZSxcbiAgICAgIG1lc3NhZ2VUeXBlLFxuICAgICAgY29udGVudDogbWVzc2FnZVR5cGUgPT09ICd0ZXh0JyA/IHRoaXMuZGVkdXBsaWNhdGVDb250ZW50KGNvbnRlbnQpIDogY29udGVudCxcbiAgICAgIG1ldGFkYXRhOiBkYXRhLm1ldGFkYXRhIHx8IHsgXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgc291cmNlOiAnbjhuLXdlYmhvb2snLFxuICAgICAgICBvcmlnaW5hbFJlc3BvbnNlOiBkYXRhXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgb25nb2luZyByZXF1ZXN0XG4gICAqL1xuICBjYW5jZWwoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWFsdGggY2hlY2sgZW5kcG9pbnRcbiAgICovXG4gIGFzeW5jIGhlYWx0aENoZWNrKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuY29uZmlnLndlYmhvb2tVcmx9L2hlYWx0aGAsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KDUwMDApLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiByZXNwb25zZS5vaztcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgY2xpZW50IGluc3RhbmNlc1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU44TkNsaWVudChjb25maWc6IE44TkNsaWVudENvbmZpZyk6IE44TkNsaWVudCB7XG4gIHJldHVybiBuZXcgTjhOQ2xpZW50KGNvbmZpZyk7XG59XG5cbi8vIEV4YW1wbGUgdXNhZ2VcbmV4cG9ydCBjb25zdCBuOG5DbGllbnRFeGFtcGxlID0gKCkgPT4ge1xuICBjb25zdCBjbGllbnQgPSBjcmVhdGVOOE5DbGllbnQoe1xuICAgIHdlYmhvb2tVcmw6IHByb2Nlc3MuZW52Lk44Tl9XRUJIT09LX1VSTCEsXG4gICAgc3RyZWFtaW5nVXJsOiBwcm9jZXNzLmVudi5OOE5fU1RSRUFNSU5HX1VSTCEsXG4gICAgdGltZW91dDogMzAwMDAsXG4gICAgcmV0cnlBdHRlbXB0czogMyxcbiAgICByZXRyeURlbGF5OiAxMDAwXG4gIH0pO1xuXG4gIC8vIEV4YW1wbGU6IFNlbmQgbWVzc2FnZVxuICBjb25zdCBzZW5kTWVzc2FnZSA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVxdWVzdDogTjhOUmVxdWVzdCA9IHtcbiAgICAgICAgdXNlcm5hbWU6ICd1c2VyMTIzJyxcbiAgICAgICAgbWVzc2FnZTogJ0hlbGxvLCBjYW4geW91IGFuYWx5emUgdGhpcyBkYXRhPycsXG4gICAgICAgIHNlc3Npb25JZDogJ3Nlc3Npb24tMTIzJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5zZW5kTWVzc2FnZVdpdGhSZXRyeShyZXF1ZXN0KTtcbiAgICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE44TkVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ044TiBFcnJvcjonLCBlcnJvci5tZXNzYWdlLCBlcnJvci50eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBFeGFtcGxlOiBTdHJlYW0gbWVzc2FnZXNcbiAgY29uc3Qgc3RyZWFtTWVzc2FnZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICdzZXNzaW9uLTEyMyc7XG4gICAgICBcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgcmVzcG9uc2Ugb2YgY2xpZW50LnN0cmVhbU1lc3NhZ2VzKHNlc3Npb25JZCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1N0cmVhbWluZyByZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ2ZpbmFsJykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1N0cmVhbWluZyBlcnJvcjonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7IHNlbmRNZXNzYWdlLCBzdHJlYW1NZXNzYWdlcyB9O1xufTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGNvbW1vbiBvcGVyYXRpb25zXG5leHBvcnQgY29uc3QgbjhuVXRpbHMgPSB7XG4gIC8qKlxuICAgKiBGb3JtYXQgZXJyb3IgZm9yIHVzZXIgZGlzcGxheVxuICAgKi9cbiAgZm9ybWF0RXJyb3IoZXJyb3I6IE44TkVycm9yKTogc3RyaW5nIHtcbiAgICBzd2l0Y2ggKGVycm9yLnR5cGUpIHtcbiAgICAgIGNhc2UgJ25ldHdvcmsnOlxuICAgICAgICByZXR1cm4gJ05ldHdvcmsgY29ubmVjdGlvbiBmYWlsZWQuIFBsZWFzZSBjaGVjayB5b3VyIGludGVybmV0IGNvbm5lY3Rpb24uJztcbiAgICAgIGNhc2UgJ3RpbWVvdXQnOlxuICAgICAgICByZXR1cm4gJ1JlcXVlc3QgdGltZWQgb3V0LiBUaGUgd29ya2Zsb3cgbWF5IGJlIHRha2luZyBsb25nZXIgdGhhbiBleHBlY3RlZC4nO1xuICAgICAgY2FzZSAnc2VydmVyJzpcbiAgICAgICAgcmV0dXJuICdTZXJ2ZXIgZXJyb3Igb2NjdXJyZWQuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJztcbiAgICAgIGNhc2UgJ3ZhbGlkYXRpb24nOlxuICAgICAgICByZXR1cm4gJ0ludmFsaWQgZGF0YSBmb3JtYXQuIFBsZWFzZSBjb250YWN0IHN1cHBvcnQuJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZC4gUGxlYXNlIHRyeSBhZ2Fpbi4nO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgcmVzcG9uc2UgaXMgaW50ZXJpbSBtZXNzYWdlXG4gICAqL1xuICBpc0ludGVyaW1NZXNzYWdlKHJlc3BvbnNlOiBOOE5SZXNwb25zZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiByZXNwb25zZS50eXBlID09PSAnaW50ZXJpbSc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHJlc3BvbnNlIGlzIGZpbmFsIG1lc3NhZ2VcbiAgICovXG4gIGlzRmluYWxNZXNzYWdlKHJlc3BvbnNlOiBOOE5SZXNwb25zZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiByZXNwb25zZS50eXBlID09PSAnZmluYWwnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHByb2Nlc3NpbmcgdGltZSBmcm9tIG1ldGFkYXRhXG4gICAqL1xuICBnZXRQcm9jZXNzaW5nVGltZShyZXNwb25zZTogTjhOUmVzcG9uc2UpOiBudW1iZXIgfCBudWxsIHtcbiAgICByZXR1cm4gcmVzcG9uc2UubWV0YWRhdGE/LnByb2Nlc3NpbmdUaW1lIHx8IG51bGw7XG4gIH1cbn07Il0sIm5hbWVzIjpbIk44TkVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwidHlwZSIsImRldGFpbHMiLCJuYW1lIiwiTjhOQ2xpZW50Iiwic2VuZE1lc3NhZ2UiLCJyZXF1ZXN0Iiwid2ViaG9va1VybCIsInRpbWVvdXQiLCJjb25maWciLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJjb25zb2xlIiwibG9nIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsInNpZ25hbCIsImNsZWFyVGltZW91dCIsInN0YXR1cyIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsIm9rIiwiZXJyb3JUZXh0IiwidGV4dCIsImVycm9yIiwic3RhdHVzVGV4dCIsInJlc3BvbnNlVGV4dCIsImRhdGEiLCJwYXJzZSIsInBhcnNlRXJyb3IiLCJ2YWxpZGF0ZWRSZXNwb25zZSIsInZhbGlkYXRlUmVzcG9uc2UiLCJTdHJpbmciLCJpbmNsdWRlcyIsInN0cmVhbU1lc3NhZ2VzIiwic2Vzc2lvbklkIiwic3RyZWFtaW5nVXJsIiwidXJsIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwic2V0IiwidG9TdHJpbmciLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJidWZmZXIiLCJkb25lIiwidmFsdWUiLCJyZWFkIiwiZGVjb2RlIiwic3RyZWFtIiwibGluZXMiLCJzcGxpdCIsInBvcCIsImxpbmUiLCJ0cmltIiwic3RhcnRzV2l0aCIsInNsaWNlIiwicGFyc2VkIiwid2FybiIsInJlbGVhc2VMb2NrIiwic2VuZE1lc3NhZ2VXaXRoUmV0cnkiLCJyZXRyeUF0dGVtcHRzIiwicmV0cnlEZWxheSIsImF0dGVtcHQiLCJQcm9taXNlIiwicmVzb2x2ZSIsImRlZHVwbGljYXRlQ29udGVudCIsImNvbnRlbnQiLCJzZWVuTGluZXMiLCJTZXQiLCJkZWR1cGxpY2F0ZWRMaW5lcyIsInRyaW1tZWRMaW5lIiwicHVzaCIsImhhcyIsImFkZCIsImpvaW4iLCJpc01peGVkQ29udGVudCIsIkFycmF5IiwiaXNBcnJheSIsInNvbWUiLCJpdGVtIiwia2V5cyIsImhhc1RleHQiLCJrZXkiLCJoYXNDaGFydCIsIm1lc3NhZ2VUeXBlIiwibWV0YWRhdGEiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidW5kZWZpbmVkIiwib3V0cHV0IiwiZm9ybWF0IiwicGFyc2VkT3V0cHV0Iiwic291cmNlIiwib3JpZ2luYWxSZXNwb25zZSIsImNhbmNlbCIsImhlYWx0aENoZWNrIiwiQWJvcnRTaWduYWwiLCJjcmVhdGVOOE5DbGllbnQiLCJuOG5DbGllbnRFeGFtcGxlIiwiY2xpZW50IiwicHJvY2VzcyIsImVudiIsIk44Tl9XRUJIT09LX1VSTCIsIk44Tl9TVFJFQU1JTkdfVVJMIiwidXNlcm5hbWUiLCJuOG5VdGlscyIsImZvcm1hdEVycm9yIiwiaXNJbnRlcmltTWVzc2FnZSIsImlzRmluYWxNZXNzYWdlIiwiZ2V0UHJvY2Vzc2luZ1RpbWUiLCJwcm9jZXNzaW5nVGltZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/n8n-client.ts\n"));

/***/ })

});