"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/n8n-client.ts":
/*!***************************!*\
  !*** ./lib/n8n-client.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   N8NClient: () => (/* binding */ N8NClient),\n/* harmony export */   N8NError: () => (/* binding */ N8NError),\n/* harmony export */   createN8NClient: () => (/* binding */ createN8NClient),\n/* harmony export */   n8nClientExample: () => (/* binding */ n8nClientExample),\n/* harmony export */   n8nUtils: () => (/* binding */ n8nUtils)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * n8n Webhook Client\n * Handles communication with n8n workflows via webhook and streaming endpoints\n */ class N8NError extends Error {\n    constructor(message, type, details){\n        super(message), this.type = type, this.details = details;\n        this.name = 'N8NError';\n    }\n}\nclass N8NClient {\n    /**\n   * Send a message to n8n webhook\n   */ async sendMessage(request) {\n        const { webhookUrl, timeout } = this.config;\n        try {\n            console.log('=== N8N WEBHOOK DEBUG ===');\n            console.log('Webhook URL:', webhookUrl);\n            console.log('Request payload:', JSON.stringify(request, null, 2));\n            const response = await fetch(webhookUrl, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Accept': 'application/json'\n                },\n                body: JSON.stringify(request),\n                signal: AbortSignal.timeout(timeout)\n            });\n            console.log('Response status:', response.status);\n            console.log('Response headers:', Object.fromEntries(response.headers.entries()));\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('Error response body:', errorText);\n                throw new N8NError(\"HTTP \".concat(response.status, \": \").concat(response.statusText), 'server', {\n                    status: response.status,\n                    statusText: response.statusText,\n                    body: errorText\n                });\n            }\n            const responseText = await response.text();\n            console.log('Raw response:', responseText);\n            let data;\n            try {\n                data = JSON.parse(responseText);\n            } catch (parseError) {\n                console.log('Response is not JSON, treating as plain text');\n                data = responseText;\n            }\n            console.log('Parsed response data:', data);\n            const validatedResponse = this.validateResponse(data);\n            console.log('Validated response:', validatedResponse);\n            console.log('=== END N8N WEBHOOK DEBUG ===');\n            return validatedResponse;\n        } catch (error) {\n            clearTimeout(timeoutId);\n            console.error('=== N8N WEBHOOK ERROR ===');\n            console.error('Error details:', error);\n            console.error('Error type:', error instanceof Error ? error.constructor.name : typeof error);\n            console.error('Error message:', error instanceof Error ? error.message : String(error));\n            console.error('=== END N8N WEBHOOK ERROR ===');\n            if (error instanceof Error) {\n                if (error.name === 'AbortError') {\n                    throw new N8NError('Request timeout', 'timeout');\n                }\n                if (error.message.includes('fetch') || error.message.includes('network')) {\n                    throw new N8NError('Network error', 'network', error);\n                }\n            }\n            throw error;\n        }\n    }\n    /**\n   * Set up streaming connection for real-time updates\n   */ async *streamMessages(sessionId) {\n        const { streamingUrl } = this.config;\n        const url = new URL(streamingUrl);\n        url.searchParams.set('sessionId', sessionId);\n        try {\n            var _response_body;\n            const response = await fetch(url.toString(), {\n                headers: {\n                    'Accept': 'text/event-stream',\n                    'Cache-Control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                throw new N8NError(\"Streaming failed: \".concat(response.status), 'server', {\n                    status: response.status\n                });\n            }\n            const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n            if (!reader) {\n                throw new N8NError('No response body', 'server');\n            }\n            const decoder = new TextDecoder();\n            let buffer = '';\n            try {\n                while(true){\n                    const { done, value } = await reader.read();\n                    if (done) break;\n                    buffer += decoder.decode(value, {\n                        stream: true\n                    });\n                    const lines = buffer.split('\\n');\n                    // Keep the last incomplete line in buffer\n                    buffer = lines.pop() || '';\n                    for (const line of lines){\n                        if (line.trim() === '') continue;\n                        if (line.startsWith('data: ')) {\n                            const data = line.slice(6);\n                            if (data === '[DONE]') {\n                                return;\n                            }\n                            try {\n                                const parsed = JSON.parse(data);\n                                const response = this.validateResponse(parsed);\n                                yield response;\n                            } catch (error) {\n                                console.warn('Failed to parse streaming data:', error);\n                            }\n                        }\n                    }\n                }\n            } finally{\n                reader.releaseLock();\n            }\n        } catch (error) {\n            if (error instanceof N8NError) {\n                throw error;\n            }\n            throw new N8NError('Streaming connection failed', 'network', error);\n        }\n    }\n    /**\n   * Send message with retry logic\n   */ async sendMessageWithRetry(request) {\n        const { retryAttempts, retryDelay } = this.config;\n        for(let attempt = 1; attempt <= retryAttempts; attempt++){\n            try {\n                return await this.sendMessage(request);\n            } catch (error) {\n                if (error instanceof N8NError) {\n                    // Don't retry validation errors\n                    if (error.type === 'validation') {\n                        throw error;\n                    }\n                    // Don't retry on final attempt\n                    if (attempt === retryAttempts) {\n                        throw error;\n                    }\n                    // Wait before retry\n                    await new Promise((resolve)=>setTimeout(resolve, retryDelay * attempt));\n                } else {\n                    throw error;\n                }\n            }\n        }\n        throw new N8NError('Max retry attempts reached', 'network');\n    }\n    /**\n   * Remove duplicate content from response\n   */ deduplicateContent(content) {\n        if (typeof content !== 'string') {\n            return content;\n        }\n        // Split content into lines\n        const lines = content.split('\\n');\n        const seenLines = new Set();\n        const deduplicatedLines = [];\n        for (const line of lines){\n            const trimmedLine = line.trim();\n            // Skip empty lines for deduplication check\n            if (trimmedLine === '') {\n                deduplicatedLines.push(line);\n                continue;\n            }\n            // If we haven't seen this line before, add it\n            if (!seenLines.has(trimmedLine)) {\n                seenLines.add(trimmedLine);\n                deduplicatedLines.push(line);\n            }\n        }\n        return deduplicatedLines.join('\\n');\n    }\n    /**\n   * Detect if content is mixed format (contains text and chart keys)\n   */ isMixedContent(content) {\n        if (!Array.isArray(content)) return false;\n        return content.some((item)=>{\n            if (!item || typeof item !== 'object') return false;\n            const keys = Object.keys(item);\n            const hasText = keys.some((key)=>key.startsWith('text'));\n            const hasChart = keys.some((key)=>key.startsWith('chart'));\n            return hasText || hasChart;\n        });\n    }\n    /**\n   * Validate n8n response format\n   */ validateResponse(data) {\n        if (!data || typeof data !== 'object') {\n            // If we get a simple response, wrap it in our expected format\n            return {\n                type: 'final',\n                messageType: 'text',\n                content: String(data),\n                metadata: {\n                    timestamp: new Date()\n                }\n            };\n        }\n        // Check if response already has our expected format\n        if (data.type && data.messageType && data.content !== undefined) {\n            return {\n                type: data.type,\n                messageType: data.messageType,\n                content: data.messageType === 'text' ? this.deduplicateContent(data.content) : data.content,\n                metadata: data.metadata || {\n                    timestamp: new Date()\n                }\n            };\n        }\n        // Handle various possible n8n response formats\n        let content = data.content || data.message || data.response || data.text || data.output || data;\n        let messageType = data.messageType || data.format || 'text';\n        let type = data.type || 'final';\n        // Special handling for n8n output field that contains JSON string\n        if (data.output && typeof data.output === 'string') {\n            try {\n                const parsedOutput = JSON.parse(data.output);\n                if (parsedOutput && typeof parsedOutput === 'object') {\n                    // If the output contains a valid JSON object, use it as the base\n                    content = parsedOutput.content || parsedOutput;\n                    messageType = parsedOutput.messageType || messageType;\n                    type = parsedOutput.type || type;\n                }\n            } catch (error) {\n                // If parsing fails, treat output as regular text content\n                console.warn('Failed to parse n8n output as JSON:', error);\n            }\n        }\n        // Check if this is a mixed content response (array with text/chart combinations)\n        if (this.isMixedContent(content)) {\n            messageType = 'mixed';\n        } else if (Array.isArray(content)) {\n            // If it's an array but not mixed content, treat as JSON\n            messageType = 'json';\n        }\n        // Validate messageType\n        if (![\n            'text',\n            'json',\n            'image',\n            'chart',\n            'error',\n            'mixed'\n        ].includes(messageType)) {\n            messageType = 'text';\n        }\n        // Validate type\n        if (![\n            'interim',\n            'final'\n        ].includes(type)) {\n            type = 'final';\n        }\n        return {\n            type,\n            messageType,\n            content: messageType === 'text' ? this.deduplicateContent(content) : content,\n            metadata: data.metadata || {\n                timestamp: new Date(),\n                source: 'n8n-webhook',\n                originalResponse: data\n            }\n        };\n    }\n    /**\n   * Cancel ongoing request\n   */ cancel() {\n        if (this.abortController) {\n            this.abortController.abort();\n            this.abortController = null;\n        }\n    }\n    /**\n   * Health check endpoint\n   */ async healthCheck() {\n        try {\n            const response = await fetch(\"\".concat(this.config.webhookUrl, \"/health\"), {\n                method: 'GET',\n                signal: AbortSignal.timeout(5000)\n            });\n            return response.ok;\n        } catch (e) {\n            return false;\n        }\n    }\n    constructor(config){\n        this.abortController = null;\n        this.config = {\n            timeout: 120000,\n            retryAttempts: 3,\n            retryDelay: 1000,\n            ...config\n        };\n    }\n}\n// Factory function for creating client instances\nfunction createN8NClient(config) {\n    return new N8NClient(config);\n}\n// Example usage\nconst n8nClientExample = ()=>{\n    const client = createN8NClient({\n        webhookUrl: process.env.N8N_WEBHOOK_URL,\n        streamingUrl: process.env.N8N_STREAMING_URL,\n        timeout: 30000,\n        retryAttempts: 3,\n        retryDelay: 1000\n    });\n    // Example: Send message\n    const sendMessage = async ()=>{\n        try {\n            const request = {\n                username: 'user123',\n                message: 'Hello, can you analyze this data?',\n                sessionId: 'session-123',\n                timestamp: new Date()\n            };\n            const response = await client.sendMessageWithRetry(request);\n            console.log('Response:', response);\n        } catch (error) {\n            if (error instanceof N8NError) {\n                console.error('N8N Error:', error.message, error.type);\n            } else {\n                console.error('Unexpected error:', error);\n            }\n        }\n    };\n    // Example: Stream messages\n    const streamMessages = async ()=>{\n        try {\n            const sessionId = 'session-123';\n            for await (const response of client.streamMessages(sessionId)){\n                console.log('Streaming response:', response);\n                if (response.type === 'final') {\n                    break;\n                }\n            }\n        } catch (error) {\n            console.error('Streaming error:', error);\n        }\n    };\n    return {\n        sendMessage,\n        streamMessages\n    };\n};\n// Utility functions for common operations\nconst n8nUtils = {\n    /**\n   * Format error for user display\n   */ formatError (error) {\n        switch(error.type){\n            case 'network':\n                return 'Network connection failed. Please check your internet connection.';\n            case 'timeout':\n                return 'Request timed out. The workflow may be taking longer than expected.';\n            case 'server':\n                return 'Server error occurred. Please try again later.';\n            case 'validation':\n                return 'Invalid data format. Please contact support.';\n            default:\n                return 'An unexpected error occurred. Please try again.';\n        }\n    },\n    /**\n   * Check if response is interim message\n   */ isInterimMessage (response) {\n        return response.type === 'interim';\n    },\n    /**\n   * Check if response is final message\n   */ isFinalMessage (response) {\n        return response.type === 'final';\n    },\n    /**\n   * Extract processing time from metadata\n   */ getProcessingTime (response) {\n        var _response_metadata;\n        return ((_response_metadata = response.metadata) === null || _response_metadata === void 0 ? void 0 : _response_metadata.processingTime) || null;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTJCO0lBQzNCLE1BQU1ZLGlCQUFpQjtRQUNyQixJQUFJO1lBQ0YsTUFBTUMsWUFBWTtZQUVsQixXQUFXLE1BQU0zQixZQUFZZ0csT0FBT3RFLGNBQWMsQ0FBQ0MsV0FBWTtnQkFDN0QvQixRQUFRQyxHQUFHLENBQUMsdUJBQXVCRztnQkFFbkMsSUFBSUEsU0FBU2IsSUFBSSxLQUFLLFNBQVM7b0JBQzdCO2dCQUNGO1lBQ0Y7UUFDRixFQUFFLE9BQU8yQixPQUFPO1lBQ2RsQixRQUFRa0IsS0FBSyxDQUFDLG9CQUFvQkE7UUFDcEM7SUFDRjtJQUVBLE9BQU87UUFBRXZCO1FBQWFtQztJQUFlO0FBQ3ZDLEVBQUU7QUFFRiwwQ0FBMEM7QUFDbkMsTUFBTTRFLFdBQVc7SUFDdEI7O0dBRUMsR0FDREMsYUFBWXpGLEtBQWU7UUFDekIsT0FBUUEsTUFBTTNCLElBQUk7WUFDaEIsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1lBQ1QsS0FBSztnQkFDSCxPQUFPO1lBQ1Q7Z0JBQ0UsT0FBTztRQUNYO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEcUgsa0JBQWlCeEcsUUFBcUI7UUFDcEMsT0FBT0EsU0FBU2IsSUFBSSxLQUFLO0lBQzNCO0lBRUE7O0dBRUMsR0FDRHNILGdCQUFlekcsUUFBcUI7UUFDbEMsT0FBT0EsU0FBU2IsSUFBSSxLQUFLO0lBQzNCO0lBRUE7O0dBRUMsR0FDRHVILG1CQUFrQjFHLFFBQXFCO1lBQzlCQTtRQUFQLE9BQU9BLEVBQUFBLHFCQUFBQSxTQUFTaUYsUUFBUSxjQUFqQmpGLHlDQUFBQSxtQkFBbUIyRyxjQUFjLEtBQUk7SUFDOUM7QUFDRixFQUFFIiwic291cmNlcyI6WyJDOlxcRWJ0dGlrYXIgSW50ZWxsaWdlbmNlIFByb2plY3RzXFxUZXN0LUNoYXQtQXBwXFxsaWJcXG44bi1jbGllbnQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBuOG4gV2ViaG9vayBDbGllbnRcbiAqIEhhbmRsZXMgY29tbXVuaWNhdGlvbiB3aXRoIG44biB3b3JrZmxvd3MgdmlhIHdlYmhvb2sgYW5kIHN0cmVhbWluZyBlbmRwb2ludHNcbiAqL1xuXG5pbXBvcnQgeyBOOE5SZXF1ZXN0LCBOOE5SZXNwb25zZSwgQ2hhdEVycm9yIH0gZnJvbSAnQC90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBOOE5FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIHB1YmxpYyB0eXBlOiAnbmV0d29yaycgfCAndGltZW91dCcgfCAnc2VydmVyJyB8ICd2YWxpZGF0aW9uJyxcbiAgICBwdWJsaWMgZGV0YWlscz86IGFueVxuICApIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnTjhORXJyb3InO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTjhOQ2xpZW50Q29uZmlnIHtcbiAgd2ViaG9va1VybDogc3RyaW5nO1xuICBzdHJlYW1pbmdVcmw6IHN0cmluZztcbiAgdGltZW91dD86IG51bWJlcjtcbiAgcmV0cnlBdHRlbXB0cz86IG51bWJlcjtcbiAgcmV0cnlEZWxheT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIE44TkNsaWVudCB7XG4gIHByaXZhdGUgY29uZmlnOiBSZXF1aXJlZDxOOE5DbGllbnRDb25maWc+O1xuICBwcml2YXRlIGFib3J0Q29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBOOE5DbGllbnRDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIHRpbWVvdXQ6IDEyMDAwMCwgLy8gSW5jcmVhc2VkIHRvIDIgbWludXRlcyBmb3IgQUkgcHJvY2Vzc2luZ1xuICAgICAgcmV0cnlBdHRlbXB0czogMyxcbiAgICAgIHJldHJ5RGVsYXk6IDEwMDAsXG4gICAgICAuLi5jb25maWdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBtZXNzYWdlIHRvIG44biB3ZWJob29rXG4gICAqL1xuICBhc3luYyBzZW5kTWVzc2FnZShyZXF1ZXN0OiBOOE5SZXF1ZXN0KTogUHJvbWlzZTxOOE5SZXNwb25zZT4ge1xuICAgIGNvbnN0IHsgd2ViaG9va1VybCwgdGltZW91dCB9ID0gdGhpcy5jb25maWc7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCc9PT0gTjhOIFdFQkhPT0sgREVCVUcgPT09Jyk7XG4gICAgICBjb25zb2xlLmxvZygnV2ViaG9vayBVUkw6Jywgd2ViaG9va1VybCk7XG4gICAgICBjb25zb2xlLmxvZygnUmVxdWVzdCBwYXlsb2FkOicsIEpTT04uc3RyaW5naWZ5KHJlcXVlc3QsIG51bGwsIDIpKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh3ZWJob29rVXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSxcbiAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRpbWVvdXQpLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZSBoZWFkZXJzOicsIE9iamVjdC5mcm9tRW50cmllcyhyZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKSkpO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVzcG9uc2UgYm9keTonLCBlcnJvclRleHQpO1xuICAgICAgICB0aHJvdyBuZXcgTjhORXJyb3IoXG4gICAgICAgICAgYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCxcbiAgICAgICAgICAnc2VydmVyJyxcbiAgICAgICAgICB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLCBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LCBib2R5OiBlcnJvclRleHQgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZVRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBjb25zb2xlLmxvZygnUmF3IHJlc3BvbnNlOicsIHJlc3BvbnNlVGV4dCk7XG4gICAgICBcbiAgICAgIGxldCBkYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KTtcbiAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1Jlc3BvbnNlIGlzIG5vdCBKU09OLCB0cmVhdGluZyBhcyBwbGFpbiB0ZXh0Jyk7XG4gICAgICAgIGRhdGEgPSByZXNwb25zZVRleHQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdQYXJzZWQgcmVzcG9uc2UgZGF0YTonLCBkYXRhKTtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFJlc3BvbnNlID0gdGhpcy52YWxpZGF0ZVJlc3BvbnNlKGRhdGEpO1xuICAgICAgY29uc29sZS5sb2coJ1ZhbGlkYXRlZCByZXNwb25zZTonLCB2YWxpZGF0ZWRSZXNwb25zZSk7XG4gICAgICBjb25zb2xlLmxvZygnPT09IEVORCBOOE4gV0VCSE9PSyBERUJVRyA9PT0nKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHZhbGlkYXRlZFJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJz09PSBOOE4gV0VCSE9PSyBFUlJPUiA9PT0nKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6JywgZXJyb3IpO1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdHlwZTonLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IuY29uc3RydWN0b3IubmFtZSA6IHR5cGVvZiBlcnJvcik7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBtZXNzYWdlOicsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSk7XG4gICAgICBjb25zb2xlLmVycm9yKCc9PT0gRU5EIE44TiBXRUJIT09LIEVSUk9SID09PScpO1xuICAgICAgXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE44TkVycm9yKCdSZXF1ZXN0IHRpbWVvdXQnLCAndGltZW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZmV0Y2gnKSB8fCBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCduZXR3b3JrJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTjhORXJyb3IoJ05ldHdvcmsgZXJyb3InLCAnbmV0d29yaycsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIHN0cmVhbWluZyBjb25uZWN0aW9uIGZvciByZWFsLXRpbWUgdXBkYXRlc1xuICAgKi9cbiAgYXN5bmMgKnN0cmVhbU1lc3NhZ2VzKHNlc3Npb25JZDogc3RyaW5nKTogQXN5bmNHZW5lcmF0b3I8TjhOUmVzcG9uc2UsIHZvaWQsIHVua25vd24+IHtcbiAgICBjb25zdCB7IHN0cmVhbWluZ1VybCB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChzdHJlYW1pbmdVcmwpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdzZXNzaW9uSWQnLCBzZXNzaW9uSWQpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBY2NlcHQnOiAndGV4dC9ldmVudC1zdHJlYW0nLFxuICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBOOE5FcnJvcihcbiAgICAgICAgICBgU3RyZWFtaW5nIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9YCxcbiAgICAgICAgICAnc2VydmVyJyxcbiAgICAgICAgICB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzIH1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keT8uZ2V0UmVhZGVyKCk7XG4gICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgTjhORXJyb3IoJ05vIHJlc3BvbnNlIGJvZHknLCAnc2VydmVyJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgIGxldCBidWZmZXIgPSAnJztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgICAgICBcbiAgICAgICAgICBidWZmZXIgKz0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgIGNvbnN0IGxpbmVzID0gYnVmZmVyLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBLZWVwIHRoZSBsYXN0IGluY29tcGxldGUgbGluZSBpbiBidWZmZXJcbiAgICAgICAgICBidWZmZXIgPSBsaW5lcy5wb3AoKSB8fCAnJztcbiAgICAgICAgICBcbiAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICAgIGlmIChsaW5lLnRyaW0oKSA9PT0gJycpIGNvbnRpbnVlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKCdkYXRhOiAnKSkge1xuICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbGluZS5zbGljZSg2KTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChkYXRhID09PSAnW0RPTkVdJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy52YWxpZGF0ZVJlc3BvbnNlKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgeWllbGQgcmVzcG9uc2U7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtaW5nIGRhdGE6JywgZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgTjhORXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IG5ldyBOOE5FcnJvcihcbiAgICAgICAgJ1N0cmVhbWluZyBjb25uZWN0aW9uIGZhaWxlZCcsXG4gICAgICAgICduZXR3b3JrJyxcbiAgICAgICAgZXJyb3JcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgbWVzc2FnZSB3aXRoIHJldHJ5IGxvZ2ljXG4gICAqL1xuICBhc3luYyBzZW5kTWVzc2FnZVdpdGhSZXRyeShyZXF1ZXN0OiBOOE5SZXF1ZXN0KTogUHJvbWlzZTxOOE5SZXNwb25zZT4ge1xuICAgIGNvbnN0IHsgcmV0cnlBdHRlbXB0cywgcmV0cnlEZWxheSB9ID0gdGhpcy5jb25maWc7XG4gICAgXG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gcmV0cnlBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZShyZXF1ZXN0KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE44TkVycm9yKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgcmV0cnkgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICAgICAgICBpZiAoZXJyb3IudHlwZSA9PT0gJ3ZhbGlkYXRpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRG9uJ3QgcmV0cnkgb24gZmluYWwgYXR0ZW1wdFxuICAgICAgICAgIGlmIChhdHRlbXB0ID09PSByZXRyeUF0dGVtcHRzKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gV2FpdCBiZWZvcmUgcmV0cnlcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheSAqIGF0dGVtcHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aHJvdyBuZXcgTjhORXJyb3IoJ01heCByZXRyeSBhdHRlbXB0cyByZWFjaGVkJywgJ25ldHdvcmsnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgZHVwbGljYXRlIGNvbnRlbnQgZnJvbSByZXNwb25zZVxuICAgKi9cbiAgcHJpdmF0ZSBkZWR1cGxpY2F0ZUNvbnRlbnQoY29udGVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG5cbiAgICAvLyBTcGxpdCBjb250ZW50IGludG8gbGluZXNcbiAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IHNlZW5MaW5lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IGRlZHVwbGljYXRlZExpbmVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgY29uc3QgdHJpbW1lZExpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgIFxuICAgICAgLy8gU2tpcCBlbXB0eSBsaW5lcyBmb3IgZGVkdXBsaWNhdGlvbiBjaGVja1xuICAgICAgaWYgKHRyaW1tZWRMaW5lID09PSAnJykge1xuICAgICAgICBkZWR1cGxpY2F0ZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBzZWVuIHRoaXMgbGluZSBiZWZvcmUsIGFkZCBpdFxuICAgICAgaWYgKCFzZWVuTGluZXMuaGFzKHRyaW1tZWRMaW5lKSkge1xuICAgICAgICBzZWVuTGluZXMuYWRkKHRyaW1tZWRMaW5lKTtcbiAgICAgICAgZGVkdXBsaWNhdGVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGRlZHVwbGljYXRlZExpbmVzLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBjb250ZW50IGlzIG1peGVkIGZvcm1hdCAoY29udGFpbnMgdGV4dCBhbmQgY2hhcnQga2V5cylcbiAgICovXG4gIHByaXZhdGUgaXNNaXhlZENvbnRlbnQoY29udGVudDogYW55KTogYm9vbGVhbiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbnRlbnQpKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgcmV0dXJuIGNvbnRlbnQuc29tZShpdGVtID0+IHtcbiAgICAgIGlmICghaXRlbSB8fCB0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICAgIFxuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGl0ZW0pO1xuICAgICAgY29uc3QgaGFzVGV4dCA9IGtleXMuc29tZShrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ3RleHQnKSk7XG4gICAgICBjb25zdCBoYXNDaGFydCA9IGtleXMuc29tZShrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ2NoYXJ0JykpO1xuICAgICAgXG4gICAgICByZXR1cm4gaGFzVGV4dCB8fCBoYXNDaGFydDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBuOG4gcmVzcG9uc2UgZm9ybWF0XG4gICAqL1xuICBwcml2YXRlIHZhbGlkYXRlUmVzcG9uc2UoZGF0YTogYW55KTogTjhOUmVzcG9uc2Uge1xuICAgIGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIElmIHdlIGdldCBhIHNpbXBsZSByZXNwb25zZSwgd3JhcCBpdCBpbiBvdXIgZXhwZWN0ZWQgZm9ybWF0XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZmluYWwnLFxuICAgICAgICBtZXNzYWdlVHlwZTogJ3RleHQnLFxuICAgICAgICBjb250ZW50OiBTdHJpbmcoZGF0YSksXG4gICAgICAgIG1ldGFkYXRhOiB7IHRpbWVzdGFtcDogbmV3IERhdGUoKSB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHJlc3BvbnNlIGFscmVhZHkgaGFzIG91ciBleHBlY3RlZCBmb3JtYXRcbiAgICBpZiAoZGF0YS50eXBlICYmIGRhdGEubWVzc2FnZVR5cGUgJiYgZGF0YS5jb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGRhdGEudHlwZSxcbiAgICAgICAgbWVzc2FnZVR5cGU6IGRhdGEubWVzc2FnZVR5cGUsXG4gICAgICAgIGNvbnRlbnQ6IGRhdGEubWVzc2FnZVR5cGUgPT09ICd0ZXh0JyA/IHRoaXMuZGVkdXBsaWNhdGVDb250ZW50KGRhdGEuY29udGVudCkgOiBkYXRhLmNvbnRlbnQsXG4gICAgICAgIG1ldGFkYXRhOiBkYXRhLm1ldGFkYXRhIHx8IHsgdGltZXN0YW1wOiBuZXcgRGF0ZSgpIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHZhcmlvdXMgcG9zc2libGUgbjhuIHJlc3BvbnNlIGZvcm1hdHNcbiAgICBsZXQgY29udGVudCA9IGRhdGEuY29udGVudCB8fCBkYXRhLm1lc3NhZ2UgfHwgZGF0YS5yZXNwb25zZSB8fCBkYXRhLnRleHQgfHwgZGF0YS5vdXRwdXQgfHwgZGF0YTtcbiAgICBsZXQgbWVzc2FnZVR5cGUgPSBkYXRhLm1lc3NhZ2VUeXBlIHx8IGRhdGEuZm9ybWF0IHx8ICd0ZXh0JztcbiAgICBsZXQgdHlwZSA9IGRhdGEudHlwZSB8fCAnZmluYWwnO1xuICAgIFxuICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIG44biBvdXRwdXQgZmllbGQgdGhhdCBjb250YWlucyBKU09OIHN0cmluZ1xuICAgIGlmIChkYXRhLm91dHB1dCAmJiB0eXBlb2YgZGF0YS5vdXRwdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWRPdXRwdXQgPSBKU09OLnBhcnNlKGRhdGEub3V0cHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZE91dHB1dCAmJiB0eXBlb2YgcGFyc2VkT3V0cHV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIC8vIElmIHRoZSBvdXRwdXQgY29udGFpbnMgYSB2YWxpZCBKU09OIG9iamVjdCwgdXNlIGl0IGFzIHRoZSBiYXNlXG4gICAgICAgICAgY29udGVudCA9IHBhcnNlZE91dHB1dC5jb250ZW50IHx8IHBhcnNlZE91dHB1dDtcbiAgICAgICAgICBtZXNzYWdlVHlwZSA9IHBhcnNlZE91dHB1dC5tZXNzYWdlVHlwZSB8fCBtZXNzYWdlVHlwZTtcbiAgICAgICAgICB0eXBlID0gcGFyc2VkT3V0cHV0LnR5cGUgfHwgdHlwZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgcGFyc2luZyBmYWlscywgdHJlYXQgb3V0cHV0IGFzIHJlZ3VsYXIgdGV4dCBjb250ZW50XG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIG44biBvdXRwdXQgYXMgSlNPTjonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIG1peGVkIGNvbnRlbnQgcmVzcG9uc2UgKGFycmF5IHdpdGggdGV4dC9jaGFydCBjb21iaW5hdGlvbnMpXG4gICAgaWYgKHRoaXMuaXNNaXhlZENvbnRlbnQoY29udGVudCkpIHtcbiAgICAgIG1lc3NhZ2VUeXBlID0gJ21peGVkJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudCkpIHtcbiAgICAgIC8vIElmIGl0J3MgYW4gYXJyYXkgYnV0IG5vdCBtaXhlZCBjb250ZW50LCB0cmVhdCBhcyBKU09OXG4gICAgICBtZXNzYWdlVHlwZSA9ICdqc29uJztcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBtZXNzYWdlVHlwZVxuICAgIGlmICghWyd0ZXh0JywgJ2pzb24nLCAnaW1hZ2UnLCAnY2hhcnQnLCAnZXJyb3InLCAnbWl4ZWQnXS5pbmNsdWRlcyhtZXNzYWdlVHlwZSkpIHtcbiAgICAgIG1lc3NhZ2VUeXBlID0gJ3RleHQnO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHR5cGVcbiAgICBpZiAoIVsnaW50ZXJpbScsICdmaW5hbCddLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICB0eXBlID0gJ2ZpbmFsJztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZSxcbiAgICAgIG1lc3NhZ2VUeXBlLFxuICAgICAgY29udGVudDogbWVzc2FnZVR5cGUgPT09ICd0ZXh0JyA/IHRoaXMuZGVkdXBsaWNhdGVDb250ZW50KGNvbnRlbnQpIDogY29udGVudCxcbiAgICAgIG1ldGFkYXRhOiBkYXRhLm1ldGFkYXRhIHx8IHsgXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgc291cmNlOiAnbjhuLXdlYmhvb2snLFxuICAgICAgICBvcmlnaW5hbFJlc3BvbnNlOiBkYXRhXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgb25nb2luZyByZXF1ZXN0XG4gICAqL1xuICBjYW5jZWwoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWFsdGggY2hlY2sgZW5kcG9pbnRcbiAgICovXG4gIGFzeW5jIGhlYWx0aENoZWNrKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuY29uZmlnLndlYmhvb2tVcmx9L2hlYWx0aGAsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KDUwMDApLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiByZXNwb25zZS5vaztcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgY2xpZW50IGluc3RhbmNlc1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU44TkNsaWVudChjb25maWc6IE44TkNsaWVudENvbmZpZyk6IE44TkNsaWVudCB7XG4gIHJldHVybiBuZXcgTjhOQ2xpZW50KGNvbmZpZyk7XG59XG5cbi8vIEV4YW1wbGUgdXNhZ2VcbmV4cG9ydCBjb25zdCBuOG5DbGllbnRFeGFtcGxlID0gKCkgPT4ge1xuICBjb25zdCBjbGllbnQgPSBjcmVhdGVOOE5DbGllbnQoe1xuICAgIHdlYmhvb2tVcmw6IHByb2Nlc3MuZW52Lk44Tl9XRUJIT09LX1VSTCEsXG4gICAgc3RyZWFtaW5nVXJsOiBwcm9jZXNzLmVudi5OOE5fU1RSRUFNSU5HX1VSTCEsXG4gICAgdGltZW91dDogMzAwMDAsXG4gICAgcmV0cnlBdHRlbXB0czogMyxcbiAgICByZXRyeURlbGF5OiAxMDAwXG4gIH0pO1xuXG4gIC8vIEV4YW1wbGU6IFNlbmQgbWVzc2FnZVxuICBjb25zdCBzZW5kTWVzc2FnZSA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVxdWVzdDogTjhOUmVxdWVzdCA9IHtcbiAgICAgICAgdXNlcm5hbWU6ICd1c2VyMTIzJyxcbiAgICAgICAgbWVzc2FnZTogJ0hlbGxvLCBjYW4geW91IGFuYWx5emUgdGhpcyBkYXRhPycsXG4gICAgICAgIHNlc3Npb25JZDogJ3Nlc3Npb24tMTIzJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5zZW5kTWVzc2FnZVdpdGhSZXRyeShyZXF1ZXN0KTtcbiAgICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE44TkVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ044TiBFcnJvcjonLCBlcnJvci5tZXNzYWdlLCBlcnJvci50eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBFeGFtcGxlOiBTdHJlYW0gbWVzc2FnZXNcbiAgY29uc3Qgc3RyZWFtTWVzc2FnZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICdzZXNzaW9uLTEyMyc7XG4gICAgICBcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgcmVzcG9uc2Ugb2YgY2xpZW50LnN0cmVhbU1lc3NhZ2VzKHNlc3Npb25JZCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1N0cmVhbWluZyByZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ2ZpbmFsJykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1N0cmVhbWluZyBlcnJvcjonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7IHNlbmRNZXNzYWdlLCBzdHJlYW1NZXNzYWdlcyB9O1xufTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGNvbW1vbiBvcGVyYXRpb25zXG5leHBvcnQgY29uc3QgbjhuVXRpbHMgPSB7XG4gIC8qKlxuICAgKiBGb3JtYXQgZXJyb3IgZm9yIHVzZXIgZGlzcGxheVxuICAgKi9cbiAgZm9ybWF0RXJyb3IoZXJyb3I6IE44TkVycm9yKTogc3RyaW5nIHtcbiAgICBzd2l0Y2ggKGVycm9yLnR5cGUpIHtcbiAgICAgIGNhc2UgJ25ldHdvcmsnOlxuICAgICAgICByZXR1cm4gJ05ldHdvcmsgY29ubmVjdGlvbiBmYWlsZWQuIFBsZWFzZSBjaGVjayB5b3VyIGludGVybmV0IGNvbm5lY3Rpb24uJztcbiAgICAgIGNhc2UgJ3RpbWVvdXQnOlxuICAgICAgICByZXR1cm4gJ1JlcXVlc3QgdGltZWQgb3V0LiBUaGUgd29ya2Zsb3cgbWF5IGJlIHRha2luZyBsb25nZXIgdGhhbiBleHBlY3RlZC4nO1xuICAgICAgY2FzZSAnc2VydmVyJzpcbiAgICAgICAgcmV0dXJuICdTZXJ2ZXIgZXJyb3Igb2NjdXJyZWQuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJztcbiAgICAgIGNhc2UgJ3ZhbGlkYXRpb24nOlxuICAgICAgICByZXR1cm4gJ0ludmFsaWQgZGF0YSBmb3JtYXQuIFBsZWFzZSBjb250YWN0IHN1cHBvcnQuJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZC4gUGxlYXNlIHRyeSBhZ2Fpbi4nO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgcmVzcG9uc2UgaXMgaW50ZXJpbSBtZXNzYWdlXG4gICAqL1xuICBpc0ludGVyaW1NZXNzYWdlKHJlc3BvbnNlOiBOOE5SZXNwb25zZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiByZXNwb25zZS50eXBlID09PSAnaW50ZXJpbSc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHJlc3BvbnNlIGlzIGZpbmFsIG1lc3NhZ2VcbiAgICovXG4gIGlzRmluYWxNZXNzYWdlKHJlc3BvbnNlOiBOOE5SZXNwb25zZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiByZXNwb25zZS50eXBlID09PSAnZmluYWwnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHByb2Nlc3NpbmcgdGltZSBmcm9tIG1ldGFkYXRhXG4gICAqL1xuICBnZXRQcm9jZXNzaW5nVGltZShyZXNwb25zZTogTjhOUmVzcG9uc2UpOiBudW1iZXIgfCBudWxsIHtcbiAgICByZXR1cm4gcmVzcG9uc2UubWV0YWRhdGE/LnByb2Nlc3NpbmdUaW1lIHx8IG51bGw7XG4gIH1cbn07Il0sIm5hbWVzIjpbIk44TkVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwidHlwZSIsImRldGFpbHMiLCJuYW1lIiwiTjhOQ2xpZW50Iiwic2VuZE1lc3NhZ2UiLCJyZXF1ZXN0Iiwid2ViaG9va1VybCIsInRpbWVvdXQiLCJjb25maWciLCJjb25zb2xlIiwibG9nIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsInNpZ25hbCIsIkFib3J0U2lnbmFsIiwic3RhdHVzIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwib2siLCJlcnJvclRleHQiLCJ0ZXh0IiwiZXJyb3IiLCJzdGF0dXNUZXh0IiwicmVzcG9uc2VUZXh0IiwiZGF0YSIsInBhcnNlIiwicGFyc2VFcnJvciIsInZhbGlkYXRlZFJlc3BvbnNlIiwidmFsaWRhdGVSZXNwb25zZSIsImNsZWFyVGltZW91dCIsInRpbWVvdXRJZCIsIlN0cmluZyIsImluY2x1ZGVzIiwic3RyZWFtTWVzc2FnZXMiLCJzZXNzaW9uSWQiLCJzdHJlYW1pbmdVcmwiLCJ1cmwiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJzZXQiLCJ0b1N0cmluZyIsInJlYWRlciIsImdldFJlYWRlciIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImJ1ZmZlciIsImRvbmUiLCJ2YWx1ZSIsInJlYWQiLCJkZWNvZGUiLCJzdHJlYW0iLCJsaW5lcyIsInNwbGl0IiwicG9wIiwibGluZSIsInRyaW0iLCJzdGFydHNXaXRoIiwic2xpY2UiLCJwYXJzZWQiLCJ3YXJuIiwicmVsZWFzZUxvY2siLCJzZW5kTWVzc2FnZVdpdGhSZXRyeSIsInJldHJ5QXR0ZW1wdHMiLCJyZXRyeURlbGF5IiwiYXR0ZW1wdCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImRlZHVwbGljYXRlQ29udGVudCIsImNvbnRlbnQiLCJzZWVuTGluZXMiLCJTZXQiLCJkZWR1cGxpY2F0ZWRMaW5lcyIsInRyaW1tZWRMaW5lIiwicHVzaCIsImhhcyIsImFkZCIsImpvaW4iLCJpc01peGVkQ29udGVudCIsIkFycmF5IiwiaXNBcnJheSIsInNvbWUiLCJpdGVtIiwia2V5cyIsImhhc1RleHQiLCJrZXkiLCJoYXNDaGFydCIsIm1lc3NhZ2VUeXBlIiwibWV0YWRhdGEiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidW5kZWZpbmVkIiwib3V0cHV0IiwiZm9ybWF0IiwicGFyc2VkT3V0cHV0Iiwic291cmNlIiwib3JpZ2luYWxSZXNwb25zZSIsImNhbmNlbCIsImFib3J0Q29udHJvbGxlciIsImFib3J0IiwiaGVhbHRoQ2hlY2siLCJjcmVhdGVOOE5DbGllbnQiLCJuOG5DbGllbnRFeGFtcGxlIiwiY2xpZW50IiwicHJvY2VzcyIsImVudiIsIk44Tl9XRUJIT09LX1VSTCIsIk44Tl9TVFJFQU1JTkdfVVJMIiwidXNlcm5hbWUiLCJuOG5VdGlscyIsImZvcm1hdEVycm9yIiwiaXNJbnRlcmltTWVzc2FnZSIsImlzRmluYWxNZXNzYWdlIiwiZ2V0UHJvY2Vzc2luZ1RpbWUiLCJwcm9jZXNzaW5nVGltZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/n8n-client.ts\n"));

/***/ })

});