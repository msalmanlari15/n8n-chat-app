"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./lib/n8n-client.ts":
/*!***************************!*\
  !*** ./lib/n8n-client.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   N8NClient: () => (/* binding */ N8NClient),\n/* harmony export */   N8NError: () => (/* binding */ N8NError),\n/* harmony export */   createN8NClient: () => (/* binding */ createN8NClient),\n/* harmony export */   n8nClientExample: () => (/* binding */ n8nClientExample),\n/* harmony export */   n8nUtils: () => (/* binding */ n8nUtils)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * n8n Webhook Client\n * Handles communication with n8n workflows via webhook and streaming endpoints\n */ class N8NError extends Error {\n    constructor(message, type, details){\n        super(message), this.type = type, this.details = details;\n        this.name = 'N8NError';\n    }\n}\nclass N8NClient {\n    /**\n   * Send a message to n8n webhook\n   */ async sendMessage(request) {\n        const { webhookUrl, timeout } = this.config;\n        try {\n            console.log('=== N8N WEBHOOK DEBUG ===');\n            console.log('Webhook URL:', webhookUrl);\n            console.log('Request payload:', JSON.stringify(request, null, 2));\n            const response = await fetch(webhookUrl, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Accept': 'application/json'\n                },\n                body: JSON.stringify(request),\n                signal: AbortSignal.timeout(timeout)\n            });\n            console.log('Response status:', response.status);\n            console.log('Response headers:', Object.fromEntries(response.headers.entries()));\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('Error response body:', errorText);\n                throw new N8NError(\"HTTP \".concat(response.status, \": \").concat(response.statusText), 'server', {\n                    status: response.status,\n                    statusText: response.statusText,\n                    body: errorText\n                });\n            }\n            const responseText = await response.text();\n            console.log('Raw response:', responseText);\n            let data;\n            try {\n                data = JSON.parse(responseText);\n            } catch (parseError) {\n                console.log('Response is not JSON, treating as plain text');\n                data = responseText;\n            }\n            console.log('Parsed response data:', data);\n            const validatedResponse = this.validateResponse(data);\n            console.log('Validated response:', validatedResponse);\n            console.log('=== END N8N WEBHOOK DEBUG ===');\n            return validatedResponse;\n        } catch (error) {\n            console.error('=== N8N WEBHOOK ERROR ===');\n            console.error('Error details:', error);\n            console.error('Error type:', error instanceof Error ? error.constructor.name : typeof error);\n            console.error('Error message:', error instanceof Error ? error.message : String(error));\n            console.error('=== END N8N WEBHOOK ERROR ===');\n            if (error instanceof Error) {\n                if (error.name === 'TimeoutError' || error.name === 'AbortError') {\n                    throw new N8NError('Request timeout', 'timeout');\n                }\n                if (error.message.includes('fetch') || error.message.includes('network')) {\n                    throw new N8NError('Network error', 'network', error);\n                }\n            }\n            throw error;\n        }\n    }\n    /**\n   * Set up streaming connection for real-time updates\n   */ async *streamMessages(sessionId) {\n        const { streamingUrl } = this.config;\n        const url = new URL(streamingUrl);\n        url.searchParams.set('sessionId', sessionId);\n        try {\n            var _response_body;\n            const response = await fetch(url.toString(), {\n                headers: {\n                    'Accept': 'text/event-stream',\n                    'Cache-Control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                throw new N8NError(\"Streaming failed: \".concat(response.status), 'server', {\n                    status: response.status\n                });\n            }\n            const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n            if (!reader) {\n                throw new N8NError('No response body', 'server');\n            }\n            const decoder = new TextDecoder();\n            let buffer = '';\n            try {\n                while(true){\n                    const { done, value } = await reader.read();\n                    if (done) break;\n                    buffer += decoder.decode(value, {\n                        stream: true\n                    });\n                    const lines = buffer.split('\\n');\n                    // Keep the last incomplete line in buffer\n                    buffer = lines.pop() || '';\n                    for (const line of lines){\n                        if (line.trim() === '') continue;\n                        if (line.startsWith('data: ')) {\n                            const data = line.slice(6);\n                            if (data === '[DONE]') {\n                                return;\n                            }\n                            try {\n                                const parsed = JSON.parse(data);\n                                const response = this.validateResponse(parsed);\n                                yield response;\n                            } catch (error) {\n                                console.warn('Failed to parse streaming data:', error);\n                            }\n                        }\n                    }\n                }\n            } finally{\n                reader.releaseLock();\n            }\n        } catch (error) {\n            if (error instanceof N8NError) {\n                throw error;\n            }\n            throw new N8NError('Streaming connection failed', 'network', error);\n        }\n    }\n    /**\n   * Send message with retry logic\n   */ async sendMessageWithRetry(request) {\n        const { retryAttempts, retryDelay } = this.config;\n        for(let attempt = 1; attempt <= retryAttempts; attempt++){\n            try {\n                return await this.sendMessage(request);\n            } catch (error) {\n                if (error instanceof N8NError) {\n                    // Don't retry validation errors\n                    if (error.type === 'validation') {\n                        throw error;\n                    }\n                    // Don't retry on final attempt\n                    if (attempt === retryAttempts) {\n                        throw error;\n                    }\n                    // Wait before retry\n                    await new Promise((resolve)=>setTimeout(resolve, retryDelay * attempt));\n                } else {\n                    throw error;\n                }\n            }\n        }\n        throw new N8NError('Max retry attempts reached', 'network');\n    }\n    /**\n   * Remove duplicate content from response\n   */ deduplicateContent(content) {\n        if (typeof content !== 'string') {\n            return content;\n        }\n        // Split content into lines\n        const lines = content.split('\\n');\n        const seenLines = new Set();\n        const deduplicatedLines = [];\n        for (const line of lines){\n            const trimmedLine = line.trim();\n            // Skip empty lines for deduplication check\n            if (trimmedLine === '') {\n                deduplicatedLines.push(line);\n                continue;\n            }\n            // If we haven't seen this line before, add it\n            if (!seenLines.has(trimmedLine)) {\n                seenLines.add(trimmedLine);\n                deduplicatedLines.push(line);\n            }\n        }\n        return deduplicatedLines.join('\\n');\n    }\n    /**\n   * Detect if content is mixed format (contains text and chart keys)\n   */ isMixedContent(content) {\n        if (!Array.isArray(content)) return false;\n        return content.some((item)=>{\n            if (!item || typeof item !== 'object') return false;\n            const keys = Object.keys(item);\n            const hasText = keys.some((key)=>key.startsWith('text'));\n            const hasChart = keys.some((key)=>key.startsWith('chart'));\n            return hasText || hasChart;\n        });\n    }\n    /**\n   * Validate n8n response format\n   */ validateResponse(data) {\n        if (!data || typeof data !== 'object') {\n            // If we get a simple response, wrap it in our expected format\n            return {\n                type: 'final',\n                messageType: 'text',\n                content: String(data),\n                metadata: {\n                    timestamp: new Date()\n                }\n            };\n        }\n        // Check if response already has our expected format\n        if (data.type && data.messageType && data.content !== undefined) {\n            return {\n                type: data.type,\n                messageType: data.messageType,\n                content: data.messageType === 'text' ? this.deduplicateContent(data.content) : data.content,\n                metadata: data.metadata || {\n                    timestamp: new Date()\n                }\n            };\n        }\n        // Handle various possible n8n response formats\n        let content = data.content || data.message || data.response || data.text || data.output || data;\n        let messageType = data.messageType || data.format || 'text';\n        let type = data.type || 'final';\n        // Special handling for n8n output field that contains JSON string\n        if (data.output && typeof data.output === 'string') {\n            try {\n                const parsedOutput = JSON.parse(data.output);\n                if (parsedOutput && typeof parsedOutput === 'object') {\n                    // If the output contains a valid JSON object, use it as the base\n                    content = parsedOutput.content || parsedOutput;\n                    messageType = parsedOutput.messageType || messageType;\n                    type = parsedOutput.type || type;\n                }\n            } catch (error) {\n                // If parsing fails, treat output as regular text content\n                console.warn('Failed to parse n8n output as JSON:', error);\n            }\n        }\n        // Check if this is a mixed content response (array with text/chart combinations)\n        if (this.isMixedContent(content)) {\n            messageType = 'mixed';\n        } else if (Array.isArray(content)) {\n            // If it's an array but not mixed content, treat as JSON\n            messageType = 'json';\n        }\n        // Validate messageType\n        if (![\n            'text',\n            'json',\n            'image',\n            'chart',\n            'error',\n            'mixed'\n        ].includes(messageType)) {\n            messageType = 'text';\n        }\n        // Validate type\n        if (![\n            'interim',\n            'final'\n        ].includes(type)) {\n            type = 'final';\n        }\n        return {\n            type,\n            messageType,\n            content: messageType === 'text' ? this.deduplicateContent(content) : content,\n            metadata: data.metadata || {\n                timestamp: new Date(),\n                source: 'n8n-webhook',\n                originalResponse: data\n            }\n        };\n    }\n    /**\n   * Cancel ongoing request\n   */ cancel() {\n        // Requests now use AbortSignal.timeout() which auto-cancels\n        console.log('Cancel requested - using timeout-based cancellation');\n    }\n    /**\n   * Health check endpoint\n   */ async healthCheck() {\n        try {\n            const response = await fetch(\"\".concat(this.config.webhookUrl, \"/health\"), {\n                method: 'GET',\n                signal: AbortSignal.timeout(5000)\n            });\n            return response.ok;\n        } catch (e) {\n            return false;\n        }\n    }\n    constructor(config){\n        this.config = {\n            timeout: 120000,\n            retryAttempts: 3,\n            retryDelay: 1000,\n            ...config\n        };\n    }\n}\n// Factory function for creating client instances\nfunction createN8NClient(config) {\n    return new N8NClient(config);\n}\n// Example usage\nconst n8nClientExample = ()=>{\n    const client = createN8NClient({\n        webhookUrl: process.env.N8N_WEBHOOK_URL,\n        streamingUrl: process.env.N8N_STREAMING_URL,\n        timeout: 30000,\n        retryAttempts: 3,\n        retryDelay: 1000\n    });\n    // Example: Send message\n    const sendMessage = async ()=>{\n        try {\n            const request = {\n                username: 'user123',\n                message: 'Hello, can you analyze this data?',\n                sessionId: 'session-123',\n                timestamp: new Date()\n            };\n            const response = await client.sendMessageWithRetry(request);\n            console.log('Response:', response);\n        } catch (error) {\n            if (error instanceof N8NError) {\n                console.error('N8N Error:', error.message, error.type);\n            } else {\n                console.error('Unexpected error:', error);\n            }\n        }\n    };\n    // Example: Stream messages\n    const streamMessages = async ()=>{\n        try {\n            const sessionId = 'session-123';\n            for await (const response of client.streamMessages(sessionId)){\n                console.log('Streaming response:', response);\n                if (response.type === 'final') {\n                    break;\n                }\n            }\n        } catch (error) {\n            console.error('Streaming error:', error);\n        }\n    };\n    return {\n        sendMessage,\n        streamMessages\n    };\n};\n// Utility functions for common operations\nconst n8nUtils = {\n    /**\n   * Format error for user display\n   */ formatError (error) {\n        switch(error.type){\n            case 'network':\n                return 'Network connection failed. Please check your internet connection.';\n            case 'timeout':\n                return 'Request timed out. The workflow may be taking longer than expected.';\n            case 'server':\n                return 'Server error occurred. Please try again later.';\n            case 'validation':\n                return 'Invalid data format. Please contact support.';\n            default:\n                return 'An unexpected error occurred. Please try again.';\n        }\n    },\n    /**\n   * Check if response is interim message\n   */ isInterimMessage (response) {\n        return response.type === 'interim';\n    },\n    /**\n   * Check if response is final message\n   */ isFinalMessage (response) {\n        return response.type === 'final';\n    },\n    /**\n   * Extract processing time from metadata\n   */ getProcessingTime (response) {\n        var _response_metadata;\n        return ((_response_metadata = response.metadata) === null || _response_metadata === void 0 ? void 0 : _response_metadata.processingTime) || null;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFNekIsWUFBWTRGLE9BQU9wRSxjQUFjLENBQUNDLFdBQVk7Z0JBQzdEN0IsUUFBUUMsR0FBRyxDQUFDLHVCQUF1Qkc7Z0JBRW5DLElBQUlBLFNBQVNiLElBQUksS0FBSyxTQUFTO29CQUM3QjtnQkFDRjtZQUNGO1FBQ0YsRUFBRSxPQUFPMkIsT0FBTztZQUNkbEIsUUFBUWtCLEtBQUssQ0FBQyxvQkFBb0JBO1FBQ3BDO0lBQ0Y7SUFFQSxPQUFPO1FBQUV2QjtRQUFhaUM7SUFBZTtBQUN2QyxFQUFFO0FBRUYsMENBQTBDO0FBQ25DLE1BQU0wRSxXQUFXO0lBQ3RCOztHQUVDLEdBQ0RDLGFBQVlyRixLQUFlO1FBQ3pCLE9BQVFBLE1BQU0zQixJQUFJO1lBQ2hCLEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNUO2dCQUNFLE9BQU87UUFDWDtJQUNGO0lBRUE7O0dBRUMsR0FDRGlILGtCQUFpQnBHLFFBQXFCO1FBQ3BDLE9BQU9BLFNBQVNiLElBQUksS0FBSztJQUMzQjtJQUVBOztHQUVDLEdBQ0RrSCxnQkFBZXJHLFFBQXFCO1FBQ2xDLE9BQU9BLFNBQVNiLElBQUksS0FBSztJQUMzQjtJQUVBOztHQUVDLEdBQ0RtSCxtQkFBa0J0RyxRQUFxQjtZQUM5QkE7UUFBUCxPQUFPQSxFQUFBQSxxQkFBQUEsU0FBUytFLFFBQVEsY0FBakIvRSx5Q0FBQUEsbUJBQW1CdUcsY0FBYyxLQUFJO0lBQzlDO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiQzpcXEVidHRpa2FyIEludGVsbGlnZW5jZSBQcm9qZWN0c1xcVGVzdC1DaGF0LUFwcFxcbGliXFxuOG4tY2xpZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbjhuIFdlYmhvb2sgQ2xpZW50XG4gKiBIYW5kbGVzIGNvbW11bmljYXRpb24gd2l0aCBuOG4gd29ya2Zsb3dzIHZpYSB3ZWJob29rIGFuZCBzdHJlYW1pbmcgZW5kcG9pbnRzXG4gKi9cblxuaW1wb3J0IHsgTjhOUmVxdWVzdCwgTjhOUmVzcG9uc2UsIENoYXRFcnJvciB9IGZyb20gJ0AvdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgTjhORXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U6IHN0cmluZyxcbiAgICBwdWJsaWMgdHlwZTogJ25ldHdvcmsnIHwgJ3RpbWVvdXQnIHwgJ3NlcnZlcicgfCAndmFsaWRhdGlvbicsXG4gICAgcHVibGljIGRldGFpbHM/OiBhbnlcbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ044TkVycm9yJztcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE44TkNsaWVudENvbmZpZyB7XG4gIHdlYmhvb2tVcmw6IHN0cmluZztcbiAgc3RyZWFtaW5nVXJsOiBzdHJpbmc7XG4gIHRpbWVvdXQ/OiBudW1iZXI7XG4gIHJldHJ5QXR0ZW1wdHM/OiBudW1iZXI7XG4gIHJldHJ5RGVsYXk/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBOOE5DbGllbnQge1xuICBwcml2YXRlIGNvbmZpZzogUmVxdWlyZWQ8TjhOQ2xpZW50Q29uZmlnPjtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IE44TkNsaWVudENvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgdGltZW91dDogMTIwMDAwLCAvLyBJbmNyZWFzZWQgdG8gMiBtaW51dGVzIGZvciBBSSBwcm9jZXNzaW5nXG4gICAgICByZXRyeUF0dGVtcHRzOiAzLFxuICAgICAgcmV0cnlEZWxheTogMTAwMCxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIG1lc3NhZ2UgdG8gbjhuIHdlYmhvb2tcbiAgICovXG4gIGFzeW5jIHNlbmRNZXNzYWdlKHJlcXVlc3Q6IE44TlJlcXVlc3QpOiBQcm9taXNlPE44TlJlc3BvbnNlPiB7XG4gICAgY29uc3QgeyB3ZWJob29rVXJsLCB0aW1lb3V0IH0gPSB0aGlzLmNvbmZpZztcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJz09PSBOOE4gV0VCSE9PSyBERUJVRyA9PT0nKTtcbiAgICAgIGNvbnNvbGUubG9nKCdXZWJob29rIFVSTDonLCB3ZWJob29rVXJsKTtcbiAgICAgIGNvbnNvbGUubG9nKCdSZXF1ZXN0IHBheWxvYWQ6JywgSlNPTi5zdHJpbmdpZnkocmVxdWVzdCwgbnVsbCwgMikpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHdlYmhvb2tVcmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLFxuICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGltZW91dCksXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coJ1Jlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgY29uc29sZS5sb2coJ1Jlc3BvbnNlIGhlYWRlcnM6JywgT2JqZWN0LmZyb21FbnRyaWVzKHJlc3BvbnNlLmhlYWRlcnMuZW50cmllcygpKSk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXNwb25zZSBib2R5OicsIGVycm9yVGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBOOE5FcnJvcihcbiAgICAgICAgICBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gLFxuICAgICAgICAgICdzZXJ2ZXInLFxuICAgICAgICAgIHsgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsIGJvZHk6IGVycm9yVGV4dCB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIGNvbnNvbGUubG9nKCdSYXcgcmVzcG9uc2U6JywgcmVzcG9uc2VUZXh0KTtcbiAgICAgIFxuICAgICAgbGV0IGRhdGE7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpO1xuICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZygnUmVzcG9uc2UgaXMgbm90IEpTT04sIHRyZWF0aW5nIGFzIHBsYWluIHRleHQnKTtcbiAgICAgICAgZGF0YSA9IHJlc3BvbnNlVGV4dDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1BhcnNlZCByZXNwb25zZSBkYXRhOicsIGRhdGEpO1xuICAgICAgY29uc3QgdmFsaWRhdGVkUmVzcG9uc2UgPSB0aGlzLnZhbGlkYXRlUmVzcG9uc2UoZGF0YSk7XG4gICAgICBjb25zb2xlLmxvZygnVmFsaWRhdGVkIHJlc3BvbnNlOicsIHZhbGlkYXRlZFJlc3BvbnNlKTtcbiAgICAgIGNvbnNvbGUubG9nKCc9PT0gRU5EIE44TiBXRUJIT09LIERFQlVHID09PScpO1xuICAgICAgXG4gICAgICByZXR1cm4gdmFsaWRhdGVkUmVzcG9uc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJz09PSBOOE4gV0VCSE9PSyBFUlJPUiA9PT0nKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6JywgZXJyb3IpO1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdHlwZTonLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IuY29uc3RydWN0b3IubmFtZSA6IHR5cGVvZiBlcnJvcik7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBtZXNzYWdlOicsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSk7XG4gICAgICBjb25zb2xlLmVycm9yKCc9PT0gRU5EIE44TiBXRUJIT09LIEVSUk9SID09PScpO1xuICAgICAgXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ1RpbWVvdXRFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE44TkVycm9yKCdSZXF1ZXN0IHRpbWVvdXQnLCAndGltZW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZmV0Y2gnKSB8fCBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCduZXR3b3JrJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTjhORXJyb3IoJ05ldHdvcmsgZXJyb3InLCAnbmV0d29yaycsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIHN0cmVhbWluZyBjb25uZWN0aW9uIGZvciByZWFsLXRpbWUgdXBkYXRlc1xuICAgKi9cbiAgYXN5bmMgKnN0cmVhbU1lc3NhZ2VzKHNlc3Npb25JZDogc3RyaW5nKTogQXN5bmNHZW5lcmF0b3I8TjhOUmVzcG9uc2UsIHZvaWQsIHVua25vd24+IHtcbiAgICBjb25zdCB7IHN0cmVhbWluZ1VybCB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChzdHJlYW1pbmdVcmwpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdzZXNzaW9uSWQnLCBzZXNzaW9uSWQpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBY2NlcHQnOiAndGV4dC9ldmVudC1zdHJlYW0nLFxuICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBOOE5FcnJvcihcbiAgICAgICAgICBgU3RyZWFtaW5nIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9YCxcbiAgICAgICAgICAnc2VydmVyJyxcbiAgICAgICAgICB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzIH1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keT8uZ2V0UmVhZGVyKCk7XG4gICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgTjhORXJyb3IoJ05vIHJlc3BvbnNlIGJvZHknLCAnc2VydmVyJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgIGxldCBidWZmZXIgPSAnJztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgICAgICBcbiAgICAgICAgICBidWZmZXIgKz0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgIGNvbnN0IGxpbmVzID0gYnVmZmVyLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBLZWVwIHRoZSBsYXN0IGluY29tcGxldGUgbGluZSBpbiBidWZmZXJcbiAgICAgICAgICBidWZmZXIgPSBsaW5lcy5wb3AoKSB8fCAnJztcbiAgICAgICAgICBcbiAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICAgIGlmIChsaW5lLnRyaW0oKSA9PT0gJycpIGNvbnRpbnVlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKCdkYXRhOiAnKSkge1xuICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbGluZS5zbGljZSg2KTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChkYXRhID09PSAnW0RPTkVdJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy52YWxpZGF0ZVJlc3BvbnNlKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgeWllbGQgcmVzcG9uc2U7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtaW5nIGRhdGE6JywgZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgTjhORXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IG5ldyBOOE5FcnJvcihcbiAgICAgICAgJ1N0cmVhbWluZyBjb25uZWN0aW9uIGZhaWxlZCcsXG4gICAgICAgICduZXR3b3JrJyxcbiAgICAgICAgZXJyb3JcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgbWVzc2FnZSB3aXRoIHJldHJ5IGxvZ2ljXG4gICAqL1xuICBhc3luYyBzZW5kTWVzc2FnZVdpdGhSZXRyeShyZXF1ZXN0OiBOOE5SZXF1ZXN0KTogUHJvbWlzZTxOOE5SZXNwb25zZT4ge1xuICAgIGNvbnN0IHsgcmV0cnlBdHRlbXB0cywgcmV0cnlEZWxheSB9ID0gdGhpcy5jb25maWc7XG4gICAgXG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gcmV0cnlBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZShyZXF1ZXN0KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE44TkVycm9yKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgcmV0cnkgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICAgICAgICBpZiAoZXJyb3IudHlwZSA9PT0gJ3ZhbGlkYXRpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRG9uJ3QgcmV0cnkgb24gZmluYWwgYXR0ZW1wdFxuICAgICAgICAgIGlmIChhdHRlbXB0ID09PSByZXRyeUF0dGVtcHRzKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gV2FpdCBiZWZvcmUgcmV0cnlcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheSAqIGF0dGVtcHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aHJvdyBuZXcgTjhORXJyb3IoJ01heCByZXRyeSBhdHRlbXB0cyByZWFjaGVkJywgJ25ldHdvcmsnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgZHVwbGljYXRlIGNvbnRlbnQgZnJvbSByZXNwb25zZVxuICAgKi9cbiAgcHJpdmF0ZSBkZWR1cGxpY2F0ZUNvbnRlbnQoY29udGVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG5cbiAgICAvLyBTcGxpdCBjb250ZW50IGludG8gbGluZXNcbiAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IHNlZW5MaW5lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IGRlZHVwbGljYXRlZExpbmVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgY29uc3QgdHJpbW1lZExpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgIFxuICAgICAgLy8gU2tpcCBlbXB0eSBsaW5lcyBmb3IgZGVkdXBsaWNhdGlvbiBjaGVja1xuICAgICAgaWYgKHRyaW1tZWRMaW5lID09PSAnJykge1xuICAgICAgICBkZWR1cGxpY2F0ZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBzZWVuIHRoaXMgbGluZSBiZWZvcmUsIGFkZCBpdFxuICAgICAgaWYgKCFzZWVuTGluZXMuaGFzKHRyaW1tZWRMaW5lKSkge1xuICAgICAgICBzZWVuTGluZXMuYWRkKHRyaW1tZWRMaW5lKTtcbiAgICAgICAgZGVkdXBsaWNhdGVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGRlZHVwbGljYXRlZExpbmVzLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBjb250ZW50IGlzIG1peGVkIGZvcm1hdCAoY29udGFpbnMgdGV4dCBhbmQgY2hhcnQga2V5cylcbiAgICovXG4gIHByaXZhdGUgaXNNaXhlZENvbnRlbnQoY29udGVudDogYW55KTogYm9vbGVhbiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbnRlbnQpKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgcmV0dXJuIGNvbnRlbnQuc29tZShpdGVtID0+IHtcbiAgICAgIGlmICghaXRlbSB8fCB0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICAgIFxuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGl0ZW0pO1xuICAgICAgY29uc3QgaGFzVGV4dCA9IGtleXMuc29tZShrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ3RleHQnKSk7XG4gICAgICBjb25zdCBoYXNDaGFydCA9IGtleXMuc29tZShrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ2NoYXJ0JykpO1xuICAgICAgXG4gICAgICByZXR1cm4gaGFzVGV4dCB8fCBoYXNDaGFydDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBuOG4gcmVzcG9uc2UgZm9ybWF0XG4gICAqL1xuICBwcml2YXRlIHZhbGlkYXRlUmVzcG9uc2UoZGF0YTogYW55KTogTjhOUmVzcG9uc2Uge1xuICAgIGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIElmIHdlIGdldCBhIHNpbXBsZSByZXNwb25zZSwgd3JhcCBpdCBpbiBvdXIgZXhwZWN0ZWQgZm9ybWF0XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZmluYWwnLFxuICAgICAgICBtZXNzYWdlVHlwZTogJ3RleHQnLFxuICAgICAgICBjb250ZW50OiBTdHJpbmcoZGF0YSksXG4gICAgICAgIG1ldGFkYXRhOiB7IHRpbWVzdGFtcDogbmV3IERhdGUoKSB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHJlc3BvbnNlIGFscmVhZHkgaGFzIG91ciBleHBlY3RlZCBmb3JtYXRcbiAgICBpZiAoZGF0YS50eXBlICYmIGRhdGEubWVzc2FnZVR5cGUgJiYgZGF0YS5jb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGRhdGEudHlwZSxcbiAgICAgICAgbWVzc2FnZVR5cGU6IGRhdGEubWVzc2FnZVR5cGUsXG4gICAgICAgIGNvbnRlbnQ6IGRhdGEubWVzc2FnZVR5cGUgPT09ICd0ZXh0JyA/IHRoaXMuZGVkdXBsaWNhdGVDb250ZW50KGRhdGEuY29udGVudCkgOiBkYXRhLmNvbnRlbnQsXG4gICAgICAgIG1ldGFkYXRhOiBkYXRhLm1ldGFkYXRhIHx8IHsgdGltZXN0YW1wOiBuZXcgRGF0ZSgpIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHZhcmlvdXMgcG9zc2libGUgbjhuIHJlc3BvbnNlIGZvcm1hdHNcbiAgICBsZXQgY29udGVudCA9IGRhdGEuY29udGVudCB8fCBkYXRhLm1lc3NhZ2UgfHwgZGF0YS5yZXNwb25zZSB8fCBkYXRhLnRleHQgfHwgZGF0YS5vdXRwdXQgfHwgZGF0YTtcbiAgICBsZXQgbWVzc2FnZVR5cGUgPSBkYXRhLm1lc3NhZ2VUeXBlIHx8IGRhdGEuZm9ybWF0IHx8ICd0ZXh0JztcbiAgICBsZXQgdHlwZSA9IGRhdGEudHlwZSB8fCAnZmluYWwnO1xuICAgIFxuICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIG44biBvdXRwdXQgZmllbGQgdGhhdCBjb250YWlucyBKU09OIHN0cmluZ1xuICAgIGlmIChkYXRhLm91dHB1dCAmJiB0eXBlb2YgZGF0YS5vdXRwdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWRPdXRwdXQgPSBKU09OLnBhcnNlKGRhdGEub3V0cHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZE91dHB1dCAmJiB0eXBlb2YgcGFyc2VkT3V0cHV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIC8vIElmIHRoZSBvdXRwdXQgY29udGFpbnMgYSB2YWxpZCBKU09OIG9iamVjdCwgdXNlIGl0IGFzIHRoZSBiYXNlXG4gICAgICAgICAgY29udGVudCA9IHBhcnNlZE91dHB1dC5jb250ZW50IHx8IHBhcnNlZE91dHB1dDtcbiAgICAgICAgICBtZXNzYWdlVHlwZSA9IHBhcnNlZE91dHB1dC5tZXNzYWdlVHlwZSB8fCBtZXNzYWdlVHlwZTtcbiAgICAgICAgICB0eXBlID0gcGFyc2VkT3V0cHV0LnR5cGUgfHwgdHlwZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgcGFyc2luZyBmYWlscywgdHJlYXQgb3V0cHV0IGFzIHJlZ3VsYXIgdGV4dCBjb250ZW50XG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIG44biBvdXRwdXQgYXMgSlNPTjonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIG1peGVkIGNvbnRlbnQgcmVzcG9uc2UgKGFycmF5IHdpdGggdGV4dC9jaGFydCBjb21iaW5hdGlvbnMpXG4gICAgaWYgKHRoaXMuaXNNaXhlZENvbnRlbnQoY29udGVudCkpIHtcbiAgICAgIG1lc3NhZ2VUeXBlID0gJ21peGVkJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudCkpIHtcbiAgICAgIC8vIElmIGl0J3MgYW4gYXJyYXkgYnV0IG5vdCBtaXhlZCBjb250ZW50LCB0cmVhdCBhcyBKU09OXG4gICAgICBtZXNzYWdlVHlwZSA9ICdqc29uJztcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBtZXNzYWdlVHlwZVxuICAgIGlmICghWyd0ZXh0JywgJ2pzb24nLCAnaW1hZ2UnLCAnY2hhcnQnLCAnZXJyb3InLCAnbWl4ZWQnXS5pbmNsdWRlcyhtZXNzYWdlVHlwZSkpIHtcbiAgICAgIG1lc3NhZ2VUeXBlID0gJ3RleHQnO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHR5cGVcbiAgICBpZiAoIVsnaW50ZXJpbScsICdmaW5hbCddLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICB0eXBlID0gJ2ZpbmFsJztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZSxcbiAgICAgIG1lc3NhZ2VUeXBlLFxuICAgICAgY29udGVudDogbWVzc2FnZVR5cGUgPT09ICd0ZXh0JyA/IHRoaXMuZGVkdXBsaWNhdGVDb250ZW50KGNvbnRlbnQpIDogY29udGVudCxcbiAgICAgIG1ldGFkYXRhOiBkYXRhLm1ldGFkYXRhIHx8IHsgXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgc291cmNlOiAnbjhuLXdlYmhvb2snLFxuICAgICAgICBvcmlnaW5hbFJlc3BvbnNlOiBkYXRhXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgb25nb2luZyByZXF1ZXN0XG4gICAqL1xuICBjYW5jZWwoKTogdm9pZCB7XG4gICAgLy8gUmVxdWVzdHMgbm93IHVzZSBBYm9ydFNpZ25hbC50aW1lb3V0KCkgd2hpY2ggYXV0by1jYW5jZWxzXG4gICAgY29uc29sZS5sb2coJ0NhbmNlbCByZXF1ZXN0ZWQgLSB1c2luZyB0aW1lb3V0LWJhc2VkIGNhbmNlbGxhdGlvbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlYWx0aCBjaGVjayBlbmRwb2ludFxuICAgKi9cbiAgYXN5bmMgaGVhbHRoQ2hlY2soKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5jb25maWcud2ViaG9va1VybH0vaGVhbHRoYCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQoNTAwMCksXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3BvbnNlLm9rO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG4vLyBGYWN0b3J5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBjbGllbnQgaW5zdGFuY2VzXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTjhOQ2xpZW50KGNvbmZpZzogTjhOQ2xpZW50Q29uZmlnKTogTjhOQ2xpZW50IHtcbiAgcmV0dXJuIG5ldyBOOE5DbGllbnQoY29uZmlnKTtcbn1cblxuLy8gRXhhbXBsZSB1c2FnZVxuZXhwb3J0IGNvbnN0IG44bkNsaWVudEV4YW1wbGUgPSAoKSA9PiB7XG4gIGNvbnN0IGNsaWVudCA9IGNyZWF0ZU44TkNsaWVudCh7XG4gICAgd2ViaG9va1VybDogcHJvY2Vzcy5lbnYuTjhOX1dFQkhPT0tfVVJMISxcbiAgICBzdHJlYW1pbmdVcmw6IHByb2Nlc3MuZW52Lk44Tl9TVFJFQU1JTkdfVVJMISxcbiAgICB0aW1lb3V0OiAzMDAwMCxcbiAgICByZXRyeUF0dGVtcHRzOiAzLFxuICAgIHJldHJ5RGVsYXk6IDEwMDBcbiAgfSk7XG5cbiAgLy8gRXhhbXBsZTogU2VuZCBtZXNzYWdlXG4gIGNvbnN0IHNlbmRNZXNzYWdlID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXF1ZXN0OiBOOE5SZXF1ZXN0ID0ge1xuICAgICAgICB1c2VybmFtZTogJ3VzZXIxMjMnLFxuICAgICAgICBtZXNzYWdlOiAnSGVsbG8sIGNhbiB5b3UgYW5hbHl6ZSB0aGlzIGRhdGE/JyxcbiAgICAgICAgc2Vzc2lvbklkOiAnc2Vzc2lvbi0xMjMnLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKClcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50LnNlbmRNZXNzYWdlV2l0aFJldHJ5KHJlcXVlc3QpO1xuICAgICAgY29uc29sZS5sb2coJ1Jlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgTjhORXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignTjhOIEVycm9yOicsIGVycm9yLm1lc3NhZ2UsIGVycm9yLnR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBlcnJvcjonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIEV4YW1wbGU6IFN0cmVhbSBtZXNzYWdlc1xuICBjb25zdCBzdHJlYW1NZXNzYWdlcyA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2Vzc2lvbklkID0gJ3Nlc3Npb24tMTIzJztcbiAgICAgIFxuICAgICAgZm9yIGF3YWl0IChjb25zdCByZXNwb25zZSBvZiBjbGllbnQuc3RyZWFtTWVzc2FnZXMoc2Vzc2lvbklkKSkge1xuICAgICAgICBjb25zb2xlLmxvZygnU3RyZWFtaW5nIHJlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChyZXNwb25zZS50eXBlID09PSAnZmluYWwnKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignU3RyZWFtaW5nIGVycm9yOicsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHsgc2VuZE1lc3NhZ2UsIHN0cmVhbU1lc3NhZ2VzIH07XG59O1xuXG4vLyBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgY29tbW9uIG9wZXJhdGlvbnNcbmV4cG9ydCBjb25zdCBuOG5VdGlscyA9IHtcbiAgLyoqXG4gICAqIEZvcm1hdCBlcnJvciBmb3IgdXNlciBkaXNwbGF5XG4gICAqL1xuICBmb3JtYXRFcnJvcihlcnJvcjogTjhORXJyb3IpOiBzdHJpbmcge1xuICAgIHN3aXRjaCAoZXJyb3IudHlwZSkge1xuICAgICAgY2FzZSAnbmV0d29yayc6XG4gICAgICAgIHJldHVybiAnTmV0d29yayBjb25uZWN0aW9uIGZhaWxlZC4gUGxlYXNlIGNoZWNrIHlvdXIgaW50ZXJuZXQgY29ubmVjdGlvbi4nO1xuICAgICAgY2FzZSAndGltZW91dCc6XG4gICAgICAgIHJldHVybiAnUmVxdWVzdCB0aW1lZCBvdXQuIFRoZSB3b3JrZmxvdyBtYXkgYmUgdGFraW5nIGxvbmdlciB0aGFuIGV4cGVjdGVkLic7XG4gICAgICBjYXNlICdzZXJ2ZXInOlxuICAgICAgICByZXR1cm4gJ1NlcnZlciBlcnJvciBvY2N1cnJlZC4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci4nO1xuICAgICAgY2FzZSAndmFsaWRhdGlvbic6XG4gICAgICAgIHJldHVybiAnSW52YWxpZCBkYXRhIGZvcm1hdC4gUGxlYXNlIGNvbnRhY3Qgc3VwcG9ydC4nO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkLiBQbGVhc2UgdHJ5IGFnYWluLic7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiByZXNwb25zZSBpcyBpbnRlcmltIG1lc3NhZ2VcbiAgICovXG4gIGlzSW50ZXJpbU1lc3NhZ2UocmVzcG9uc2U6IE44TlJlc3BvbnNlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnR5cGUgPT09ICdpbnRlcmltJztcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgcmVzcG9uc2UgaXMgZmluYWwgbWVzc2FnZVxuICAgKi9cbiAgaXNGaW5hbE1lc3NhZ2UocmVzcG9uc2U6IE44TlJlc3BvbnNlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnR5cGUgPT09ICdmaW5hbCc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgcHJvY2Vzc2luZyB0aW1lIGZyb20gbWV0YWRhdGFcbiAgICovXG4gIGdldFByb2Nlc3NpbmdUaW1lKHJlc3BvbnNlOiBOOE5SZXNwb25zZSk6IG51bWJlciB8IG51bGwge1xuICAgIHJldHVybiByZXNwb25zZS5tZXRhZGF0YT8ucHJvY2Vzc2luZ1RpbWUgfHwgbnVsbDtcbiAgfVxufTsiXSwibmFtZXMiOlsiTjhORXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJ0eXBlIiwiZGV0YWlscyIsIm5hbWUiLCJOOE5DbGllbnQiLCJzZW5kTWVzc2FnZSIsInJlcXVlc3QiLCJ3ZWJob29rVXJsIiwidGltZW91dCIsImNvbmZpZyIsImNvbnNvbGUiLCJsb2ciLCJKU09OIiwic3RyaW5naWZ5IiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5Iiwic2lnbmFsIiwiQWJvcnRTaWduYWwiLCJzdGF0dXMiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJvayIsImVycm9yVGV4dCIsInRleHQiLCJlcnJvciIsInN0YXR1c1RleHQiLCJyZXNwb25zZVRleHQiLCJkYXRhIiwicGFyc2UiLCJwYXJzZUVycm9yIiwidmFsaWRhdGVkUmVzcG9uc2UiLCJ2YWxpZGF0ZVJlc3BvbnNlIiwiU3RyaW5nIiwiaW5jbHVkZXMiLCJzdHJlYW1NZXNzYWdlcyIsInNlc3Npb25JZCIsInN0cmVhbWluZ1VybCIsInVybCIsIlVSTCIsInNlYXJjaFBhcmFtcyIsInNldCIsInRvU3RyaW5nIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiYnVmZmVyIiwiZG9uZSIsInZhbHVlIiwicmVhZCIsImRlY29kZSIsInN0cmVhbSIsImxpbmVzIiwic3BsaXQiLCJwb3AiLCJsaW5lIiwidHJpbSIsInN0YXJ0c1dpdGgiLCJzbGljZSIsInBhcnNlZCIsIndhcm4iLCJyZWxlYXNlTG9jayIsInNlbmRNZXNzYWdlV2l0aFJldHJ5IiwicmV0cnlBdHRlbXB0cyIsInJldHJ5RGVsYXkiLCJhdHRlbXB0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZGVkdXBsaWNhdGVDb250ZW50IiwiY29udGVudCIsInNlZW5MaW5lcyIsIlNldCIsImRlZHVwbGljYXRlZExpbmVzIiwidHJpbW1lZExpbmUiLCJwdXNoIiwiaGFzIiwiYWRkIiwiam9pbiIsImlzTWl4ZWRDb250ZW50IiwiQXJyYXkiLCJpc0FycmF5Iiwic29tZSIsIml0ZW0iLCJrZXlzIiwiaGFzVGV4dCIsImtleSIsImhhc0NoYXJ0IiwibWVzc2FnZVR5cGUiLCJtZXRhZGF0YSIsInRpbWVzdGFtcCIsIkRhdGUiLCJ1bmRlZmluZWQiLCJvdXRwdXQiLCJmb3JtYXQiLCJwYXJzZWRPdXRwdXQiLCJzb3VyY2UiLCJvcmlnaW5hbFJlc3BvbnNlIiwiY2FuY2VsIiwiaGVhbHRoQ2hlY2siLCJjcmVhdGVOOE5DbGllbnQiLCJuOG5DbGllbnRFeGFtcGxlIiwiY2xpZW50IiwicHJvY2VzcyIsImVudiIsIk44Tl9XRUJIT09LX1VSTCIsIk44Tl9TVFJFQU1JTkdfVVJMIiwidXNlcm5hbWUiLCJuOG5VdGlscyIsImZvcm1hdEVycm9yIiwiaXNJbnRlcmltTWVzc2FnZSIsImlzRmluYWxNZXNzYWdlIiwiZ2V0UHJvY2Vzc2luZ1RpbWUiLCJwcm9jZXNzaW5nVGltZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/n8n-client.ts\n"));

/***/ })

});