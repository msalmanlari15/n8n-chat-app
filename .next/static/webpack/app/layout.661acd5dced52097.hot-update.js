"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./lib/n8n-client.ts":
/*!***************************!*\
  !*** ./lib/n8n-client.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   N8NClient: () => (/* binding */ N8NClient),\n/* harmony export */   N8NError: () => (/* binding */ N8NError),\n/* harmony export */   createN8NClient: () => (/* binding */ createN8NClient),\n/* harmony export */   n8nClientExample: () => (/* binding */ n8nClientExample),\n/* harmony export */   n8nUtils: () => (/* binding */ n8nUtils)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * n8n Webhook Client\n * Handles communication with n8n workflows via webhook and streaming endpoints\n */ class N8NError extends Error {\n    constructor(message, type, details){\n        super(message), this.type = type, this.details = details;\n        this.name = 'N8NError';\n    }\n}\nclass N8NClient {\n    /**\n   * Send a message to n8n webhook\n   */ async sendMessage(request) {\n        const { webhookUrl, timeout } = this.config;\n        try {\n            console.log('=== N8N WEBHOOK DEBUG ===');\n            console.log('Webhook URL:', webhookUrl);\n            console.log('Request payload:', JSON.stringify(request, null, 2));\n            const response = await fetch(webhookUrl, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Accept': 'application/json'\n                },\n                body: JSON.stringify(request),\n                signal: AbortSignal.timeout(timeout)\n            });\n            console.log('Response status:', response.status);\n            console.log('Response headers:', Object.fromEntries(response.headers.entries()));\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('Error response body:', errorText);\n                throw new N8NError(\"HTTP \".concat(response.status, \": \").concat(response.statusText), 'server', {\n                    status: response.status,\n                    statusText: response.statusText,\n                    body: errorText\n                });\n            }\n            const responseText = await response.text();\n            console.log('Raw response:', responseText);\n            let data;\n            try {\n                data = JSON.parse(responseText);\n            } catch (parseError) {\n                console.log('Response is not JSON, treating as plain text');\n                data = responseText;\n            }\n            console.log('Parsed response data:', data);\n            const validatedResponse = this.validateResponse(data);\n            console.log('Validated response:', validatedResponse);\n            console.log('=== END N8N WEBHOOK DEBUG ===');\n            return validatedResponse;\n        } catch (error) {\n            console.error('=== N8N WEBHOOK ERROR ===');\n            console.error('Error details:', error);\n            console.error('Error type:', error instanceof Error ? error.constructor.name : typeof error);\n            console.error('Error message:', error instanceof Error ? error.message : String(error));\n            console.error('=== END N8N WEBHOOK ERROR ===');\n            if (error instanceof Error) {\n                if (error.name === 'TimeoutError' || error.name === 'AbortError') {\n                    throw new N8NError('Request timeout', 'timeout');\n                }\n                if (error.message.includes('fetch') || error.message.includes('network')) {\n                    throw new N8NError('Network error', 'network', error);\n                }\n            }\n            throw error;\n        }\n    }\n    /**\n   * Set up streaming connection for real-time updates\n   */ async *streamMessages(sessionId) {\n        const { streamingUrl } = this.config;\n        const url = new URL(streamingUrl);\n        url.searchParams.set('sessionId', sessionId);\n        try {\n            var _response_body;\n            const response = await fetch(url.toString(), {\n                headers: {\n                    'Accept': 'text/event-stream',\n                    'Cache-Control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                throw new N8NError(\"Streaming failed: \".concat(response.status), 'server', {\n                    status: response.status\n                });\n            }\n            const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n            if (!reader) {\n                throw new N8NError('No response body', 'server');\n            }\n            const decoder = new TextDecoder();\n            let buffer = '';\n            try {\n                while(true){\n                    const { done, value } = await reader.read();\n                    if (done) break;\n                    buffer += decoder.decode(value, {\n                        stream: true\n                    });\n                    const lines = buffer.split('\\n');\n                    // Keep the last incomplete line in buffer\n                    buffer = lines.pop() || '';\n                    for (const line of lines){\n                        if (line.trim() === '') continue;\n                        if (line.startsWith('data: ')) {\n                            const data = line.slice(6);\n                            if (data === '[DONE]') {\n                                return;\n                            }\n                            try {\n                                const parsed = JSON.parse(data);\n                                const response = this.validateResponse(parsed);\n                                yield response;\n                            } catch (error) {\n                                console.warn('Failed to parse streaming data:', error);\n                            }\n                        }\n                    }\n                }\n            } finally{\n                reader.releaseLock();\n            }\n        } catch (error) {\n            if (error instanceof N8NError) {\n                throw error;\n            }\n            throw new N8NError('Streaming connection failed', 'network', error);\n        }\n    }\n    /**\n   * Send message with retry logic\n   */ async sendMessageWithRetry(request) {\n        const { retryAttempts, retryDelay } = this.config;\n        for(let attempt = 1; attempt <= retryAttempts; attempt++){\n            try {\n                return await this.sendMessage(request);\n            } catch (error) {\n                if (error instanceof N8NError) {\n                    // Don't retry validation errors\n                    if (error.type === 'validation') {\n                        throw error;\n                    }\n                    // Don't retry on final attempt\n                    if (attempt === retryAttempts) {\n                        throw error;\n                    }\n                    // Wait before retry\n                    await new Promise((resolve)=>setTimeout(resolve, retryDelay * attempt));\n                } else {\n                    throw error;\n                }\n            }\n        }\n        throw new N8NError('Max retry attempts reached', 'network');\n    }\n    /**\n   * Remove duplicate content from response\n   */ deduplicateContent(content) {\n        if (typeof content !== 'string') {\n            return content;\n        }\n        // Split content into lines\n        const lines = content.split('\\n');\n        const seenLines = new Set();\n        const deduplicatedLines = [];\n        for (const line of lines){\n            const trimmedLine = line.trim();\n            // Skip empty lines for deduplication check\n            if (trimmedLine === '') {\n                deduplicatedLines.push(line);\n                continue;\n            }\n            // If we haven't seen this line before, add it\n            if (!seenLines.has(trimmedLine)) {\n                seenLines.add(trimmedLine);\n                deduplicatedLines.push(line);\n            }\n        }\n        return deduplicatedLines.join('\\n');\n    }\n    /**\n   * Detect if content is mixed format (contains text and chart keys)\n   */ isMixedContent(content) {\n        if (!Array.isArray(content)) return false;\n        return content.some((item)=>{\n            if (!item || typeof item !== 'object') return false;\n            const keys = Object.keys(item);\n            const hasText = keys.some((key)=>key.startsWith('text'));\n            const hasChart = keys.some((key)=>key.startsWith('chart'));\n            return hasText || hasChart;\n        });\n    }\n    /**\n   * Validate n8n response format\n   */ validateResponse(data) {\n        if (!data || typeof data !== 'object') {\n            // If we get a simple response, wrap it in our expected format\n            return {\n                type: 'final',\n                messageType: 'text',\n                content: String(data),\n                metadata: {\n                    timestamp: new Date()\n                }\n            };\n        }\n        // Check if response already has our expected format\n        if (data.type && data.messageType && data.content !== undefined) {\n            return {\n                type: data.type,\n                messageType: data.messageType,\n                content: data.messageType === 'text' ? this.deduplicateContent(data.content) : data.content,\n                metadata: data.metadata || {\n                    timestamp: new Date()\n                }\n            };\n        }\n        // Handle various possible n8n response formats\n        let content = data.content || data.message || data.response || data.text || data.output || data;\n        let messageType = data.messageType || data.format || 'text';\n        let type = data.type || 'final';\n        // Special handling for n8n output field that contains JSON string\n        if (data.output && typeof data.output === 'string') {\n            try {\n                const parsedOutput = JSON.parse(data.output);\n                if (parsedOutput && typeof parsedOutput === 'object') {\n                    // If the output contains a valid JSON object, use it as the base\n                    content = parsedOutput.content || parsedOutput;\n                    messageType = parsedOutput.messageType || messageType;\n                    type = parsedOutput.type || type;\n                }\n            } catch (error) {\n                // If parsing fails, treat output as regular text content\n                console.warn('Failed to parse n8n output as JSON:', error);\n            }\n        }\n        // Check if this is a mixed content response (array with text/chart combinations)\n        if (this.isMixedContent(content)) {\n            messageType = 'mixed';\n        } else if (Array.isArray(content)) {\n            // If it's an array but not mixed content, treat as JSON\n            messageType = 'json';\n        }\n        // Validate messageType\n        if (![\n            'text',\n            'json',\n            'image',\n            'chart',\n            'error',\n            'mixed'\n        ].includes(messageType)) {\n            messageType = 'text';\n        }\n        // Validate type\n        if (![\n            'interim',\n            'final'\n        ].includes(type)) {\n            type = 'final';\n        }\n        return {\n            type,\n            messageType,\n            content: messageType === 'text' ? this.deduplicateContent(content) : content,\n            metadata: data.metadata || {\n                timestamp: new Date(),\n                source: 'n8n-webhook',\n                originalResponse: data\n            }\n        };\n    }\n    /**\n   * Cancel ongoing request\n   */ cancel() {\n        if (this.abortController) {\n            this.abortController.abort();\n            this.abortController = null;\n        }\n    }\n    /**\n   * Health check endpoint\n   */ async healthCheck() {\n        try {\n            const response = await fetch(\"\".concat(this.config.webhookUrl, \"/health\"), {\n                method: 'GET',\n                signal: AbortSignal.timeout(5000)\n            });\n            return response.ok;\n        } catch (e) {\n            return false;\n        }\n    }\n    constructor(config){\n        this.abortController = null;\n        this.config = {\n            timeout: 120000,\n            retryAttempts: 3,\n            retryDelay: 1000,\n            ...config\n        };\n    }\n}\n// Factory function for creating client instances\nfunction createN8NClient(config) {\n    return new N8NClient(config);\n}\n// Example usage\nconst n8nClientExample = ()=>{\n    const client = createN8NClient({\n        webhookUrl: process.env.N8N_WEBHOOK_URL,\n        streamingUrl: process.env.N8N_STREAMING_URL,\n        timeout: 30000,\n        retryAttempts: 3,\n        retryDelay: 1000\n    });\n    // Example: Send message\n    const sendMessage = async ()=>{\n        try {\n            const request = {\n                username: 'user123',\n                message: 'Hello, can you analyze this data?',\n                sessionId: 'session-123',\n                timestamp: new Date()\n            };\n            const response = await client.sendMessageWithRetry(request);\n            console.log('Response:', response);\n        } catch (error) {\n            if (error instanceof N8NError) {\n                console.error('N8N Error:', error.message, error.type);\n            } else {\n                console.error('Unexpected error:', error);\n            }\n        }\n    };\n    // Example: Stream messages\n    const streamMessages = async ()=>{\n        try {\n            const sessionId = 'session-123';\n            for await (const response of client.streamMessages(sessionId)){\n                console.log('Streaming response:', response);\n                if (response.type === 'final') {\n                    break;\n                }\n            }\n        } catch (error) {\n            console.error('Streaming error:', error);\n        }\n    };\n    return {\n        sendMessage,\n        streamMessages\n    };\n};\n// Utility functions for common operations\nconst n8nUtils = {\n    /**\n   * Format error for user display\n   */ formatError (error) {\n        switch(error.type){\n            case 'network':\n                return 'Network connection failed. Please check your internet connection.';\n            case 'timeout':\n                return 'Request timed out. The workflow may be taking longer than expected.';\n            case 'server':\n                return 'Server error occurred. Please try again later.';\n            case 'validation':\n                return 'Invalid data format. Please contact support.';\n            default:\n                return 'An unexpected error occurred. Please try again.';\n        }\n    },\n    /**\n   * Check if response is interim message\n   */ isInterimMessage (response) {\n        return response.type === 'interim';\n    },\n    /**\n   * Check if response is final message\n   */ isFinalMessage (response) {\n        return response.type === 'final';\n    },\n    /**\n   * Extract processing time from metadata\n   */ getProcessingTime (response) {\n        var _response_metadata;\n        return ((_response_metadata = response.metadata) === null || _response_metadata === void 0 ? void 0 : _response_metadata.processingTime) || null;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9uOG4tY2xpZW50LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQUlNLE1BQU1BLGlCQUFpQkM7SUFDNUIsWUFDRUMsT0FBZSxFQUNmLElBQTRELEVBQzVELE9BQW9CLENBQ3BCO1FBQ0EsS0FBSyxDQUFDQSxlQUhDQyxPQUFBQSxXQUNBQyxVQUFBQTtRQUdQLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQVVPLE1BQU1DO0lBYVg7O0dBRUMsR0FDRCxNQUFNQyxZQUFZQyxPQUFtQixFQUF3QjtRQUMzRCxNQUFNLEVBQUVDLFVBQVUsRUFBRUMsT0FBTyxFQUFFLEdBQUcsSUFBSSxDQUFDQyxNQUFNO1FBRTNDLElBQUk7WUFDRkMsUUFBUUMsR0FBRyxDQUFDO1lBQ1pELFFBQVFDLEdBQUcsQ0FBQyxnQkFBZ0JKO1lBQzVCRyxRQUFRQyxHQUFHLENBQUMsb0JBQW9CQyxLQUFLQyxTQUFTLENBQUNQLFNBQVMsTUFBTTtZQUU5RCxNQUFNUSxXQUFXLE1BQU1DLE1BQU1SLFlBQVk7Z0JBQ3ZDUyxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsVUFBVTtnQkFDWjtnQkFDQUMsTUFBTU4sS0FBS0MsU0FBUyxDQUFDUDtnQkFDckJhLFFBQVFDLFlBQVlaLE9BQU8sQ0FBQ0E7WUFDOUI7WUFFQUUsUUFBUUMsR0FBRyxDQUFDLG9CQUFvQkcsU0FBU08sTUFBTTtZQUMvQ1gsUUFBUUMsR0FBRyxDQUFDLHFCQUFxQlcsT0FBT0MsV0FBVyxDQUFDVCxTQUFTRyxPQUFPLENBQUNPLE9BQU87WUFFNUUsSUFBSSxDQUFDVixTQUFTVyxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTVosU0FBU2EsSUFBSTtnQkFDckNqQixRQUFRa0IsS0FBSyxDQUFDLHdCQUF3QkY7Z0JBQ3RDLE1BQU0sSUFBSTVCLFNBQ1IsUUFBNEJnQixPQUFwQkEsU0FBU08sTUFBTSxFQUFDLE1BQXdCLE9BQXBCUCxTQUFTZSxVQUFVLEdBQy9DLFVBQ0E7b0JBQUVSLFFBQVFQLFNBQVNPLE1BQU07b0JBQUVRLFlBQVlmLFNBQVNlLFVBQVU7b0JBQUVYLE1BQU1RO2dCQUFVO1lBRWhGO1lBRUEsTUFBTUksZUFBZSxNQUFNaEIsU0FBU2EsSUFBSTtZQUN4Q2pCLFFBQVFDLEdBQUcsQ0FBQyxpQkFBaUJtQjtZQUU3QixJQUFJQztZQUNKLElBQUk7Z0JBQ0ZBLE9BQU9uQixLQUFLb0IsS0FBSyxDQUFDRjtZQUNwQixFQUFFLE9BQU9HLFlBQVk7Z0JBQ25CdkIsUUFBUUMsR0FBRyxDQUFDO2dCQUNab0IsT0FBT0Q7WUFDVDtZQUVBcEIsUUFBUUMsR0FBRyxDQUFDLHlCQUF5Qm9CO1lBQ3JDLE1BQU1HLG9CQUFvQixJQUFJLENBQUNDLGdCQUFnQixDQUFDSjtZQUNoRHJCLFFBQVFDLEdBQUcsQ0FBQyx1QkFBdUJ1QjtZQUNuQ3hCLFFBQVFDLEdBQUcsQ0FBQztZQUVaLE9BQU91QjtRQUNULEVBQUUsT0FBT04sT0FBTztZQUNkbEIsUUFBUWtCLEtBQUssQ0FBQztZQUNkbEIsUUFBUWtCLEtBQUssQ0FBQyxrQkFBa0JBO1lBQ2hDbEIsUUFBUWtCLEtBQUssQ0FBQyxlQUFlQSxpQkFBaUI3QixRQUFRNkIsTUFBTSxXQUFXLENBQUN6QixJQUFJLEdBQUcsT0FBT3lCO1lBQ3RGbEIsUUFBUWtCLEtBQUssQ0FBQyxrQkFBa0JBLGlCQUFpQjdCLFFBQVE2QixNQUFNNUIsT0FBTyxHQUFHb0MsT0FBT1I7WUFDaEZsQixRQUFRa0IsS0FBSyxDQUFDO1lBRWQsSUFBSUEsaUJBQWlCN0IsT0FBTztnQkFDMUIsSUFBSTZCLE1BQU16QixJQUFJLEtBQUssa0JBQWtCeUIsTUFBTXpCLElBQUksS0FBSyxjQUFjO29CQUNoRSxNQUFNLElBQUlMLFNBQVMsbUJBQW1CO2dCQUN4QztnQkFFQSxJQUFJOEIsTUFBTTVCLE9BQU8sQ0FBQ3FDLFFBQVEsQ0FBQyxZQUFZVCxNQUFNNUIsT0FBTyxDQUFDcUMsUUFBUSxDQUFDLFlBQVk7b0JBQ3hFLE1BQU0sSUFBSXZDLFNBQVMsaUJBQWlCLFdBQVc4QjtnQkFDakQ7WUFDRjtZQUVBLE1BQU1BO1FBQ1I7SUFDRjtJQUVBOztHQUVDLEdBQ0QsT0FBT1UsZUFBZUMsU0FBaUIsRUFBOEM7UUFDbkYsTUFBTSxFQUFFQyxZQUFZLEVBQUUsR0FBRyxJQUFJLENBQUMvQixNQUFNO1FBQ3BDLE1BQU1nQyxNQUFNLElBQUlDLElBQUlGO1FBQ3BCQyxJQUFJRSxZQUFZLENBQUNDLEdBQUcsQ0FBQyxhQUFhTDtRQUVsQyxJQUFJO2dCQWdCYXpCO1lBZmYsTUFBTUEsV0FBVyxNQUFNQyxNQUFNMEIsSUFBSUksUUFBUSxJQUFJO2dCQUMzQzVCLFNBQVM7b0JBQ1AsVUFBVTtvQkFDVixpQkFBaUI7Z0JBQ25CO1lBQ0Y7WUFFQSxJQUFJLENBQUNILFNBQVNXLEVBQUUsRUFBRTtnQkFDaEIsTUFBTSxJQUFJM0IsU0FDUixxQkFBcUMsT0FBaEJnQixTQUFTTyxNQUFNLEdBQ3BDLFVBQ0E7b0JBQUVBLFFBQVFQLFNBQVNPLE1BQU07Z0JBQUM7WUFFOUI7WUFFQSxNQUFNeUIsVUFBU2hDLGlCQUFBQSxTQUFTSSxJQUFJLGNBQWJKLHFDQUFBQSxlQUFlaUMsU0FBUztZQUN2QyxJQUFJLENBQUNELFFBQVE7Z0JBQ1gsTUFBTSxJQUFJaEQsU0FBUyxvQkFBb0I7WUFDekM7WUFFQSxNQUFNa0QsVUFBVSxJQUFJQztZQUNwQixJQUFJQyxTQUFTO1lBRWIsSUFBSTtnQkFDRixNQUFPLEtBQU07b0JBQ1gsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1OLE9BQU9PLElBQUk7b0JBRXpDLElBQUlGLE1BQU07b0JBRVZELFVBQVVGLFFBQVFNLE1BQU0sQ0FBQ0YsT0FBTzt3QkFBRUcsUUFBUTtvQkFBSztvQkFDL0MsTUFBTUMsUUFBUU4sT0FBT08sS0FBSyxDQUFDO29CQUUzQiwwQ0FBMEM7b0JBQzFDUCxTQUFTTSxNQUFNRSxHQUFHLE1BQU07b0JBRXhCLEtBQUssTUFBTUMsUUFBUUgsTUFBTzt3QkFDeEIsSUFBSUcsS0FBS0MsSUFBSSxPQUFPLElBQUk7d0JBRXhCLElBQUlELEtBQUtFLFVBQVUsQ0FBQyxXQUFXOzRCQUM3QixNQUFNOUIsT0FBTzRCLEtBQUtHLEtBQUssQ0FBQzs0QkFFeEIsSUFBSS9CLFNBQVMsVUFBVTtnQ0FDckI7NEJBQ0Y7NEJBRUEsSUFBSTtnQ0FDRixNQUFNZ0MsU0FBU25ELEtBQUtvQixLQUFLLENBQUNEO2dDQUMxQixNQUFNakIsV0FBVyxJQUFJLENBQUNxQixnQkFBZ0IsQ0FBQzRCO2dDQUN2QyxNQUFNakQ7NEJBQ1IsRUFBRSxPQUFPYyxPQUFPO2dDQUNkbEIsUUFBUXNELElBQUksQ0FBQyxtQ0FBbUNwQzs0QkFDbEQ7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7WUFDRixTQUFVO2dCQUNSa0IsT0FBT21CLFdBQVc7WUFDcEI7UUFDRixFQUFFLE9BQU9yQyxPQUFPO1lBQ2QsSUFBSUEsaUJBQWlCOUIsVUFBVTtnQkFDN0IsTUFBTThCO1lBQ1I7WUFFQSxNQUFNLElBQUk5QixTQUNSLCtCQUNBLFdBQ0E4QjtRQUVKO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE1BQU1zQyxxQkFBcUI1RCxPQUFtQixFQUF3QjtRQUNwRSxNQUFNLEVBQUU2RCxhQUFhLEVBQUVDLFVBQVUsRUFBRSxHQUFHLElBQUksQ0FBQzNELE1BQU07UUFFakQsSUFBSyxJQUFJNEQsVUFBVSxHQUFHQSxXQUFXRixlQUFlRSxVQUFXO1lBQ3pELElBQUk7Z0JBQ0YsT0FBTyxNQUFNLElBQUksQ0FBQ2hFLFdBQVcsQ0FBQ0M7WUFDaEMsRUFBRSxPQUFPc0IsT0FBTztnQkFDZCxJQUFJQSxpQkFBaUI5QixVQUFVO29CQUM3QixnQ0FBZ0M7b0JBQ2hDLElBQUk4QixNQUFNM0IsSUFBSSxLQUFLLGNBQWM7d0JBQy9CLE1BQU0yQjtvQkFDUjtvQkFFQSwrQkFBK0I7b0JBQy9CLElBQUl5QyxZQUFZRixlQUFlO3dCQUM3QixNQUFNdkM7b0JBQ1I7b0JBRUEsb0JBQW9CO29CQUNwQixNQUFNLElBQUkwQyxRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTSCxhQUFhQztnQkFDaEUsT0FBTztvQkFDTCxNQUFNekM7Z0JBQ1I7WUFDRjtRQUNGO1FBRUEsTUFBTSxJQUFJOUIsU0FBUyw4QkFBOEI7SUFDbkQ7SUFFQTs7R0FFQyxHQUNELG1CQUEyQjRFLE9BQWUsRUFBVTtRQUNsRCxJQUFJLE9BQU9BLFlBQVksVUFBVTtZQUMvQixPQUFPQTtRQUNUO1FBRUEsMkJBQTJCO1FBQzNCLE1BQU1sQixRQUFRa0IsUUFBUWpCLEtBQUssQ0FBQztRQUM1QixNQUFNa0IsWUFBWSxJQUFJQztRQUN0QixNQUFNQyxvQkFBOEIsRUFBRTtRQUV0QyxLQUFLLE1BQU1sQixRQUFRSCxNQUFPO1lBQ3hCLE1BQU1zQixjQUFjbkIsS0FBS0MsSUFBSTtZQUU3QiwyQ0FBMkM7WUFDM0MsSUFBSWtCLGdCQUFnQixJQUFJO2dCQUN0QkQsa0JBQWtCRSxJQUFJLENBQUNwQjtnQkFDdkI7WUFDRjtZQUVBLDhDQUE4QztZQUM5QyxJQUFJLENBQUNnQixVQUFVSyxHQUFHLENBQUNGLGNBQWM7Z0JBQy9CSCxVQUFVTSxHQUFHLENBQUNIO2dCQUNkRCxrQkFBa0JFLElBQUksQ0FBQ3BCO1lBQ3pCO1FBQ0Y7UUFFQSxPQUFPa0Isa0JBQWtCSyxJQUFJLENBQUM7SUFDaEM7SUFFQTs7R0FFQyxHQUNELGVBQXVCUixPQUFZLEVBQVc7UUFDNUMsSUFBSSxDQUFDVSxNQUFNQyxPQUFPLENBQUNYLFVBQVUsT0FBTztRQUVwQyxPQUFPQSxRQUFRWSxJQUFJLENBQUNDLENBQUFBO1lBQ2xCLElBQUksQ0FBQ0EsUUFBUSxPQUFPQSxTQUFTLFVBQVUsT0FBTztZQUU5QyxNQUFNQyxPQUFPbEUsT0FBT2tFLElBQUksQ0FBQ0Q7WUFDekIsTUFBTUUsVUFBVUQsS0FBS0YsSUFBSSxDQUFDSSxDQUFBQSxNQUFPQSxJQUFJN0IsVUFBVSxDQUFDO1lBQ2hELE1BQU04QixXQUFXSCxLQUFLRixJQUFJLENBQUNJLENBQUFBLE1BQU9BLElBQUk3QixVQUFVLENBQUM7WUFFakQsT0FBTzRCLFdBQVdFO1FBQ3BCO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELGlCQUF5QjVELElBQVMsRUFBZTtRQUMvQyxJQUFJLENBQUNBLFFBQVEsT0FBT0EsU0FBUyxVQUFVO1lBQ3JDLDhEQUE4RDtZQUM5RCxPQUFPO2dCQUNMOUIsTUFBTTtnQkFDTjJGLGFBQWE7Z0JBQ2JsQixTQUFTdEMsT0FBT0w7Z0JBQ2hCOEQsVUFBVTtvQkFBRUMsV0FBVyxJQUFJQztnQkFBTztZQUNwQztRQUNGO1FBRUEsb0RBQW9EO1FBQ3BELElBQUloRSxLQUFLOUIsSUFBSSxJQUFJOEIsS0FBSzZELFdBQVcsSUFBSTdELEtBQUsyQyxPQUFPLEtBQUtzQixXQUFXO1lBQy9ELE9BQU87Z0JBQ0wvRixNQUFNOEIsS0FBSzlCLElBQUk7Z0JBQ2YyRixhQUFhN0QsS0FBSzZELFdBQVc7Z0JBQzdCbEIsU0FBUzNDLEtBQUs2RCxXQUFXLEtBQUssU0FBUyxJQUFJLENBQUNuQixrQkFBa0IsQ0FBQzFDLEtBQUsyQyxPQUFPLElBQUkzQyxLQUFLMkMsT0FBTztnQkFDM0ZtQixVQUFVOUQsS0FBSzhELFFBQVEsSUFBSTtvQkFBRUMsV0FBVyxJQUFJQztnQkFBTztZQUNyRDtRQUNGO1FBRUEsK0NBQStDO1FBQy9DLElBQUlyQixVQUFVM0MsS0FBSzJDLE9BQU8sSUFBSTNDLEtBQUsvQixPQUFPLElBQUkrQixLQUFLakIsUUFBUSxJQUFJaUIsS0FBS0osSUFBSSxJQUFJSSxLQUFLa0UsTUFBTSxJQUFJbEU7UUFDM0YsSUFBSTZELGNBQWM3RCxLQUFLNkQsV0FBVyxJQUFJN0QsS0FBS21FLE1BQU0sSUFBSTtRQUNyRCxJQUFJakcsT0FBTzhCLEtBQUs5QixJQUFJLElBQUk7UUFFeEIsa0VBQWtFO1FBQ2xFLElBQUk4QixLQUFLa0UsTUFBTSxJQUFJLE9BQU9sRSxLQUFLa0UsTUFBTSxLQUFLLFVBQVU7WUFDbEQsSUFBSTtnQkFDRixNQUFNRSxlQUFldkYsS0FBS29CLEtBQUssQ0FBQ0QsS0FBS2tFLE1BQU07Z0JBQzNDLElBQUlFLGdCQUFnQixPQUFPQSxpQkFBaUIsVUFBVTtvQkFDcEQsaUVBQWlFO29CQUNqRXpCLFVBQVV5QixhQUFhekIsT0FBTyxJQUFJeUI7b0JBQ2xDUCxjQUFjTyxhQUFhUCxXQUFXLElBQUlBO29CQUMxQzNGLE9BQU9rRyxhQUFhbEcsSUFBSSxJQUFJQTtnQkFDOUI7WUFDRixFQUFFLE9BQU8yQixPQUFPO2dCQUNkLHlEQUF5RDtnQkFDekRsQixRQUFRc0QsSUFBSSxDQUFDLHVDQUF1Q3BDO1lBQ3REO1FBQ0Y7UUFFQSxpRkFBaUY7UUFDakYsSUFBSSxJQUFJLENBQUN1RCxjQUFjLENBQUNULFVBQVU7WUFDaENrQixjQUFjO1FBQ2hCLE9BQU8sSUFBSVIsTUFBTUMsT0FBTyxDQUFDWCxVQUFVO1lBQ2pDLHdEQUF3RDtZQUN4RGtCLGNBQWM7UUFDaEI7UUFFQSx1QkFBdUI7UUFDdkIsSUFBSSxDQUFDO1lBQUM7WUFBUTtZQUFRO1lBQVM7WUFBUztZQUFTO1NBQVEsQ0FBQ3ZELFFBQVEsQ0FBQ3VELGNBQWM7WUFDL0VBLGNBQWM7UUFDaEI7UUFFQSxnQkFBZ0I7UUFDaEIsSUFBSSxDQUFDO1lBQUM7WUFBVztTQUFRLENBQUN2RCxRQUFRLENBQUNwQyxPQUFPO1lBQ3hDQSxPQUFPO1FBQ1Q7UUFFQSxPQUFPO1lBQ0xBO1lBQ0EyRjtZQUNBbEIsU0FBU2tCLGdCQUFnQixTQUFTLElBQUksQ0FBQ25CLGtCQUFrQixDQUFDQyxXQUFXQTtZQUNyRW1CLFVBQVU5RCxLQUFLOEQsUUFBUSxJQUFJO2dCQUN6QkMsV0FBVyxJQUFJQztnQkFDZkssUUFBUTtnQkFDUkMsa0JBQWtCdEU7WUFDcEI7UUFDRjtJQUNGO0lBRUE7O0dBRUMsR0FDRHVFLFNBQWU7UUFDYixJQUFJLElBQUksQ0FBQ0MsZUFBZSxFQUFFO1lBQ3hCLElBQUksQ0FBQ0EsZUFBZSxDQUFDQyxLQUFLO1lBQzFCLElBQUksQ0FBQ0QsZUFBZSxHQUFHO1FBQ3pCO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE1BQU1FLGNBQWdDO1FBQ3BDLElBQUk7WUFDRixNQUFNM0YsV0FBVyxNQUFNQyxNQUFNLEdBQTBCLE9BQXZCLElBQUksQ0FBQ04sTUFBTSxDQUFDRixVQUFVLEVBQUMsWUFBVTtnQkFDL0RTLFFBQVE7Z0JBQ1JHLFFBQVFDLFlBQVlaLE9BQU8sQ0FBQztZQUM5QjtZQUVBLE9BQU9NLFNBQVNXLEVBQUU7UUFDcEIsRUFBRSxVQUFNO1lBQ04sT0FBTztRQUNUO0lBQ0Y7SUFyVkEsWUFBWWhCLE1BQXVCLENBQUU7YUFGN0I4RixrQkFBMEM7UUFHaEQsSUFBSSxDQUFDOUYsTUFBTSxHQUFHO1lBQ1pELFNBQVM7WUFDVDJELGVBQWU7WUFDZkMsWUFBWTtZQUNaLEdBQUczRCxNQUFNO1FBQ1g7SUFDRjtBQStVRjtBQUVBLGlEQUFpRDtBQUMxQyxTQUFTaUcsZ0JBQWdCakcsTUFBdUI7SUFDckQsT0FBTyxJQUFJTCxVQUFVSztBQUN2QjtBQUVBLGdCQUFnQjtBQUNULE1BQU1rRyxtQkFBbUI7SUFDOUIsTUFBTUMsU0FBU0YsZ0JBQWdCO1FBQzdCbkcsWUFBWXNHLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsZUFBZTtRQUN2Q3ZFLGNBQWNxRSxPQUFPQSxDQUFDQyxHQUFHLENBQUNFLGlCQUFpQjtRQUMzQ3hHLFNBQVM7UUFDVDJELGVBQWU7UUFDZkMsWUFBWTtJQUNkO0lBRUEsd0JBQXdCO0lBQ3hCLE1BQU0vRCxjQUFjO1FBQ2xCLElBQUk7WUFDRixNQUFNQyxVQUFzQjtnQkFDMUIyRyxVQUFVO2dCQUNWakgsU0FBUztnQkFDVHVDLFdBQVc7Z0JBQ1h1RCxXQUFXLElBQUlDO1lBQ2pCO1lBRUEsTUFBTWpGLFdBQVcsTUFBTThGLE9BQU8xQyxvQkFBb0IsQ0FBQzVEO1lBQ25ESSxRQUFRQyxHQUFHLENBQUMsYUFBYUc7UUFDM0IsRUFBRSxPQUFPYyxPQUFPO1lBQ2QsSUFBSUEsaUJBQWlCOUIsVUFBVTtnQkFDN0JZLFFBQVFrQixLQUFLLENBQUMsY0FBY0EsTUFBTTVCLE9BQU8sRUFBRTRCLE1BQU0zQixJQUFJO1lBQ3ZELE9BQU87Z0JBQ0xTLFFBQVFrQixLQUFLLENBQUMscUJBQXFCQTtZQUNyQztRQUNGO0lBQ0Y7SUFFQSwyQkFBMkI7SUFDM0IsTUFBTVUsaUJBQWlCO1FBQ3JCLElBQUk7WUFDRixNQUFNQyxZQUFZO1lBRWxCLFdBQVcsTUFBTXpCLFlBQVk4RixPQUFPdEUsY0FBYyxDQUFDQyxXQUFZO2dCQUM3RDdCLFFBQVFDLEdBQUcsQ0FBQyx1QkFBdUJHO2dCQUVuQyxJQUFJQSxTQUFTYixJQUFJLEtBQUssU0FBUztvQkFDN0I7Z0JBQ0Y7WUFDRjtRQUNGLEVBQUUsT0FBTzJCLE9BQU87WUFDZGxCLFFBQVFrQixLQUFLLENBQUMsb0JBQW9CQTtRQUNwQztJQUNGO0lBRUEsT0FBTztRQUFFdkI7UUFBYWlDO0lBQWU7QUFDdkMsRUFBRTtBQUVGLDBDQUEwQztBQUNuQyxNQUFNNEUsV0FBVztJQUN0Qjs7R0FFQyxHQUNEQyxhQUFZdkYsS0FBZTtRQUN6QixPQUFRQSxNQUFNM0IsSUFBSTtZQUNoQixLQUFLO2dCQUNILE9BQU87WUFDVCxLQUFLO2dCQUNILE9BQU87WUFDVCxLQUFLO2dCQUNILE9BQU87WUFDVCxLQUFLO2dCQUNILE9BQU87WUFDVDtnQkFDRSxPQUFPO1FBQ1g7SUFDRjtJQUVBOztHQUVDLEdBQ0RtSCxrQkFBaUJ0RyxRQUFxQjtRQUNwQyxPQUFPQSxTQUFTYixJQUFJLEtBQUs7SUFDM0I7SUFFQTs7R0FFQyxHQUNEb0gsZ0JBQWV2RyxRQUFxQjtRQUNsQyxPQUFPQSxTQUFTYixJQUFJLEtBQUs7SUFDM0I7SUFFQTs7R0FFQyxHQUNEcUgsbUJBQWtCeEcsUUFBcUI7WUFDOUJBO1FBQVAsT0FBT0EsRUFBQUEscUJBQUFBLFNBQVMrRSxRQUFRLGNBQWpCL0UseUNBQUFBLG1CQUFtQnlHLGNBQWMsS0FBSTtJQUM5QztBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxFYnR0aWthciBJbnRlbGxpZ2VuY2UgUHJvamVjdHNcXFRlc3QtQ2hhdC1BcHBcXGxpYlxcbjhuLWNsaWVudC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIG44biBXZWJob29rIENsaWVudFxuICogSGFuZGxlcyBjb21tdW5pY2F0aW9uIHdpdGggbjhuIHdvcmtmbG93cyB2aWEgd2ViaG9vayBhbmQgc3RyZWFtaW5nIGVuZHBvaW50c1xuICovXG5cbmltcG9ydCB7IE44TlJlcXVlc3QsIE44TlJlc3BvbnNlLCBDaGF0RXJyb3IgfSBmcm9tICdAL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIE44TkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgcHVibGljIHR5cGU6ICduZXR3b3JrJyB8ICd0aW1lb3V0JyB8ICdzZXJ2ZXInIHwgJ3ZhbGlkYXRpb24nLFxuICAgIHB1YmxpYyBkZXRhaWxzPzogYW55XG4gICkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdOOE5FcnJvcic7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBOOE5DbGllbnRDb25maWcge1xuICB3ZWJob29rVXJsOiBzdHJpbmc7XG4gIHN0cmVhbWluZ1VybDogc3RyaW5nO1xuICB0aW1lb3V0PzogbnVtYmVyO1xuICByZXRyeUF0dGVtcHRzPzogbnVtYmVyO1xuICByZXRyeURlbGF5PzogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgTjhOQ2xpZW50IHtcbiAgcHJpdmF0ZSBjb25maWc6IFJlcXVpcmVkPE44TkNsaWVudENvbmZpZz47XG4gIHByaXZhdGUgYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IE44TkNsaWVudENvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgdGltZW91dDogMTIwMDAwLCAvLyBJbmNyZWFzZWQgdG8gMiBtaW51dGVzIGZvciBBSSBwcm9jZXNzaW5nXG4gICAgICByZXRyeUF0dGVtcHRzOiAzLFxuICAgICAgcmV0cnlEZWxheTogMTAwMCxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIG1lc3NhZ2UgdG8gbjhuIHdlYmhvb2tcbiAgICovXG4gIGFzeW5jIHNlbmRNZXNzYWdlKHJlcXVlc3Q6IE44TlJlcXVlc3QpOiBQcm9taXNlPE44TlJlc3BvbnNlPiB7XG4gICAgY29uc3QgeyB3ZWJob29rVXJsLCB0aW1lb3V0IH0gPSB0aGlzLmNvbmZpZztcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJz09PSBOOE4gV0VCSE9PSyBERUJVRyA9PT0nKTtcbiAgICAgIGNvbnNvbGUubG9nKCdXZWJob29rIFVSTDonLCB3ZWJob29rVXJsKTtcbiAgICAgIGNvbnNvbGUubG9nKCdSZXF1ZXN0IHBheWxvYWQ6JywgSlNPTi5zdHJpbmdpZnkocmVxdWVzdCwgbnVsbCwgMikpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHdlYmhvb2tVcmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLFxuICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGltZW91dCksXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coJ1Jlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgY29uc29sZS5sb2coJ1Jlc3BvbnNlIGhlYWRlcnM6JywgT2JqZWN0LmZyb21FbnRyaWVzKHJlc3BvbnNlLmhlYWRlcnMuZW50cmllcygpKSk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXNwb25zZSBib2R5OicsIGVycm9yVGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBOOE5FcnJvcihcbiAgICAgICAgICBgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gLFxuICAgICAgICAgICdzZXJ2ZXInLFxuICAgICAgICAgIHsgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsIGJvZHk6IGVycm9yVGV4dCB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIGNvbnNvbGUubG9nKCdSYXcgcmVzcG9uc2U6JywgcmVzcG9uc2VUZXh0KTtcbiAgICAgIFxuICAgICAgbGV0IGRhdGE7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpO1xuICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZygnUmVzcG9uc2UgaXMgbm90IEpTT04sIHRyZWF0aW5nIGFzIHBsYWluIHRleHQnKTtcbiAgICAgICAgZGF0YSA9IHJlc3BvbnNlVGV4dDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1BhcnNlZCByZXNwb25zZSBkYXRhOicsIGRhdGEpO1xuICAgICAgY29uc3QgdmFsaWRhdGVkUmVzcG9uc2UgPSB0aGlzLnZhbGlkYXRlUmVzcG9uc2UoZGF0YSk7XG4gICAgICBjb25zb2xlLmxvZygnVmFsaWRhdGVkIHJlc3BvbnNlOicsIHZhbGlkYXRlZFJlc3BvbnNlKTtcbiAgICAgIGNvbnNvbGUubG9nKCc9PT0gRU5EIE44TiBXRUJIT09LIERFQlVHID09PScpO1xuICAgICAgXG4gICAgICByZXR1cm4gdmFsaWRhdGVkUmVzcG9uc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJz09PSBOOE4gV0VCSE9PSyBFUlJPUiA9PT0nKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGFpbHM6JywgZXJyb3IpO1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdHlwZTonLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IuY29uc3RydWN0b3IubmFtZSA6IHR5cGVvZiBlcnJvcik7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBtZXNzYWdlOicsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSk7XG4gICAgICBjb25zb2xlLmVycm9yKCc9PT0gRU5EIE44TiBXRUJIT09LIEVSUk9SID09PScpO1xuICAgICAgXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ1RpbWVvdXRFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE44TkVycm9yKCdSZXF1ZXN0IHRpbWVvdXQnLCAndGltZW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZmV0Y2gnKSB8fCBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCduZXR3b3JrJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTjhORXJyb3IoJ05ldHdvcmsgZXJyb3InLCAnbmV0d29yaycsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIHN0cmVhbWluZyBjb25uZWN0aW9uIGZvciByZWFsLXRpbWUgdXBkYXRlc1xuICAgKi9cbiAgYXN5bmMgKnN0cmVhbU1lc3NhZ2VzKHNlc3Npb25JZDogc3RyaW5nKTogQXN5bmNHZW5lcmF0b3I8TjhOUmVzcG9uc2UsIHZvaWQsIHVua25vd24+IHtcbiAgICBjb25zdCB7IHN0cmVhbWluZ1VybCB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChzdHJlYW1pbmdVcmwpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdzZXNzaW9uSWQnLCBzZXNzaW9uSWQpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLnRvU3RyaW5nKCksIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBY2NlcHQnOiAndGV4dC9ldmVudC1zdHJlYW0nLFxuICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBOOE5FcnJvcihcbiAgICAgICAgICBgU3RyZWFtaW5nIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9YCxcbiAgICAgICAgICAnc2VydmVyJyxcbiAgICAgICAgICB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzIH1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keT8uZ2V0UmVhZGVyKCk7XG4gICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgTjhORXJyb3IoJ05vIHJlc3BvbnNlIGJvZHknLCAnc2VydmVyJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgIGxldCBidWZmZXIgPSAnJztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgICAgICBcbiAgICAgICAgICBidWZmZXIgKz0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgIGNvbnN0IGxpbmVzID0gYnVmZmVyLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBLZWVwIHRoZSBsYXN0IGluY29tcGxldGUgbGluZSBpbiBidWZmZXJcbiAgICAgICAgICBidWZmZXIgPSBsaW5lcy5wb3AoKSB8fCAnJztcbiAgICAgICAgICBcbiAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICAgIGlmIChsaW5lLnRyaW0oKSA9PT0gJycpIGNvbnRpbnVlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKCdkYXRhOiAnKSkge1xuICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbGluZS5zbGljZSg2KTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChkYXRhID09PSAnW0RPTkVdJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy52YWxpZGF0ZVJlc3BvbnNlKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgeWllbGQgcmVzcG9uc2U7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtaW5nIGRhdGE6JywgZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgTjhORXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IG5ldyBOOE5FcnJvcihcbiAgICAgICAgJ1N0cmVhbWluZyBjb25uZWN0aW9uIGZhaWxlZCcsXG4gICAgICAgICduZXR3b3JrJyxcbiAgICAgICAgZXJyb3JcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgbWVzc2FnZSB3aXRoIHJldHJ5IGxvZ2ljXG4gICAqL1xuICBhc3luYyBzZW5kTWVzc2FnZVdpdGhSZXRyeShyZXF1ZXN0OiBOOE5SZXF1ZXN0KTogUHJvbWlzZTxOOE5SZXNwb25zZT4ge1xuICAgIGNvbnN0IHsgcmV0cnlBdHRlbXB0cywgcmV0cnlEZWxheSB9ID0gdGhpcy5jb25maWc7XG4gICAgXG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gcmV0cnlBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kTWVzc2FnZShyZXF1ZXN0KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE44TkVycm9yKSB7XG4gICAgICAgICAgLy8gRG9uJ3QgcmV0cnkgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICAgICAgICBpZiAoZXJyb3IudHlwZSA9PT0gJ3ZhbGlkYXRpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRG9uJ3QgcmV0cnkgb24gZmluYWwgYXR0ZW1wdFxuICAgICAgICAgIGlmIChhdHRlbXB0ID09PSByZXRyeUF0dGVtcHRzKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gV2FpdCBiZWZvcmUgcmV0cnlcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheSAqIGF0dGVtcHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aHJvdyBuZXcgTjhORXJyb3IoJ01heCByZXRyeSBhdHRlbXB0cyByZWFjaGVkJywgJ25ldHdvcmsnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgZHVwbGljYXRlIGNvbnRlbnQgZnJvbSByZXNwb25zZVxuICAgKi9cbiAgcHJpdmF0ZSBkZWR1cGxpY2F0ZUNvbnRlbnQoY29udGVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG5cbiAgICAvLyBTcGxpdCBjb250ZW50IGludG8gbGluZXNcbiAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IHNlZW5MaW5lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IGRlZHVwbGljYXRlZExpbmVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgY29uc3QgdHJpbW1lZExpbmUgPSBsaW5lLnRyaW0oKTtcbiAgICAgIFxuICAgICAgLy8gU2tpcCBlbXB0eSBsaW5lcyBmb3IgZGVkdXBsaWNhdGlvbiBjaGVja1xuICAgICAgaWYgKHRyaW1tZWRMaW5lID09PSAnJykge1xuICAgICAgICBkZWR1cGxpY2F0ZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBzZWVuIHRoaXMgbGluZSBiZWZvcmUsIGFkZCBpdFxuICAgICAgaWYgKCFzZWVuTGluZXMuaGFzKHRyaW1tZWRMaW5lKSkge1xuICAgICAgICBzZWVuTGluZXMuYWRkKHRyaW1tZWRMaW5lKTtcbiAgICAgICAgZGVkdXBsaWNhdGVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGRlZHVwbGljYXRlZExpbmVzLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBjb250ZW50IGlzIG1peGVkIGZvcm1hdCAoY29udGFpbnMgdGV4dCBhbmQgY2hhcnQga2V5cylcbiAgICovXG4gIHByaXZhdGUgaXNNaXhlZENvbnRlbnQoY29udGVudDogYW55KTogYm9vbGVhbiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbnRlbnQpKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgcmV0dXJuIGNvbnRlbnQuc29tZShpdGVtID0+IHtcbiAgICAgIGlmICghaXRlbSB8fCB0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICAgIFxuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGl0ZW0pO1xuICAgICAgY29uc3QgaGFzVGV4dCA9IGtleXMuc29tZShrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ3RleHQnKSk7XG4gICAgICBjb25zdCBoYXNDaGFydCA9IGtleXMuc29tZShrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ2NoYXJ0JykpO1xuICAgICAgXG4gICAgICByZXR1cm4gaGFzVGV4dCB8fCBoYXNDaGFydDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBuOG4gcmVzcG9uc2UgZm9ybWF0XG4gICAqL1xuICBwcml2YXRlIHZhbGlkYXRlUmVzcG9uc2UoZGF0YTogYW55KTogTjhOUmVzcG9uc2Uge1xuICAgIGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIElmIHdlIGdldCBhIHNpbXBsZSByZXNwb25zZSwgd3JhcCBpdCBpbiBvdXIgZXhwZWN0ZWQgZm9ybWF0XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZmluYWwnLFxuICAgICAgICBtZXNzYWdlVHlwZTogJ3RleHQnLFxuICAgICAgICBjb250ZW50OiBTdHJpbmcoZGF0YSksXG4gICAgICAgIG1ldGFkYXRhOiB7IHRpbWVzdGFtcDogbmV3IERhdGUoKSB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHJlc3BvbnNlIGFscmVhZHkgaGFzIG91ciBleHBlY3RlZCBmb3JtYXRcbiAgICBpZiAoZGF0YS50eXBlICYmIGRhdGEubWVzc2FnZVR5cGUgJiYgZGF0YS5jb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGRhdGEudHlwZSxcbiAgICAgICAgbWVzc2FnZVR5cGU6IGRhdGEubWVzc2FnZVR5cGUsXG4gICAgICAgIGNvbnRlbnQ6IGRhdGEubWVzc2FnZVR5cGUgPT09ICd0ZXh0JyA/IHRoaXMuZGVkdXBsaWNhdGVDb250ZW50KGRhdGEuY29udGVudCkgOiBkYXRhLmNvbnRlbnQsXG4gICAgICAgIG1ldGFkYXRhOiBkYXRhLm1ldGFkYXRhIHx8IHsgdGltZXN0YW1wOiBuZXcgRGF0ZSgpIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHZhcmlvdXMgcG9zc2libGUgbjhuIHJlc3BvbnNlIGZvcm1hdHNcbiAgICBsZXQgY29udGVudCA9IGRhdGEuY29udGVudCB8fCBkYXRhLm1lc3NhZ2UgfHwgZGF0YS5yZXNwb25zZSB8fCBkYXRhLnRleHQgfHwgZGF0YS5vdXRwdXQgfHwgZGF0YTtcbiAgICBsZXQgbWVzc2FnZVR5cGUgPSBkYXRhLm1lc3NhZ2VUeXBlIHx8IGRhdGEuZm9ybWF0IHx8ICd0ZXh0JztcbiAgICBsZXQgdHlwZSA9IGRhdGEudHlwZSB8fCAnZmluYWwnO1xuICAgIFxuICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIG44biBvdXRwdXQgZmllbGQgdGhhdCBjb250YWlucyBKU09OIHN0cmluZ1xuICAgIGlmIChkYXRhLm91dHB1dCAmJiB0eXBlb2YgZGF0YS5vdXRwdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWRPdXRwdXQgPSBKU09OLnBhcnNlKGRhdGEub3V0cHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZE91dHB1dCAmJiB0eXBlb2YgcGFyc2VkT3V0cHV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIC8vIElmIHRoZSBvdXRwdXQgY29udGFpbnMgYSB2YWxpZCBKU09OIG9iamVjdCwgdXNlIGl0IGFzIHRoZSBiYXNlXG4gICAgICAgICAgY29udGVudCA9IHBhcnNlZE91dHB1dC5jb250ZW50IHx8IHBhcnNlZE91dHB1dDtcbiAgICAgICAgICBtZXNzYWdlVHlwZSA9IHBhcnNlZE91dHB1dC5tZXNzYWdlVHlwZSB8fCBtZXNzYWdlVHlwZTtcbiAgICAgICAgICB0eXBlID0gcGFyc2VkT3V0cHV0LnR5cGUgfHwgdHlwZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgcGFyc2luZyBmYWlscywgdHJlYXQgb3V0cHV0IGFzIHJlZ3VsYXIgdGV4dCBjb250ZW50XG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIG44biBvdXRwdXQgYXMgSlNPTjonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIG1peGVkIGNvbnRlbnQgcmVzcG9uc2UgKGFycmF5IHdpdGggdGV4dC9jaGFydCBjb21iaW5hdGlvbnMpXG4gICAgaWYgKHRoaXMuaXNNaXhlZENvbnRlbnQoY29udGVudCkpIHtcbiAgICAgIG1lc3NhZ2VUeXBlID0gJ21peGVkJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudCkpIHtcbiAgICAgIC8vIElmIGl0J3MgYW4gYXJyYXkgYnV0IG5vdCBtaXhlZCBjb250ZW50LCB0cmVhdCBhcyBKU09OXG4gICAgICBtZXNzYWdlVHlwZSA9ICdqc29uJztcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBtZXNzYWdlVHlwZVxuICAgIGlmICghWyd0ZXh0JywgJ2pzb24nLCAnaW1hZ2UnLCAnY2hhcnQnLCAnZXJyb3InLCAnbWl4ZWQnXS5pbmNsdWRlcyhtZXNzYWdlVHlwZSkpIHtcbiAgICAgIG1lc3NhZ2VUeXBlID0gJ3RleHQnO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHR5cGVcbiAgICBpZiAoIVsnaW50ZXJpbScsICdmaW5hbCddLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICB0eXBlID0gJ2ZpbmFsJztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZSxcbiAgICAgIG1lc3NhZ2VUeXBlLFxuICAgICAgY29udGVudDogbWVzc2FnZVR5cGUgPT09ICd0ZXh0JyA/IHRoaXMuZGVkdXBsaWNhdGVDb250ZW50KGNvbnRlbnQpIDogY29udGVudCxcbiAgICAgIG1ldGFkYXRhOiBkYXRhLm1ldGFkYXRhIHx8IHsgXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgc291cmNlOiAnbjhuLXdlYmhvb2snLFxuICAgICAgICBvcmlnaW5hbFJlc3BvbnNlOiBkYXRhXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgb25nb2luZyByZXF1ZXN0XG4gICAqL1xuICBjYW5jZWwoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWFsdGggY2hlY2sgZW5kcG9pbnRcbiAgICovXG4gIGFzeW5jIGhlYWx0aENoZWNrKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuY29uZmlnLndlYmhvb2tVcmx9L2hlYWx0aGAsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KDUwMDApLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiByZXNwb25zZS5vaztcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgY2xpZW50IGluc3RhbmNlc1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU44TkNsaWVudChjb25maWc6IE44TkNsaWVudENvbmZpZyk6IE44TkNsaWVudCB7XG4gIHJldHVybiBuZXcgTjhOQ2xpZW50KGNvbmZpZyk7XG59XG5cbi8vIEV4YW1wbGUgdXNhZ2VcbmV4cG9ydCBjb25zdCBuOG5DbGllbnRFeGFtcGxlID0gKCkgPT4ge1xuICBjb25zdCBjbGllbnQgPSBjcmVhdGVOOE5DbGllbnQoe1xuICAgIHdlYmhvb2tVcmw6IHByb2Nlc3MuZW52Lk44Tl9XRUJIT09LX1VSTCEsXG4gICAgc3RyZWFtaW5nVXJsOiBwcm9jZXNzLmVudi5OOE5fU1RSRUFNSU5HX1VSTCEsXG4gICAgdGltZW91dDogMzAwMDAsXG4gICAgcmV0cnlBdHRlbXB0czogMyxcbiAgICByZXRyeURlbGF5OiAxMDAwXG4gIH0pO1xuXG4gIC8vIEV4YW1wbGU6IFNlbmQgbWVzc2FnZVxuICBjb25zdCBzZW5kTWVzc2FnZSA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVxdWVzdDogTjhOUmVxdWVzdCA9IHtcbiAgICAgICAgdXNlcm5hbWU6ICd1c2VyMTIzJyxcbiAgICAgICAgbWVzc2FnZTogJ0hlbGxvLCBjYW4geW91IGFuYWx5emUgdGhpcyBkYXRhPycsXG4gICAgICAgIHNlc3Npb25JZDogJ3Nlc3Npb24tMTIzJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5zZW5kTWVzc2FnZVdpdGhSZXRyeShyZXF1ZXN0KTtcbiAgICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE44TkVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ044TiBFcnJvcjonLCBlcnJvci5tZXNzYWdlLCBlcnJvci50eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBFeGFtcGxlOiBTdHJlYW0gbWVzc2FnZXNcbiAgY29uc3Qgc3RyZWFtTWVzc2FnZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICdzZXNzaW9uLTEyMyc7XG4gICAgICBcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgcmVzcG9uc2Ugb2YgY2xpZW50LnN0cmVhbU1lc3NhZ2VzKHNlc3Npb25JZCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1N0cmVhbWluZyByZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ2ZpbmFsJykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1N0cmVhbWluZyBlcnJvcjonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7IHNlbmRNZXNzYWdlLCBzdHJlYW1NZXNzYWdlcyB9O1xufTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGNvbW1vbiBvcGVyYXRpb25zXG5leHBvcnQgY29uc3QgbjhuVXRpbHMgPSB7XG4gIC8qKlxuICAgKiBGb3JtYXQgZXJyb3IgZm9yIHVzZXIgZGlzcGxheVxuICAgKi9cbiAgZm9ybWF0RXJyb3IoZXJyb3I6IE44TkVycm9yKTogc3RyaW5nIHtcbiAgICBzd2l0Y2ggKGVycm9yLnR5cGUpIHtcbiAgICAgIGNhc2UgJ25ldHdvcmsnOlxuICAgICAgICByZXR1cm4gJ05ldHdvcmsgY29ubmVjdGlvbiBmYWlsZWQuIFBsZWFzZSBjaGVjayB5b3VyIGludGVybmV0IGNvbm5lY3Rpb24uJztcbiAgICAgIGNhc2UgJ3RpbWVvdXQnOlxuICAgICAgICByZXR1cm4gJ1JlcXVlc3QgdGltZWQgb3V0LiBUaGUgd29ya2Zsb3cgbWF5IGJlIHRha2luZyBsb25nZXIgdGhhbiBleHBlY3RlZC4nO1xuICAgICAgY2FzZSAnc2VydmVyJzpcbiAgICAgICAgcmV0dXJuICdTZXJ2ZXIgZXJyb3Igb2NjdXJyZWQuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJztcbiAgICAgIGNhc2UgJ3ZhbGlkYXRpb24nOlxuICAgICAgICByZXR1cm4gJ0ludmFsaWQgZGF0YSBmb3JtYXQuIFBsZWFzZSBjb250YWN0IHN1cHBvcnQuJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZC4gUGxlYXNlIHRyeSBhZ2Fpbi4nO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgcmVzcG9uc2UgaXMgaW50ZXJpbSBtZXNzYWdlXG4gICAqL1xuICBpc0ludGVyaW1NZXNzYWdlKHJlc3BvbnNlOiBOOE5SZXNwb25zZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiByZXNwb25zZS50eXBlID09PSAnaW50ZXJpbSc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHJlc3BvbnNlIGlzIGZpbmFsIG1lc3NhZ2VcbiAgICovXG4gIGlzRmluYWxNZXNzYWdlKHJlc3BvbnNlOiBOOE5SZXNwb25zZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiByZXNwb25zZS50eXBlID09PSAnZmluYWwnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHByb2Nlc3NpbmcgdGltZSBmcm9tIG1ldGFkYXRhXG4gICAqL1xuICBnZXRQcm9jZXNzaW5nVGltZShyZXNwb25zZTogTjhOUmVzcG9uc2UpOiBudW1iZXIgfCBudWxsIHtcbiAgICByZXR1cm4gcmVzcG9uc2UubWV0YWRhdGE/LnByb2Nlc3NpbmdUaW1lIHx8IG51bGw7XG4gIH1cbn07Il0sIm5hbWVzIjpbIk44TkVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwidHlwZSIsImRldGFpbHMiLCJuYW1lIiwiTjhOQ2xpZW50Iiwic2VuZE1lc3NhZ2UiLCJyZXF1ZXN0Iiwid2ViaG9va1VybCIsInRpbWVvdXQiLCJjb25maWciLCJjb25zb2xlIiwibG9nIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsInNpZ25hbCIsIkFib3J0U2lnbmFsIiwic3RhdHVzIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwib2siLCJlcnJvclRleHQiLCJ0ZXh0IiwiZXJyb3IiLCJzdGF0dXNUZXh0IiwicmVzcG9uc2VUZXh0IiwiZGF0YSIsInBhcnNlIiwicGFyc2VFcnJvciIsInZhbGlkYXRlZFJlc3BvbnNlIiwidmFsaWRhdGVSZXNwb25zZSIsIlN0cmluZyIsImluY2x1ZGVzIiwic3RyZWFtTWVzc2FnZXMiLCJzZXNzaW9uSWQiLCJzdHJlYW1pbmdVcmwiLCJ1cmwiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJzZXQiLCJ0b1N0cmluZyIsInJlYWRlciIsImdldFJlYWRlciIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsImJ1ZmZlciIsImRvbmUiLCJ2YWx1ZSIsInJlYWQiLCJkZWNvZGUiLCJzdHJlYW0iLCJsaW5lcyIsInNwbGl0IiwicG9wIiwibGluZSIsInRyaW0iLCJzdGFydHNXaXRoIiwic2xpY2UiLCJwYXJzZWQiLCJ3YXJuIiwicmVsZWFzZUxvY2siLCJzZW5kTWVzc2FnZVdpdGhSZXRyeSIsInJldHJ5QXR0ZW1wdHMiLCJyZXRyeURlbGF5IiwiYXR0ZW1wdCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImRlZHVwbGljYXRlQ29udGVudCIsImNvbnRlbnQiLCJzZWVuTGluZXMiLCJTZXQiLCJkZWR1cGxpY2F0ZWRMaW5lcyIsInRyaW1tZWRMaW5lIiwicHVzaCIsImhhcyIsImFkZCIsImpvaW4iLCJpc01peGVkQ29udGVudCIsIkFycmF5IiwiaXNBcnJheSIsInNvbWUiLCJpdGVtIiwia2V5cyIsImhhc1RleHQiLCJrZXkiLCJoYXNDaGFydCIsIm1lc3NhZ2VUeXBlIiwibWV0YWRhdGEiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidW5kZWZpbmVkIiwib3V0cHV0IiwiZm9ybWF0IiwicGFyc2VkT3V0cHV0Iiwic291cmNlIiwib3JpZ2luYWxSZXNwb25zZSIsImNhbmNlbCIsImFib3J0Q29udHJvbGxlciIsImFib3J0IiwiaGVhbHRoQ2hlY2siLCJjcmVhdGVOOE5DbGllbnQiLCJuOG5DbGllbnRFeGFtcGxlIiwiY2xpZW50IiwicHJvY2VzcyIsImVudiIsIk44Tl9XRUJIT09LX1VSTCIsIk44Tl9TVFJFQU1JTkdfVVJMIiwidXNlcm5hbWUiLCJuOG5VdGlscyIsImZvcm1hdEVycm9yIiwiaXNJbnRlcmltTWVzc2FnZSIsImlzRmluYWxNZXNzYWdlIiwiZ2V0UHJvY2Vzc2luZ1RpbWUiLCJwcm9jZXNzaW5nVGltZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/n8n-client.ts\n"));

/***/ })

});