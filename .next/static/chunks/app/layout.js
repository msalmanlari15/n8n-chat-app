/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./app/globals.css":
/*!*************************!*\
  !*** ./app/globals.css ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"39f4d672f2b1\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9nbG9iYWxzLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIkM6XFxFYnR0aWthciBJbnRlbGxpZ2VuY2UgUHJvamVjdHNcXFRlc3QtQ2hhdC1BcHBcXGFwcFxcZ2xvYmFscy5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIzOWY0ZDY3MmYyYjFcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/providers.tsx":
/*!***************************!*\
  !*** ./app/providers.tsx ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Providers: () => (/* binding */ Providers)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _context_ThemeContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/context/ThemeContext */ \"(app-pages-browser)/./context/ThemeContext.tsx\");\n/* harmony import */ var _context_ChatContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/context/ChatContext */ \"(app-pages-browser)/./context/ChatContext.tsx\");\n/* __next_internal_client_entry_do_not_use__ Providers auto */ \n\n\n\nfunction Providers(param) {\n    let { children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_context_ThemeContext__WEBPACK_IMPORTED_MODULE_2__.ThemeProvider, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_context_ChatContext__WEBPACK_IMPORTED_MODULE_3__.ChatProvider, {\n            children: children\n        }, void 0, false, {\n            fileName: \"C:\\\\Ebttikar Intelligence Projects\\\\Test-Chat-App\\\\app\\\\providers.tsx\",\n            lineNumber: 14,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Ebttikar Intelligence Projects\\\\Test-Chat-App\\\\app\\\\providers.tsx\",\n        lineNumber: 13,\n        columnNumber: 5\n    }, this);\n}\n_c = Providers;\nvar _c;\n$RefreshReg$(_c, \"Providers\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9wcm92aWRlcnMudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFFeUI7QUFDNkI7QUFDRjtBQU03QyxTQUFTRyxVQUFVLEtBQTRCO1FBQTVCLEVBQUVDLFFBQVEsRUFBa0IsR0FBNUI7SUFDeEIscUJBQ0UsOERBQUNILGdFQUFhQTtrQkFDWiw0RUFBQ0MsOERBQVlBO3NCQUNWRTs7Ozs7Ozs7Ozs7QUFJVDtLQVJnQkQiLCJzb3VyY2VzIjpbIkM6XFxFYnR0aWthciBJbnRlbGxpZ2VuY2UgUHJvamVjdHNcXFRlc3QtQ2hhdC1BcHBcXGFwcFxccHJvdmlkZXJzLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVGhlbWVQcm92aWRlciB9IGZyb20gJ0AvY29udGV4dC9UaGVtZUNvbnRleHQnXG5pbXBvcnQgeyBDaGF0UHJvdmlkZXIgfSBmcm9tICdAL2NvbnRleHQvQ2hhdENvbnRleHQnXG5cbmludGVyZmFjZSBQcm92aWRlcnNQcm9wcyB7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFByb3ZpZGVycyh7IGNoaWxkcmVuIH06IFByb3ZpZGVyc1Byb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPFRoZW1lUHJvdmlkZXI+XG4gICAgICA8Q2hhdFByb3ZpZGVyPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L0NoYXRQcm92aWRlcj5cbiAgICA8L1RoZW1lUHJvdmlkZXI+XG4gIClcbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJUaGVtZVByb3ZpZGVyIiwiQ2hhdFByb3ZpZGVyIiwiUHJvdmlkZXJzIiwiY2hpbGRyZW4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/providers.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./context/ChatContext.tsx":
/*!*********************************!*\
  !*** ./context/ChatContext.tsx ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatProvider: () => (/* binding */ ChatProvider),\n/* harmony export */   useChat: () => (/* binding */ useChat)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_n8n_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/n8n-client */ \"(app-pages-browser)/./lib/n8n-client.ts\");\n/* harmony import */ var _lib_mockapi_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/mockapi-client */ \"(app-pages-browser)/./lib/mockapi-client.ts\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/constants */ \"(app-pages-browser)/./lib/constants.ts\");\n/* __next_internal_client_entry_do_not_use__ useChat,ChatProvider auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\nconst ChatContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction useChat() {\n    _s();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ChatContext);\n    if (!context) {\n        throw new Error('useChat must be used within a ChatProvider');\n    }\n    return context;\n}\n_s(useChat, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nfunction ChatProvider(param) {\n    let { children } = param;\n    _s1();\n    // Initialize clients\n    const n8nClient = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)((0,_lib_n8n_client__WEBPACK_IMPORTED_MODULE_2__.createN8NClient)({\n        webhookUrl: _lib_constants__WEBPACK_IMPORTED_MODULE_4__.API_CONFIG.n8n.webhookUrl,\n        streamingUrl: _lib_constants__WEBPACK_IMPORTED_MODULE_4__.API_CONFIG.n8n.streamingUrl,\n        timeout: _lib_constants__WEBPACK_IMPORTED_MODULE_4__.API_CONFIG.n8n.timeout,\n        retryAttempts: _lib_constants__WEBPACK_IMPORTED_MODULE_4__.API_CONFIG.n8n.retryAttempts,\n        retryDelay: _lib_constants__WEBPACK_IMPORTED_MODULE_4__.API_CONFIG.n8n.retryDelay\n    }));\n    const mockApiClient = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)((0,_lib_mockapi_client__WEBPACK_IMPORTED_MODULE_3__.createMockAPIClient)({\n        baseUrl: _lib_constants__WEBPACK_IMPORTED_MODULE_4__.API_CONFIG.mockApi.baseUrl,\n        projectId: _lib_constants__WEBPACK_IMPORTED_MODULE_4__.API_CONFIG.mockApi.projectId,\n        timeout: _lib_constants__WEBPACK_IMPORTED_MODULE_4__.API_CONFIG.mockApi.timeout\n    }));\n    // State\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        sessions: [],\n        currentSessionId: null,\n        isLoading: false,\n        error: null,\n        sidebarCollapsed: false,\n        theme: 'light'\n    });\n    // Current session messages\n    const [currentMessages, setCurrentMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [streamingMessageId, setStreamingMessageId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [currentMessageId, setCurrentMessageId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const sendingMessageRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // Load initial data\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ChatProvider.useEffect\": ()=>{\n            loadSessions();\n            loadSidebarState();\n        }\n    }[\"ChatProvider.useEffect\"], []);\n    // Load messages when session changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ChatProvider.useEffect\": ()=>{\n            if (state.currentSessionId) {\n                loadMessages(state.currentSessionId);\n            } else {\n                setCurrentMessages([]);\n            }\n        }\n    }[\"ChatProvider.useEffect\"], [\n        state.currentSessionId\n    ]);\n    /**\n   * Load all sessions\n   */ const loadSessions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[loadSessions]\": async ()=>{\n            setState({\n                \"ChatProvider.useCallback[loadSessions]\": (prev)=>({\n                        ...prev,\n                        isLoading: true,\n                        error: null\n                    })\n            }[\"ChatProvider.useCallback[loadSessions]\"]);\n            try {\n                const sessions = await mockApiClient.current.getSessions();\n                const savedSessionId = localStorage.getItem(_lib_constants__WEBPACK_IMPORTED_MODULE_4__.STORAGE_KEYS.sessionId);\n                setState({\n                    \"ChatProvider.useCallback[loadSessions]\": (prev)=>{\n                        var _sessions_;\n                        var _sessions__id;\n                        return {\n                            ...prev,\n                            sessions,\n                            isLoading: false,\n                            // Select saved session or first session if none selected\n                            currentSessionId: savedSessionId && sessions.find({\n                                \"ChatProvider.useCallback[loadSessions]\": (s)=>s.id === savedSessionId\n                            }[\"ChatProvider.useCallback[loadSessions]\"]) ? savedSessionId : (_sessions__id = (_sessions_ = sessions[0]) === null || _sessions_ === void 0 ? void 0 : _sessions_.id) !== null && _sessions__id !== void 0 ? _sessions__id : null\n                        };\n                    }\n                }[\"ChatProvider.useCallback[loadSessions]\"]);\n            } catch (error) {\n                const errorMessage = error instanceof _lib_mockapi_client__WEBPACK_IMPORTED_MODULE_3__.MockAPIError ? _lib_mockapi_client__WEBPACK_IMPORTED_MODULE_3__.mockAPIUtils.formatError(error) : 'Failed to load sessions';\n                setState({\n                    \"ChatProvider.useCallback[loadSessions]\": (prev)=>({\n                            ...prev,\n                            isLoading: false,\n                            error: errorMessage\n                        })\n                }[\"ChatProvider.useCallback[loadSessions]\"]);\n            }\n        }\n    }[\"ChatProvider.useCallback[loadSessions]\"], []);\n    /**\n   * Load messages for a session\n   */ const loadMessages = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[loadMessages]\": async (sessionId)=>{\n            try {\n                const sessionMessages = await mockApiClient.current.getMessages(sessionId);\n                console.log('Loading messages for session:', sessionId, 'count:', sessionMessages.length);\n                console.log('Message IDs:', sessionMessages.map({\n                    \"ChatProvider.useCallback[loadMessages]\": (m)=>m.id\n                }[\"ChatProvider.useCallback[loadMessages]\"]));\n                setCurrentMessages(sessionMessages);\n            } catch (error) {\n                console.error('Failed to load messages:', error);\n            }\n        }\n    }[\"ChatProvider.useCallback[loadMessages]\"], []);\n    /**\n   * Create new session\n   */ const createSession = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[createSession]\": async (name)=>{\n            setState({\n                \"ChatProvider.useCallback[createSession]\": (prev)=>({\n                        ...prev,\n                        isLoading: true,\n                        error: null\n                    })\n            }[\"ChatProvider.useCallback[createSession]\"]);\n            try {\n                const sessionName = name || \"Chat \".concat(new Date().toLocaleString());\n                const session = await mockApiClient.current.createSession(sessionName);\n                setState({\n                    \"ChatProvider.useCallback[createSession]\": (prev)=>({\n                            ...prev,\n                            sessions: [\n                                session,\n                                ...prev.sessions\n                            ],\n                            currentSessionId: session.id,\n                            isLoading: false\n                        })\n                }[\"ChatProvider.useCallback[createSession]\"]);\n                // Save current session to localStorage\n                localStorage.setItem(_lib_constants__WEBPACK_IMPORTED_MODULE_4__.STORAGE_KEYS.sessionId, session.id);\n            } catch (error) {\n                const errorMessage = error instanceof _lib_mockapi_client__WEBPACK_IMPORTED_MODULE_3__.MockAPIError ? _lib_mockapi_client__WEBPACK_IMPORTED_MODULE_3__.mockAPIUtils.formatError(error) : 'Failed to create session';\n                setState({\n                    \"ChatProvider.useCallback[createSession]\": (prev)=>({\n                            ...prev,\n                            isLoading: false,\n                            error: errorMessage\n                        })\n                }[\"ChatProvider.useCallback[createSession]\"]);\n            }\n        }\n    }[\"ChatProvider.useCallback[createSession]\"], []);\n    /**\n   * Select session\n   */ const selectSession = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[selectSession]\": async (sessionId)=>{\n            setState({\n                \"ChatProvider.useCallback[selectSession]\": (prev)=>({\n                        ...prev,\n                        currentSessionId: sessionId\n                    })\n            }[\"ChatProvider.useCallback[selectSession]\"]);\n            // Save to localStorage\n            localStorage.setItem(_lib_constants__WEBPACK_IMPORTED_MODULE_4__.STORAGE_KEYS.sessionId, sessionId);\n            // Update session activity\n            try {\n                await mockApiClient.current.updateSessionActivity(sessionId);\n            } catch (error) {\n                console.error('Failed to update session activity:', error);\n            }\n        }\n    }[\"ChatProvider.useCallback[selectSession]\"], []);\n    /**\n   * Rename session\n   */ const renameSession = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[renameSession]\": async (sessionId, newName)=>{\n            const validationError = _lib_mockapi_client__WEBPACK_IMPORTED_MODULE_3__.mockAPIUtils.validateSessionName(newName);\n            if (validationError) {\n                setState({\n                    \"ChatProvider.useCallback[renameSession]\": (prev)=>({\n                            ...prev,\n                            error: validationError\n                        })\n                }[\"ChatProvider.useCallback[renameSession]\"]);\n                return;\n            }\n            try {\n                const updatedSession = await mockApiClient.current.updateSession(sessionId, {\n                    name: newName\n                });\n                setState({\n                    \"ChatProvider.useCallback[renameSession]\": (prev)=>({\n                            ...prev,\n                            sessions: prev.sessions.map({\n                                \"ChatProvider.useCallback[renameSession]\": (session)=>session.id === sessionId ? updatedSession : session\n                            }[\"ChatProvider.useCallback[renameSession]\"])\n                        })\n                }[\"ChatProvider.useCallback[renameSession]\"]);\n            } catch (error) {\n                const errorMessage = error instanceof _lib_mockapi_client__WEBPACK_IMPORTED_MODULE_3__.MockAPIError ? _lib_mockapi_client__WEBPACK_IMPORTED_MODULE_3__.mockAPIUtils.formatError(error) : 'Failed to rename session';\n                setState({\n                    \"ChatProvider.useCallback[renameSession]\": (prev)=>({\n                            ...prev,\n                            error: errorMessage\n                        })\n                }[\"ChatProvider.useCallback[renameSession]\"]);\n            }\n        }\n    }[\"ChatProvider.useCallback[renameSession]\"], []);\n    /**\n   * Delete session\n   */ const deleteSession = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[deleteSession]\": async (sessionId)=>{\n            try {\n                await mockApiClient.current.deleteSession(sessionId);\n                setState({\n                    \"ChatProvider.useCallback[deleteSession]\": (prev)=>{\n                        var _newSessions_;\n                        const newSessions = prev.sessions.filter({\n                            \"ChatProvider.useCallback[deleteSession].newSessions\": (s)=>s.id !== sessionId\n                        }[\"ChatProvider.useCallback[deleteSession].newSessions\"]);\n                        var _newSessions__id;\n                        const newCurrentSessionId = prev.currentSessionId === sessionId ? (_newSessions__id = (_newSessions_ = newSessions[0]) === null || _newSessions_ === void 0 ? void 0 : _newSessions_.id) !== null && _newSessions__id !== void 0 ? _newSessions__id : null : prev.currentSessionId;\n                        // Update localStorage\n                        if (newCurrentSessionId) {\n                            localStorage.setItem(_lib_constants__WEBPACK_IMPORTED_MODULE_4__.STORAGE_KEYS.sessionId, newCurrentSessionId);\n                        } else {\n                            localStorage.removeItem(_lib_constants__WEBPACK_IMPORTED_MODULE_4__.STORAGE_KEYS.sessionId);\n                        }\n                        return {\n                            ...prev,\n                            sessions: newSessions,\n                            currentSessionId: newCurrentSessionId\n                        };\n                    }\n                }[\"ChatProvider.useCallback[deleteSession]\"]);\n            } catch (error) {\n                const errorMessage = error instanceof _lib_mockapi_client__WEBPACK_IMPORTED_MODULE_3__.MockAPIError ? _lib_mockapi_client__WEBPACK_IMPORTED_MODULE_3__.mockAPIUtils.formatError(error) : 'Failed to delete session';\n                setState({\n                    \"ChatProvider.useCallback[deleteSession]\": (prev)=>({\n                            ...prev,\n                            error: errorMessage\n                        })\n                }[\"ChatProvider.useCallback[deleteSession]\"]);\n            }\n        }\n    }[\"ChatProvider.useCallback[deleteSession]\"], []);\n    /**\n   * Send message\n   */ const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[sendMessage]\": async (content)=>{\n            if (!state.currentSessionId) {\n                setState({\n                    \"ChatProvider.useCallback[sendMessage]\": (prev)=>({\n                            ...prev,\n                            error: 'No session selected'\n                        })\n                }[\"ChatProvider.useCallback[sendMessage]\"]);\n                return;\n            }\n            // Prevent double submissions with ref\n            if (sendingMessageRef.current) {\n                console.log('Already sending message, ignoring duplicate request');\n                return;\n            }\n            sendingMessageRef.current = true;\n            setState({\n                \"ChatProvider.useCallback[sendMessage]\": (prev)=>({\n                        ...prev,\n                        error: null,\n                        isLoading: true\n                    })\n            }[\"ChatProvider.useCallback[sendMessage]\"]);\n            // Generate a temporary message ID for tracking\n            const tempMessageId = \"temp-\".concat(Date.now());\n            setCurrentMessageId(tempMessageId);\n            // Create user message\n            const userMessage = {\n                sessionId: state.currentSessionId,\n                content,\n                type: 'user',\n                timestamp: new Date()\n            };\n            try {\n                // Save user message\n                const savedUserMessage = await mockApiClient.current.createMessage(userMessage);\n                console.log('Adding user message:', savedUserMessage.id);\n                setCurrentMessages({\n                    \"ChatProvider.useCallback[sendMessage]\": (prev)=>{\n                        // Check if this message already exists to prevent duplicates\n                        const exists = prev.some({\n                            \"ChatProvider.useCallback[sendMessage].exists\": (msg)=>msg.id === savedUserMessage.id\n                        }[\"ChatProvider.useCallback[sendMessage].exists\"]);\n                        if (exists) {\n                            console.log('User message already exists, skipping:', savedUserMessage.id);\n                            return prev;\n                        }\n                        console.log('Adding new user message to state:', savedUserMessage.id);\n                        return [\n                            ...prev,\n                            savedUserMessage\n                        ];\n                    }\n                }[\"ChatProvider.useCallback[sendMessage]\"]);\n                // Prepare n8n request with message ID for tracking\n                const n8nRequest = {\n                    username: 'user',\n                    message: content,\n                    sessionId: state.currentSessionId,\n                    timestamp: new Date(),\n                    messageId: tempMessageId // Add this to track thinking updates\n                };\n                // Send to n8n\n                const response = await n8nClient.current.sendMessageWithRetry(n8nRequest);\n                // Create assistant message\n                const assistantMessage = {\n                    sessionId: state.currentSessionId,\n                    content: '',\n                    type: 'assistant',\n                    timestamp: new Date(),\n                    responseData: {\n                        type: response.messageType,\n                        content: response.content,\n                        metadata: response.metadata\n                    }\n                };\n                // Save assistant message\n                const savedAssistantMessage = await mockApiClient.current.createMessage(assistantMessage);\n                console.log('Adding assistant message:', savedAssistantMessage.id);\n                setCurrentMessages({\n                    \"ChatProvider.useCallback[sendMessage]\": (prev)=>{\n                        // Check if this message already exists to prevent duplicates\n                        const exists = prev.some({\n                            \"ChatProvider.useCallback[sendMessage].exists\": (msg)=>msg.id === savedAssistantMessage.id\n                        }[\"ChatProvider.useCallback[sendMessage].exists\"]);\n                        if (exists) {\n                            console.log('Assistant message already exists, skipping:', savedAssistantMessage.id);\n                            return prev;\n                        }\n                        console.log('Adding new assistant message to state:', savedAssistantMessage.id);\n                        return [\n                            ...prev,\n                            savedAssistantMessage\n                        ];\n                    }\n                }[\"ChatProvider.useCallback[sendMessage]\"]);\n                // Update session in state\n                setState({\n                    \"ChatProvider.useCallback[sendMessage]\": (prev)=>({\n                            ...prev,\n                            sessions: prev.sessions.map({\n                                \"ChatProvider.useCallback[sendMessage]\": (session)=>session.id === state.currentSessionId ? {\n                                        ...session,\n                                        metadata: {\n                                            ...session.metadata,\n                                            messageCount: session.metadata.messageCount + 2\n                                        }\n                                    } : session\n                            }[\"ChatProvider.useCallback[sendMessage]\"])\n                        })\n                }[\"ChatProvider.useCallback[sendMessage]\"]);\n                // Clear loading state and message ID on success\n                setState({\n                    \"ChatProvider.useCallback[sendMessage]\": (prev)=>({\n                            ...prev,\n                            isLoading: false\n                        })\n                }[\"ChatProvider.useCallback[sendMessage]\"]);\n                setCurrentMessageId(null);\n            } catch (error) {\n                const errorMessage = error instanceof _lib_n8n_client__WEBPACK_IMPORTED_MODULE_2__.N8NError ? _lib_n8n_client__WEBPACK_IMPORTED_MODULE_2__.n8nUtils.formatError(error) : 'Failed to send message';\n                setState({\n                    \"ChatProvider.useCallback[sendMessage]\": (prev)=>({\n                            ...prev,\n                            error: errorMessage,\n                            isLoading: false\n                        })\n                }[\"ChatProvider.useCallback[sendMessage]\"]);\n                setCurrentMessageId(null);\n            } finally{\n                sendingMessageRef.current = false;\n            }\n        }\n    }[\"ChatProvider.useCallback[sendMessage]\"], [\n        state.currentSessionId\n    ]);\n    /**\n   * Handle streaming messages\n   */ const handleStreaming = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[handleStreaming]\": async (sessionId)=>{\n            try {\n                for await (const response of n8nClient.current.streamMessages(sessionId)){\n                    if (_lib_n8n_client__WEBPACK_IMPORTED_MODULE_2__.n8nUtils.isInterimMessage(response)) {\n                        // Create interim message\n                        const interimMessage = {\n                            sessionId,\n                            content: typeof response.content === 'string' ? response.content : JSON.stringify(response.content),\n                            type: 'interim',\n                            timestamp: new Date(),\n                            responseData: {\n                                type: response.messageType,\n                                content: response.content,\n                                metadata: response.metadata\n                            }\n                        };\n                        // Save and display interim message\n                        const savedInterimMessage = await mockApiClient.current.createMessage(interimMessage);\n                        setCurrentMessages({\n                            \"ChatProvider.useCallback[handleStreaming]\": (prev)=>[\n                                    ...prev,\n                                    savedInterimMessage\n                                ]\n                        }[\"ChatProvider.useCallback[handleStreaming]\"]);\n                    }\n                }\n            } catch (error) {\n                console.error('Streaming error:', error);\n            }\n        }\n    }[\"ChatProvider.useCallback[handleStreaming]\"], []);\n    /**\n   * Retry failed message\n   */ const retryMessage = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[retryMessage]\": async (messageId)=>{\n            const message = currentMessages.find({\n                \"ChatProvider.useCallback[retryMessage].message\": (m)=>m.id === messageId\n            }[\"ChatProvider.useCallback[retryMessage].message\"]);\n            if (!message || message.type !== 'user') return;\n            await sendMessage(message.content);\n        }\n    }[\"ChatProvider.useCallback[retryMessage]\"], [\n        currentMessages,\n        sendMessage\n    ]);\n    /**\n   * Toggle sidebar\n   */ const toggleSidebar = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[toggleSidebar]\": ()=>{\n            setState({\n                \"ChatProvider.useCallback[toggleSidebar]\": (prev)=>{\n                    const newCollapsed = !prev.sidebarCollapsed;\n                    localStorage.setItem(_lib_constants__WEBPACK_IMPORTED_MODULE_4__.STORAGE_KEYS.sidebarCollapsed, String(newCollapsed));\n                    return {\n                        ...prev,\n                        sidebarCollapsed: newCollapsed\n                    };\n                }\n            }[\"ChatProvider.useCallback[toggleSidebar]\"]);\n        }\n    }[\"ChatProvider.useCallback[toggleSidebar]\"], []);\n    /**\n   * Load sidebar state from localStorage\n   */ const loadSidebarState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[loadSidebarState]\": ()=>{\n            const saved = localStorage.getItem(_lib_constants__WEBPACK_IMPORTED_MODULE_4__.STORAGE_KEYS.sidebarCollapsed);\n            if (saved) {\n                setState({\n                    \"ChatProvider.useCallback[loadSidebarState]\": (prev)=>({\n                            ...prev,\n                            sidebarCollapsed: saved === 'true'\n                        })\n                }[\"ChatProvider.useCallback[loadSidebarState]\"]);\n            }\n        }\n    }[\"ChatProvider.useCallback[loadSidebarState]\"], []);\n    /**\n   * Clear error\n   */ const clearError = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ChatProvider.useCallback[clearError]\": ()=>{\n            setState({\n                \"ChatProvider.useCallback[clearError]\": (prev)=>({\n                        ...prev,\n                        error: null\n                    })\n            }[\"ChatProvider.useCallback[clearError]\"]);\n        }\n    }[\"ChatProvider.useCallback[clearError]\"], []);\n    const value = {\n        state,\n        currentMessages,\n        currentMessageId,\n        createSession,\n        selectSession,\n        renameSession,\n        deleteSession,\n        sendMessage,\n        retryMessage,\n        toggleSidebar,\n        clearError\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ChatContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Ebttikar Intelligence Projects\\\\Test-Chat-App\\\\context\\\\ChatContext.tsx\",\n        lineNumber: 445,\n        columnNumber: 5\n    }, this);\n}\n_s1(ChatProvider, \"yqIVGbJRCf/4KC7JQutgEjkWA2Q=\");\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHQvQ2hhdENvbnRleHQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFa0c7QUFFNUI7QUFDZ0I7QUFDakI7QUF5QnJFLE1BQU1lLDRCQUFjZCxvREFBYUEsQ0FBOEJlO0FBRXhELFNBQVNDOztJQUNkLE1BQU1DLFVBQVVoQixpREFBVUEsQ0FBQ2E7SUFDM0IsSUFBSSxDQUFDRyxTQUFTO1FBQ1osTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBQ0EsT0FBT0Q7QUFDVDtHQU5nQkQ7QUFZVCxTQUFTRyxhQUFhLEtBQStCO1FBQS9CLEVBQUVDLFFBQVEsRUFBcUIsR0FBL0I7O0lBQzNCLHFCQUFxQjtJQUNyQixNQUFNQyxZQUFZaEIsNkNBQU1BLENBQUNDLGdFQUFlQSxDQUFDO1FBQ3ZDZ0IsWUFBWVYsc0RBQVVBLENBQUNXLEdBQUcsQ0FBQ0QsVUFBVTtRQUNyQ0UsY0FBY1osc0RBQVVBLENBQUNXLEdBQUcsQ0FBQ0MsWUFBWTtRQUN6Q0MsU0FBU2Isc0RBQVVBLENBQUNXLEdBQUcsQ0FBQ0UsT0FBTztRQUMvQkMsZUFBZWQsc0RBQVVBLENBQUNXLEdBQUcsQ0FBQ0csYUFBYTtRQUMzQ0MsWUFBWWYsc0RBQVVBLENBQUNXLEdBQUcsQ0FBQ0ksVUFBVTtJQUN2QztJQUVBLE1BQU1DLGdCQUFnQnZCLDZDQUFNQSxDQUFDSSx3RUFBbUJBLENBQUM7UUFDL0NvQixTQUFTakIsc0RBQVVBLENBQUNrQixPQUFPLENBQUNELE9BQU87UUFDbkNFLFdBQVduQixzREFBVUEsQ0FBQ2tCLE9BQU8sQ0FBQ0MsU0FBUztRQUN2Q04sU0FBU2Isc0RBQVVBLENBQUNrQixPQUFPLENBQUNMLE9BQU87SUFDckM7SUFFQSxRQUFRO0lBQ1IsTUFBTSxDQUFDTyxPQUFPQyxTQUFTLEdBQUc5QiwrQ0FBUUEsQ0FBWTtRQUM1QytCLFVBQVUsRUFBRTtRQUNaQyxrQkFBa0I7UUFDbEJDLFdBQVc7UUFDWEMsT0FBTztRQUNQQyxrQkFBa0I7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O0dBRUMsR0FDRCxNQUFNZ0MsZ0JBQWdCckgsa0RBQVdBO21EQUFDO1lBQ2hDNkI7MkRBQVNpQixDQUFBQTtvQkFDUCxNQUFNd0UsZUFBZSxDQUFDeEUsS0FBS1osZ0JBQWdCO29CQUMzQ2dCLGFBQWFxQixPQUFPLENBQUM5RCx3REFBWUEsQ0FBQ3lCLGdCQUFnQixFQUFFcUYsT0FBT0Q7b0JBQzNELE9BQU87d0JBQUUsR0FBR3hFLElBQUk7d0JBQUVaLGtCQUFrQm9GO29CQUFhO2dCQUNuRDs7UUFDRjtrREFBRyxFQUFFO0lBRUw7O0dBRUMsR0FDRCxNQUFNMUUsbUJBQW1CNUMsa0RBQVdBO3NEQUFDO1lBQ25DLE1BQU13SCxRQUFRdEUsYUFBYUMsT0FBTyxDQUFDMUMsd0RBQVlBLENBQUN5QixnQkFBZ0I7WUFDaEUsSUFBSXNGLE9BQU87Z0JBQ1QzRjtrRUFBU2lCLENBQUFBLE9BQVM7NEJBQUUsR0FBR0EsSUFBSTs0QkFBRVosa0JBQWtCc0YsVUFBVTt3QkFBTzs7WUFDbEU7UUFDRjtxREFBRyxFQUFFO0lBRUw7O0dBRUMsR0FDRCxNQUFNQyxhQUFhekgsa0RBQVdBO2dEQUFDO1lBQzdCNkI7d0RBQVNpQixDQUFBQSxPQUFTO3dCQUFFLEdBQUdBLElBQUk7d0JBQUViLE9BQU87b0JBQUs7O1FBQzNDOytDQUFHLEVBQUU7SUFFTCxNQUFNeUYsUUFBeUI7UUFDN0I5RjtRQUNBUTtRQUNBSTtRQUNBeUI7UUFDQU87UUFDQUU7UUFDQU07UUFDQUs7UUFDQStCO1FBQ0FDO1FBQ0FJO0lBQ0Y7SUFFQSxxQkFDRSw4REFBQy9HLFlBQVlpSCxRQUFRO1FBQUNELE9BQU9BO2tCQUMxQjFHOzs7Ozs7QUFHUDtJQW5aZ0JEO0tBQUFBIiwic291cmNlcyI6WyJDOlxcRWJ0dGlrYXIgSW50ZWxsaWdlbmNlIFByb2plY3RzXFxUZXN0LUNoYXQtQXBwXFxjb250ZXh0XFxDaGF0Q29udGV4dC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBDaGF0U3RhdGUsIENoYXRTZXNzaW9uLCBNZXNzYWdlLCBOOE5SZXF1ZXN0LCBOOE5SZXNwb25zZSB9IGZyb20gJ0AvdHlwZXMnXG5pbXBvcnQgeyBjcmVhdGVOOE5DbGllbnQsIE44TkVycm9yLCBuOG5VdGlscyB9IGZyb20gJ0AvbGliL244bi1jbGllbnQnXG5pbXBvcnQgeyBjcmVhdGVNb2NrQVBJQ2xpZW50LCBNb2NrQVBJRXJyb3IsIG1vY2tBUElVdGlscyB9IGZyb20gJ0AvbGliL21vY2thcGktY2xpZW50J1xuaW1wb3J0IHsgQVBJX0NPTkZJRywgVUlfQ09ORklHLCBTVE9SQUdFX0tFWVMgfSBmcm9tICdAL2xpYi9jb25zdGFudHMnXG5cbmludGVyZmFjZSBDaGF0Q29udGV4dFR5cGUge1xuICAvLyBTdGF0ZVxuICBzdGF0ZTogQ2hhdFN0YXRlXG4gIGN1cnJlbnRNZXNzYWdlczogTWVzc2FnZVtdXG4gIGN1cnJlbnRNZXNzYWdlSWQ6IHN0cmluZyB8IG51bGxcbiAgXG4gIC8vIFNlc3Npb24gb3BlcmF0aW9uc1xuICBjcmVhdGVTZXNzaW9uOiAobmFtZT86IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPlxuICBzZWxlY3RTZXNzaW9uOiAoc2Vzc2lvbklkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD5cbiAgcmVuYW1lU2Vzc2lvbjogKHNlc3Npb25JZDogc3RyaW5nLCBuZXdOYW1lOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD5cbiAgZGVsZXRlU2Vzc2lvbjogKHNlc3Npb25JZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+XG4gIFxuICAvLyBNZXNzYWdlIG9wZXJhdGlvbnNcbiAgc2VuZE1lc3NhZ2U6IChjb250ZW50OiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD5cbiAgcmV0cnlNZXNzYWdlOiAobWVzc2FnZUlkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD5cbiAgXG4gIC8vIFVJIG9wZXJhdGlvbnNcbiAgdG9nZ2xlU2lkZWJhcjogKCkgPT4gdm9pZFxuICBcbiAgLy8gVXRpbGl0eVxuICBjbGVhckVycm9yOiAoKSA9PiB2b2lkXG59XG5cbmNvbnN0IENoYXRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxDaGF0Q29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZClcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoYXQoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KENoYXRDb250ZXh0KVxuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUNoYXQgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIENoYXRQcm92aWRlcicpXG4gIH1cbiAgcmV0dXJuIGNvbnRleHRcbn1cblxuaW50ZXJmYWNlIENoYXRQcm92aWRlclByb3BzIHtcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ2hhdFByb3ZpZGVyKHsgY2hpbGRyZW4gfTogQ2hhdFByb3ZpZGVyUHJvcHMpIHtcbiAgLy8gSW5pdGlhbGl6ZSBjbGllbnRzXG4gIGNvbnN0IG44bkNsaWVudCA9IHVzZVJlZihjcmVhdGVOOE5DbGllbnQoe1xuICAgIHdlYmhvb2tVcmw6IEFQSV9DT05GSUcubjhuLndlYmhvb2tVcmwsXG4gICAgc3RyZWFtaW5nVXJsOiBBUElfQ09ORklHLm44bi5zdHJlYW1pbmdVcmwsXG4gICAgdGltZW91dDogQVBJX0NPTkZJRy5uOG4udGltZW91dCxcbiAgICByZXRyeUF0dGVtcHRzOiBBUElfQ09ORklHLm44bi5yZXRyeUF0dGVtcHRzLFxuICAgIHJldHJ5RGVsYXk6IEFQSV9DT05GSUcubjhuLnJldHJ5RGVsYXlcbiAgfSkpXG4gIFxuICBjb25zdCBtb2NrQXBpQ2xpZW50ID0gdXNlUmVmKGNyZWF0ZU1vY2tBUElDbGllbnQoe1xuICAgIGJhc2VVcmw6IEFQSV9DT05GSUcubW9ja0FwaS5iYXNlVXJsLFxuICAgIHByb2plY3RJZDogQVBJX0NPTkZJRy5tb2NrQXBpLnByb2plY3RJZCxcbiAgICB0aW1lb3V0OiBBUElfQ09ORklHLm1vY2tBcGkudGltZW91dFxuICB9KSlcblxuICAvLyBTdGF0ZVxuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlPENoYXRTdGF0ZT4oe1xuICAgIHNlc3Npb25zOiBbXSxcbiAgICBjdXJyZW50U2Vzc2lvbklkOiBudWxsLFxuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgZXJyb3I6IG51bGwsXG4gICAgc2lkZWJhckNvbGxhcHNlZDogZmFsc2UsXG4gICAgdGhlbWU6ICdsaWdodCdcbiAgfSlcblxuICAvLyBDdXJyZW50IHNlc3Npb24gbWVzc2FnZXNcbiAgY29uc3QgW2N1cnJlbnRNZXNzYWdlcywgc2V0Q3VycmVudE1lc3NhZ2VzXSA9IHVzZVN0YXRlPE1lc3NhZ2VbXT4oW10pXG4gIGNvbnN0IFtzdHJlYW1pbmdNZXNzYWdlSWQsIHNldFN0cmVhbWluZ01lc3NhZ2VJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKVxuICBjb25zdCBbY3VycmVudE1lc3NhZ2VJZCwgc2V0Q3VycmVudE1lc3NhZ2VJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKVxuICBjb25zdCBzZW5kaW5nTWVzc2FnZVJlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSlcblxuICAvLyBMb2FkIGluaXRpYWwgZGF0YVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxvYWRTZXNzaW9ucygpXG4gICAgbG9hZFNpZGViYXJTdGF0ZSgpXG4gIH0sIFtdKVxuXG4gIC8vIExvYWQgbWVzc2FnZXMgd2hlbiBzZXNzaW9uIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc3RhdGUuY3VycmVudFNlc3Npb25JZCkge1xuICAgICAgbG9hZE1lc3NhZ2VzKHN0YXRlLmN1cnJlbnRTZXNzaW9uSWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEN1cnJlbnRNZXNzYWdlcyhbXSlcbiAgICB9XG4gIH0sIFtzdGF0ZS5jdXJyZW50U2Vzc2lvbklkXSlcblxuICAvKipcbiAgICogTG9hZCBhbGwgc2Vzc2lvbnNcbiAgICovXG4gIGNvbnN0IGxvYWRTZXNzaW9ucyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBzZXRTdGF0ZShwcmV2ID0+ICh7IC4uLnByZXYsIGlzTG9hZGluZzogdHJ1ZSwgZXJyb3I6IG51bGwgfSkpXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlc3Npb25zID0gYXdhaXQgbW9ja0FwaUNsaWVudC5jdXJyZW50LmdldFNlc3Npb25zKClcbiAgICAgIGNvbnN0IHNhdmVkU2Vzc2lvbklkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9LRVlTLnNlc3Npb25JZClcbiAgICAgIFxuICAgICAgc2V0U3RhdGUocHJldiA9PiAoeyBcbiAgICAgICAgLi4ucHJldiwgXG4gICAgICAgIHNlc3Npb25zLCBcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgLy8gU2VsZWN0IHNhdmVkIHNlc3Npb24gb3IgZmlyc3Qgc2Vzc2lvbiBpZiBub25lIHNlbGVjdGVkXG4gICAgICAgIGN1cnJlbnRTZXNzaW9uSWQ6IHNhdmVkU2Vzc2lvbklkICYmIHNlc3Npb25zLmZpbmQocyA9PiBzLmlkID09PSBzYXZlZFNlc3Npb25JZCkgXG4gICAgICAgICAgPyBzYXZlZFNlc3Npb25JZCBcbiAgICAgICAgICA6IChzZXNzaW9uc1swXT8uaWQgPz8gbnVsbClcbiAgICAgIH0pKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIE1vY2tBUElFcnJvciBcbiAgICAgICAgPyBtb2NrQVBJVXRpbHMuZm9ybWF0RXJyb3IoZXJyb3IpXG4gICAgICAgIDogJ0ZhaWxlZCB0byBsb2FkIHNlc3Npb25zJ1xuICAgICAgXG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7IFxuICAgICAgICAuLi5wcmV2LCBcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSwgXG4gICAgICAgIGVycm9yOiBlcnJvck1lc3NhZ2UgXG4gICAgICB9KSlcbiAgICB9XG4gIH0sIFtdKVxuXG4gIC8qKlxuICAgKiBMb2FkIG1lc3NhZ2VzIGZvciBhIHNlc3Npb25cbiAgICovXG4gIGNvbnN0IGxvYWRNZXNzYWdlcyA9IHVzZUNhbGxiYWNrKGFzeW5jIChzZXNzaW9uSWQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZXNzaW9uTWVzc2FnZXMgPSBhd2FpdCBtb2NrQXBpQ2xpZW50LmN1cnJlbnQuZ2V0TWVzc2FnZXMoc2Vzc2lvbklkKVxuICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcgbWVzc2FnZXMgZm9yIHNlc3Npb246Jywgc2Vzc2lvbklkLCAnY291bnQ6Jywgc2Vzc2lvbk1lc3NhZ2VzLmxlbmd0aClcbiAgICAgIGNvbnNvbGUubG9nKCdNZXNzYWdlIElEczonLCBzZXNzaW9uTWVzc2FnZXMubWFwKG0gPT4gbS5pZCkpXG4gICAgICBzZXRDdXJyZW50TWVzc2FnZXMoc2Vzc2lvbk1lc3NhZ2VzKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBtZXNzYWdlczonLCBlcnJvcilcbiAgICB9XG4gIH0sIFtdKVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgbmV3IHNlc3Npb25cbiAgICovXG4gIGNvbnN0IGNyZWF0ZVNlc3Npb24gPSB1c2VDYWxsYmFjayhhc3luYyAobmFtZT86IHN0cmluZykgPT4ge1xuICAgIHNldFN0YXRlKHByZXYgPT4gKHsgLi4ucHJldiwgaXNMb2FkaW5nOiB0cnVlLCBlcnJvcjogbnVsbCB9KSlcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2Vzc2lvbk5hbWUgPSBuYW1lIHx8IGBDaGF0ICR7bmV3IERhdGUoKS50b0xvY2FsZVN0cmluZygpfWBcbiAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBtb2NrQXBpQ2xpZW50LmN1cnJlbnQuY3JlYXRlU2Vzc2lvbihzZXNzaW9uTmFtZSlcbiAgICAgIFxuICAgICAgc2V0U3RhdGUocHJldiA9PiAoeyBcbiAgICAgICAgLi4ucHJldiwgXG4gICAgICAgIHNlc3Npb25zOiBbc2Vzc2lvbiwgLi4ucHJldi5zZXNzaW9uc10sXG4gICAgICAgIGN1cnJlbnRTZXNzaW9uSWQ6IHNlc3Npb24uaWQsXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2VcbiAgICAgIH0pKVxuICAgICAgXG4gICAgICAvLyBTYXZlIGN1cnJlbnQgc2Vzc2lvbiB0byBsb2NhbFN0b3JhZ2VcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZUy5zZXNzaW9uSWQsIHNlc3Npb24uaWQpXG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBNb2NrQVBJRXJyb3IgXG4gICAgICAgID8gbW9ja0FQSVV0aWxzLmZvcm1hdEVycm9yKGVycm9yKVxuICAgICAgICA6ICdGYWlsZWQgdG8gY3JlYXRlIHNlc3Npb24nXG4gICAgICBcbiAgICAgIHNldFN0YXRlKHByZXYgPT4gKHsgXG4gICAgICAgIC4uLnByZXYsIFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLCBcbiAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSBcbiAgICAgIH0pKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgLyoqXG4gICAqIFNlbGVjdCBzZXNzaW9uXG4gICAqL1xuICBjb25zdCBzZWxlY3RTZXNzaW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKHNlc3Npb25JZDogc3RyaW5nKSA9PiB7XG4gICAgc2V0U3RhdGUocHJldiA9PiAoeyAuLi5wcmV2LCBjdXJyZW50U2Vzc2lvbklkOiBzZXNzaW9uSWQgfSkpXG4gICAgXG4gICAgLy8gU2F2ZSB0byBsb2NhbFN0b3JhZ2VcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWVMuc2Vzc2lvbklkLCBzZXNzaW9uSWQpXG4gICAgXG4gICAgLy8gVXBkYXRlIHNlc3Npb24gYWN0aXZpdHlcbiAgICB0cnkge1xuICAgICAgYXdhaXQgbW9ja0FwaUNsaWVudC5jdXJyZW50LnVwZGF0ZVNlc3Npb25BY3Rpdml0eShzZXNzaW9uSWQpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgc2Vzc2lvbiBhY3Rpdml0eTonLCBlcnJvcilcbiAgICB9XG4gIH0sIFtdKVxuXG4gIC8qKlxuICAgKiBSZW5hbWUgc2Vzc2lvblxuICAgKi9cbiAgY29uc3QgcmVuYW1lU2Vzc2lvbiA9IHVzZUNhbGxiYWNrKGFzeW5jIChzZXNzaW9uSWQ6IHN0cmluZywgbmV3TmFtZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgdmFsaWRhdGlvbkVycm9yID0gbW9ja0FQSVV0aWxzLnZhbGlkYXRlU2Vzc2lvbk5hbWUobmV3TmFtZSlcbiAgICBpZiAodmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7IC4uLnByZXYsIGVycm9yOiB2YWxpZGF0aW9uRXJyb3IgfSkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdXBkYXRlZFNlc3Npb24gPSBhd2FpdCBtb2NrQXBpQ2xpZW50LmN1cnJlbnQudXBkYXRlU2Vzc2lvbihzZXNzaW9uSWQsIHsgbmFtZTogbmV3TmFtZSB9KVxuICAgICAgXG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIHNlc3Npb25zOiBwcmV2LnNlc3Npb25zLm1hcChzZXNzaW9uID0+XG4gICAgICAgICAgc2Vzc2lvbi5pZCA9PT0gc2Vzc2lvbklkID8gdXBkYXRlZFNlc3Npb24gOiBzZXNzaW9uXG4gICAgICAgIClcbiAgICAgIH0pKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIE1vY2tBUElFcnJvciBcbiAgICAgICAgPyBtb2NrQVBJVXRpbHMuZm9ybWF0RXJyb3IoZXJyb3IpXG4gICAgICAgIDogJ0ZhaWxlZCB0byByZW5hbWUgc2Vzc2lvbidcbiAgICAgIFxuICAgICAgc2V0U3RhdGUocHJldiA9PiAoeyAuLi5wcmV2LCBlcnJvcjogZXJyb3JNZXNzYWdlIH0pKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgLyoqXG4gICAqIERlbGV0ZSBzZXNzaW9uXG4gICAqL1xuICBjb25zdCBkZWxldGVTZXNzaW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKHNlc3Npb25JZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IG1vY2tBcGlDbGllbnQuY3VycmVudC5kZWxldGVTZXNzaW9uKHNlc3Npb25JZClcbiAgICAgIFxuICAgICAgc2V0U3RhdGUocHJldiA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1Nlc3Npb25zID0gcHJldi5zZXNzaW9ucy5maWx0ZXIocyA9PiBzLmlkICE9PSBzZXNzaW9uSWQpXG4gICAgICAgIGNvbnN0IG5ld0N1cnJlbnRTZXNzaW9uSWQgPSBwcmV2LmN1cnJlbnRTZXNzaW9uSWQgPT09IHNlc3Npb25JZCBcbiAgICAgICAgICA/IChuZXdTZXNzaW9uc1swXT8uaWQgPz8gbnVsbClcbiAgICAgICAgICA6IHByZXYuY3VycmVudFNlc3Npb25JZFxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGxvY2FsU3RvcmFnZVxuICAgICAgICBpZiAobmV3Q3VycmVudFNlc3Npb25JZCkge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZUy5zZXNzaW9uSWQsIG5ld0N1cnJlbnRTZXNzaW9uSWQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oU1RPUkFHRV9LRVlTLnNlc3Npb25JZClcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgIHNlc3Npb25zOiBuZXdTZXNzaW9ucyxcbiAgICAgICAgICBjdXJyZW50U2Vzc2lvbklkOiBuZXdDdXJyZW50U2Vzc2lvbklkXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgTW9ja0FQSUVycm9yIFxuICAgICAgICA/IG1vY2tBUElVdGlscy5mb3JtYXRFcnJvcihlcnJvcilcbiAgICAgICAgOiAnRmFpbGVkIHRvIGRlbGV0ZSBzZXNzaW9uJ1xuICAgICAgXG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7IC4uLnByZXYsIGVycm9yOiBlcnJvck1lc3NhZ2UgfSkpXG4gICAgfVxuICB9LCBbXSlcblxuICAvKipcbiAgICogU2VuZCBtZXNzYWdlXG4gICAqL1xuICBjb25zdCBzZW5kTWVzc2FnZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChjb250ZW50OiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXN0YXRlLmN1cnJlbnRTZXNzaW9uSWQpIHtcbiAgICAgIHNldFN0YXRlKHByZXYgPT4gKHsgLi4ucHJldiwgZXJyb3I6ICdObyBzZXNzaW9uIHNlbGVjdGVkJyB9KSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFByZXZlbnQgZG91YmxlIHN1Ym1pc3Npb25zIHdpdGggcmVmXG4gICAgaWYgKHNlbmRpbmdNZXNzYWdlUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdBbHJlYWR5IHNlbmRpbmcgbWVzc2FnZSwgaWdub3JpbmcgZHVwbGljYXRlIHJlcXVlc3QnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc2VuZGluZ01lc3NhZ2VSZWYuY3VycmVudCA9IHRydWVcbiAgICBzZXRTdGF0ZShwcmV2ID0+ICh7IC4uLnByZXYsIGVycm9yOiBudWxsLCBpc0xvYWRpbmc6IHRydWUgfSkpXG5cbiAgICAvLyBHZW5lcmF0ZSBhIHRlbXBvcmFyeSBtZXNzYWdlIElEIGZvciB0cmFja2luZ1xuICAgIGNvbnN0IHRlbXBNZXNzYWdlSWQgPSBgdGVtcC0ke0RhdGUubm93KCl9YFxuICAgIHNldEN1cnJlbnRNZXNzYWdlSWQodGVtcE1lc3NhZ2VJZClcblxuICAgIC8vIENyZWF0ZSB1c2VyIG1lc3NhZ2VcbiAgICBjb25zdCB1c2VyTWVzc2FnZTogT21pdDxNZXNzYWdlLCAnaWQnPiA9IHtcbiAgICAgIHNlc3Npb25JZDogc3RhdGUuY3VycmVudFNlc3Npb25JZCxcbiAgICAgIGNvbnRlbnQsXG4gICAgICB0eXBlOiAndXNlcicsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKClcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gU2F2ZSB1c2VyIG1lc3NhZ2VcbiAgICAgIGNvbnN0IHNhdmVkVXNlck1lc3NhZ2UgPSBhd2FpdCBtb2NrQXBpQ2xpZW50LmN1cnJlbnQuY3JlYXRlTWVzc2FnZSh1c2VyTWVzc2FnZSlcbiAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgdXNlciBtZXNzYWdlOicsIHNhdmVkVXNlck1lc3NhZ2UuaWQpXG4gICAgICBzZXRDdXJyZW50TWVzc2FnZXMocHJldiA9PiB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgbWVzc2FnZSBhbHJlYWR5IGV4aXN0cyB0byBwcmV2ZW50IGR1cGxpY2F0ZXNcbiAgICAgICAgY29uc3QgZXhpc3RzID0gcHJldi5zb21lKG1zZyA9PiBtc2cuaWQgPT09IHNhdmVkVXNlck1lc3NhZ2UuaWQpXG4gICAgICAgIGlmIChleGlzdHMpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNlciBtZXNzYWdlIGFscmVhZHkgZXhpc3RzLCBza2lwcGluZzonLCBzYXZlZFVzZXJNZXNzYWdlLmlkKVxuICAgICAgICAgIHJldHVybiBwcmV2XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coJ0FkZGluZyBuZXcgdXNlciBtZXNzYWdlIHRvIHN0YXRlOicsIHNhdmVkVXNlck1lc3NhZ2UuaWQpXG4gICAgICAgIHJldHVybiBbLi4ucHJldiwgc2F2ZWRVc2VyTWVzc2FnZV1cbiAgICAgIH0pXG5cbiAgICAgIC8vIFByZXBhcmUgbjhuIHJlcXVlc3Qgd2l0aCBtZXNzYWdlIElEIGZvciB0cmFja2luZ1xuICAgICAgY29uc3QgbjhuUmVxdWVzdDogTjhOUmVxdWVzdCA9IHtcbiAgICAgICAgdXNlcm5hbWU6ICd1c2VyJywgLy8gVGhpcyBjb3VsZCBjb21lIGZyb20gdXNlciBjb250ZXh0XG4gICAgICAgIG1lc3NhZ2U6IGNvbnRlbnQsXG4gICAgICAgIHNlc3Npb25JZDogc3RhdGUuY3VycmVudFNlc3Npb25JZCxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICBtZXNzYWdlSWQ6IHRlbXBNZXNzYWdlSWQgLy8gQWRkIHRoaXMgdG8gdHJhY2sgdGhpbmtpbmcgdXBkYXRlc1xuICAgICAgfVxuXG4gICAgICAvLyBTZW5kIHRvIG44blxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBuOG5DbGllbnQuY3VycmVudC5zZW5kTWVzc2FnZVdpdGhSZXRyeShuOG5SZXF1ZXN0KVxuXG4gICAgICAvLyBDcmVhdGUgYXNzaXN0YW50IG1lc3NhZ2VcbiAgICAgIGNvbnN0IGFzc2lzdGFudE1lc3NhZ2U6IE9taXQ8TWVzc2FnZSwgJ2lkJz4gPSB7XG4gICAgICAgIHNlc3Npb25JZDogc3RhdGUuY3VycmVudFNlc3Npb25JZCxcbiAgICAgICAgY29udGVudDogJycsIC8vIExlYXZlIGVtcHR5IC0gUmVzcG9uc2VSZW5kZXJlciB3aWxsIGhhbmRsZSBkaXNwbGF5XG4gICAgICAgIHR5cGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIHJlc3BvbnNlRGF0YToge1xuICAgICAgICAgIHR5cGU6IHJlc3BvbnNlLm1lc3NhZ2VUeXBlLFxuICAgICAgICAgIGNvbnRlbnQ6IHJlc3BvbnNlLmNvbnRlbnQsXG4gICAgICAgICAgbWV0YWRhdGE6IHJlc3BvbnNlLm1ldGFkYXRhXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU2F2ZSBhc3Npc3RhbnQgbWVzc2FnZVxuICAgICAgY29uc3Qgc2F2ZWRBc3Npc3RhbnRNZXNzYWdlID0gYXdhaXQgbW9ja0FwaUNsaWVudC5jdXJyZW50LmNyZWF0ZU1lc3NhZ2UoYXNzaXN0YW50TWVzc2FnZSlcbiAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgYXNzaXN0YW50IG1lc3NhZ2U6Jywgc2F2ZWRBc3Npc3RhbnRNZXNzYWdlLmlkKVxuICAgICAgc2V0Q3VycmVudE1lc3NhZ2VzKHByZXYgPT4ge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIG1lc3NhZ2UgYWxyZWFkeSBleGlzdHMgdG8gcHJldmVudCBkdXBsaWNhdGVzXG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IHByZXYuc29tZShtc2cgPT4gbXNnLmlkID09PSBzYXZlZEFzc2lzdGFudE1lc3NhZ2UuaWQpXG4gICAgICAgIGlmIChleGlzdHMpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQXNzaXN0YW50IG1lc3NhZ2UgYWxyZWFkeSBleGlzdHMsIHNraXBwaW5nOicsIHNhdmVkQXNzaXN0YW50TWVzc2FnZS5pZClcbiAgICAgICAgICByZXR1cm4gcHJldlxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgbmV3IGFzc2lzdGFudCBtZXNzYWdlIHRvIHN0YXRlOicsIHNhdmVkQXNzaXN0YW50TWVzc2FnZS5pZClcbiAgICAgICAgcmV0dXJuIFsuLi5wcmV2LCBzYXZlZEFzc2lzdGFudE1lc3NhZ2VdXG4gICAgICB9KVxuXG4gICAgICAvLyBVcGRhdGUgc2Vzc2lvbiBpbiBzdGF0ZVxuICAgICAgc2V0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBzZXNzaW9uczogcHJldi5zZXNzaW9ucy5tYXAoc2Vzc2lvbiA9PlxuICAgICAgICAgIHNlc3Npb24uaWQgPT09IHN0YXRlLmN1cnJlbnRTZXNzaW9uSWRcbiAgICAgICAgICAgID8geyAuLi5zZXNzaW9uLCBtZXRhZGF0YTogeyAuLi5zZXNzaW9uLm1ldGFkYXRhLCBtZXNzYWdlQ291bnQ6IHNlc3Npb24ubWV0YWRhdGEubWVzc2FnZUNvdW50ICsgMiB9IH1cbiAgICAgICAgICAgIDogc2Vzc2lvblxuICAgICAgICApXG4gICAgICB9KSlcblxuICAgICAgLy8gQ2xlYXIgbG9hZGluZyBzdGF0ZSBhbmQgbWVzc2FnZSBJRCBvbiBzdWNjZXNzXG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7IC4uLnByZXYsIGlzTG9hZGluZzogZmFsc2UgfSkpXG4gICAgICBzZXRDdXJyZW50TWVzc2FnZUlkKG51bGwpXG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBOOE5FcnJvciBcbiAgICAgICAgPyBuOG5VdGlscy5mb3JtYXRFcnJvcihlcnJvcilcbiAgICAgICAgOiAnRmFpbGVkIHRvIHNlbmQgbWVzc2FnZSdcbiAgICAgIFxuICAgICAgc2V0U3RhdGUocHJldiA9PiAoeyAuLi5wcmV2LCBlcnJvcjogZXJyb3JNZXNzYWdlLCBpc0xvYWRpbmc6IGZhbHNlIH0pKVxuICAgICAgc2V0Q3VycmVudE1lc3NhZ2VJZChudWxsKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBzZW5kaW5nTWVzc2FnZVJlZi5jdXJyZW50ID0gZmFsc2VcbiAgICB9XG4gIH0sIFtzdGF0ZS5jdXJyZW50U2Vzc2lvbklkXSlcblxuICAvKipcbiAgICogSGFuZGxlIHN0cmVhbWluZyBtZXNzYWdlc1xuICAgKi9cbiAgY29uc3QgaGFuZGxlU3RyZWFtaW5nID0gdXNlQ2FsbGJhY2soYXN5bmMgKHNlc3Npb25JZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgcmVzcG9uc2Ugb2YgbjhuQ2xpZW50LmN1cnJlbnQuc3RyZWFtTWVzc2FnZXMoc2Vzc2lvbklkKSkge1xuICAgICAgICBpZiAobjhuVXRpbHMuaXNJbnRlcmltTWVzc2FnZShyZXNwb25zZSkpIHtcbiAgICAgICAgICAvLyBDcmVhdGUgaW50ZXJpbSBtZXNzYWdlXG4gICAgICAgICAgY29uc3QgaW50ZXJpbU1lc3NhZ2U6IE9taXQ8TWVzc2FnZSwgJ2lkJz4gPSB7XG4gICAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgICBjb250ZW50OiB0eXBlb2YgcmVzcG9uc2UuY29udGVudCA9PT0gJ3N0cmluZycgPyByZXNwb25zZS5jb250ZW50IDogSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UuY29udGVudCksXG4gICAgICAgICAgICB0eXBlOiAnaW50ZXJpbScsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICByZXNwb25zZURhdGE6IHtcbiAgICAgICAgICAgICAgdHlwZTogcmVzcG9uc2UubWVzc2FnZVR5cGUsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IHJlc3BvbnNlLmNvbnRlbnQsXG4gICAgICAgICAgICAgIG1ldGFkYXRhOiByZXNwb25zZS5tZXRhZGF0YVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNhdmUgYW5kIGRpc3BsYXkgaW50ZXJpbSBtZXNzYWdlXG4gICAgICAgICAgY29uc3Qgc2F2ZWRJbnRlcmltTWVzc2FnZSA9IGF3YWl0IG1vY2tBcGlDbGllbnQuY3VycmVudC5jcmVhdGVNZXNzYWdlKGludGVyaW1NZXNzYWdlKVxuICAgICAgICAgIHNldEN1cnJlbnRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCBzYXZlZEludGVyaW1NZXNzYWdlXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdTdHJlYW1pbmcgZXJyb3I6JywgZXJyb3IpXG4gICAgfVxuICB9LCBbXSlcblxuICAvKipcbiAgICogUmV0cnkgZmFpbGVkIG1lc3NhZ2VcbiAgICovXG4gIGNvbnN0IHJldHJ5TWVzc2FnZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChtZXNzYWdlSWQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjdXJyZW50TWVzc2FnZXMuZmluZChtID0+IG0uaWQgPT09IG1lc3NhZ2VJZClcbiAgICBpZiAoIW1lc3NhZ2UgfHwgbWVzc2FnZS50eXBlICE9PSAndXNlcicpIHJldHVyblxuXG4gICAgYXdhaXQgc2VuZE1lc3NhZ2UobWVzc2FnZS5jb250ZW50KVxuICB9LCBbY3VycmVudE1lc3NhZ2VzLCBzZW5kTWVzc2FnZV0pXG5cbiAgLyoqXG4gICAqIFRvZ2dsZSBzaWRlYmFyXG4gICAqL1xuICBjb25zdCB0b2dnbGVTaWRlYmFyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldFN0YXRlKHByZXYgPT4ge1xuICAgICAgY29uc3QgbmV3Q29sbGFwc2VkID0gIXByZXYuc2lkZWJhckNvbGxhcHNlZFxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9LRVlTLnNpZGViYXJDb2xsYXBzZWQsIFN0cmluZyhuZXdDb2xsYXBzZWQpKVxuICAgICAgcmV0dXJuIHsgLi4ucHJldiwgc2lkZWJhckNvbGxhcHNlZDogbmV3Q29sbGFwc2VkIH1cbiAgICB9KVxuICB9LCBbXSlcblxuICAvKipcbiAgICogTG9hZCBzaWRlYmFyIHN0YXRlIGZyb20gbG9jYWxTdG9yYWdlXG4gICAqL1xuICBjb25zdCBsb2FkU2lkZWJhclN0YXRlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHNhdmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9LRVlTLnNpZGViYXJDb2xsYXBzZWQpXG4gICAgaWYgKHNhdmVkKSB7XG4gICAgICBzZXRTdGF0ZShwcmV2ID0+ICh7IC4uLnByZXYsIHNpZGViYXJDb2xsYXBzZWQ6IHNhdmVkID09PSAndHJ1ZScgfSkpXG4gICAgfVxuICB9LCBbXSlcblxuICAvKipcbiAgICogQ2xlYXIgZXJyb3JcbiAgICovXG4gIGNvbnN0IGNsZWFyRXJyb3IgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0U3RhdGUocHJldiA9PiAoeyAuLi5wcmV2LCBlcnJvcjogbnVsbCB9KSlcbiAgfSwgW10pXG5cbiAgY29uc3QgdmFsdWU6IENoYXRDb250ZXh0VHlwZSA9IHtcbiAgICBzdGF0ZSxcbiAgICBjdXJyZW50TWVzc2FnZXMsXG4gICAgY3VycmVudE1lc3NhZ2VJZCxcbiAgICBjcmVhdGVTZXNzaW9uLFxuICAgIHNlbGVjdFNlc3Npb24sXG4gICAgcmVuYW1lU2Vzc2lvbixcbiAgICBkZWxldGVTZXNzaW9uLFxuICAgIHNlbmRNZXNzYWdlLFxuICAgIHJldHJ5TWVzc2FnZSxcbiAgICB0b2dnbGVTaWRlYmFyLFxuICAgIGNsZWFyRXJyb3JcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPENoYXRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt2YWx1ZX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9DaGF0Q29udGV4dC5Qcm92aWRlcj5cbiAgKVxufSJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZVJlZiIsImNyZWF0ZU44TkNsaWVudCIsIk44TkVycm9yIiwibjhuVXRpbHMiLCJjcmVhdGVNb2NrQVBJQ2xpZW50IiwiTW9ja0FQSUVycm9yIiwibW9ja0FQSVV0aWxzIiwiQVBJX0NPTkZJRyIsIlNUT1JBR0VfS0VZUyIsIkNoYXRDb250ZXh0IiwidW5kZWZpbmVkIiwidXNlQ2hhdCIsImNvbnRleHQiLCJFcnJvciIsIkNoYXRQcm92aWRlciIsImNoaWxkcmVuIiwibjhuQ2xpZW50Iiwid2ViaG9va1VybCIsIm44biIsInN0cmVhbWluZ1VybCIsInRpbWVvdXQiLCJyZXRyeUF0dGVtcHRzIiwicmV0cnlEZWxheSIsIm1vY2tBcGlDbGllbnQiLCJiYXNlVXJsIiwibW9ja0FwaSIsInByb2plY3RJZCIsInN0YXRlIiwic2V0U3RhdGUiLCJzZXNzaW9ucyIsImN1cnJlbnRTZXNzaW9uSWQiLCJpc0xvYWRpbmciLCJlcnJvciIsInNpZGViYXJDb2xsYXBzZWQiLCJ0aGVtZSIsImN1cnJlbnRNZXNzYWdlcyIsInNldEN1cnJlbnRNZXNzYWdlcyIsInN0cmVhbWluZ01lc3NhZ2VJZCIsInNldFN0cmVhbWluZ01lc3NhZ2VJZCIsImN1cnJlbnRNZXNzYWdlSWQiLCJzZXRDdXJyZW50TWVzc2FnZUlkIiwic2VuZGluZ01lc3NhZ2VSZWYiLCJsb2FkU2Vzc2lvbnMiLCJsb2FkU2lkZWJhclN0YXRlIiwibG9hZE1lc3NhZ2VzIiwicHJldiIsImN1cnJlbnQiLCJnZXRTZXNzaW9ucyIsInNhdmVkU2Vzc2lvbklkIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInNlc3Npb25JZCIsImZpbmQiLCJzIiwiaWQiLCJlcnJvck1lc3NhZ2UiLCJmb3JtYXRFcnJvciIsInNlc3Npb25NZXNzYWdlcyIsImdldE1lc3NhZ2VzIiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsIm1hcCIsIm0iLCJjcmVhdGVTZXNzaW9uIiwibmFtZSIsInNlc3Npb25OYW1lIiwiRGF0ZSIsInRvTG9jYWxlU3RyaW5nIiwic2Vzc2lvbiIsInNldEl0ZW0iLCJzZWxlY3RTZXNzaW9uIiwidXBkYXRlU2Vzc2lvbkFjdGl2aXR5IiwicmVuYW1lU2Vzc2lvbiIsIm5ld05hbWUiLCJ2YWxpZGF0aW9uRXJyb3IiLCJ2YWxpZGF0ZVNlc3Npb25OYW1lIiwidXBkYXRlZFNlc3Npb24iLCJ1cGRhdGVTZXNzaW9uIiwiZGVsZXRlU2Vzc2lvbiIsIm5ld1Nlc3Npb25zIiwiZmlsdGVyIiwibmV3Q3VycmVudFNlc3Npb25JZCIsInJlbW92ZUl0ZW0iLCJzZW5kTWVzc2FnZSIsImNvbnRlbnQiLCJ0ZW1wTWVzc2FnZUlkIiwibm93IiwidXNlck1lc3NhZ2UiLCJ0eXBlIiwidGltZXN0YW1wIiwic2F2ZWRVc2VyTWVzc2FnZSIsImNyZWF0ZU1lc3NhZ2UiLCJleGlzdHMiLCJzb21lIiwibXNnIiwibjhuUmVxdWVzdCIsInVzZXJuYW1lIiwibWVzc2FnZSIsIm1lc3NhZ2VJZCIsInJlc3BvbnNlIiwic2VuZE1lc3NhZ2VXaXRoUmV0cnkiLCJhc3Npc3RhbnRNZXNzYWdlIiwicmVzcG9uc2VEYXRhIiwibWVzc2FnZVR5cGUiLCJtZXRhZGF0YSIsInNhdmVkQXNzaXN0YW50TWVzc2FnZSIsIm1lc3NhZ2VDb3VudCIsImhhbmRsZVN0cmVhbWluZyIsInN0cmVhbU1lc3NhZ2VzIiwiaXNJbnRlcmltTWVzc2FnZSIsImludGVyaW1NZXNzYWdlIiwiSlNPTiIsInN0cmluZ2lmeSIsInNhdmVkSW50ZXJpbU1lc3NhZ2UiLCJyZXRyeU1lc3NhZ2UiLCJ0b2dnbGVTaWRlYmFyIiwibmV3Q29sbGFwc2VkIiwiU3RyaW5nIiwic2F2ZWQiLCJjbGVhckVycm9yIiwidmFsdWUiLCJQcm92aWRlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./context/ChatContext.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./context/ThemeContext.tsx":
/*!**********************************!*\
  !*** ./context/ThemeContext.tsx ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ThemeProvider: () => (/* binding */ ThemeProvider),\n/* harmony export */   useTheme: () => (/* binding */ useTheme)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/constants */ \"(app-pages-browser)/./lib/constants.ts\");\n/* __next_internal_client_entry_do_not_use__ useTheme,ThemeProvider auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst ThemeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nfunction useTheme() {\n    _s();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ThemeContext);\n    if (!context) {\n        throw new Error('useTheme must be used within a ThemeProvider');\n    }\n    return context;\n}\n_s(useTheme, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nfunction ThemeProvider(param) {\n    let { children, defaultTheme = _lib_constants__WEBPACK_IMPORTED_MODULE_2__.UI_CONFIG.theme.defaultTheme } = param;\n    _s1();\n    const [theme, setThemeState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(defaultTheme);\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ThemeProvider.useEffect\": ()=>{\n            setMounted(true);\n            // Load theme from localStorage\n            const savedTheme = localStorage.getItem(_lib_constants__WEBPACK_IMPORTED_MODULE_2__.STORAGE_KEYS.theme);\n            if (savedTheme && (savedTheme === 'light' || savedTheme === 'dark')) {\n                setThemeState(savedTheme);\n            } else {\n                // Check system preference\n                if (window.matchMedia('(prefers-color-scheme: dark)').matches) {\n                    setThemeState('dark');\n                }\n            }\n        }\n    }[\"ThemeProvider.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ThemeProvider.useEffect\": ()=>{\n            if (!mounted) return;\n            const root = window.document.documentElement;\n            root.classList.remove('light', 'dark');\n            root.classList.add(theme);\n            // Save to localStorage\n            localStorage.setItem(_lib_constants__WEBPACK_IMPORTED_MODULE_2__.STORAGE_KEYS.theme, theme);\n        }\n    }[\"ThemeProvider.useEffect\"], [\n        theme,\n        mounted\n    ]);\n    const toggleTheme = ()=>{\n        setThemeState((prev)=>prev === 'light' ? 'dark' : 'light');\n    };\n    const setTheme = (newTheme)=>{\n        setThemeState(newTheme);\n    };\n    // Prevent flash of unstyled content\n    if (!mounted) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ThemeContext.Provider, {\n        value: {\n            theme,\n            toggleTheme,\n            setTheme\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Ebttikar Intelligence Projects\\\\Test-Chat-App\\\\context\\\\ThemeContext.tsx\",\n        lineNumber: 72,\n        columnNumber: 5\n    }, this);\n}\n_s1(ThemeProvider, \"VWBRAFqA9nY/1CsqzTyaWLX2gqE=\");\n_c = ThemeProvider;\nvar _c;\n$RefreshReg$(_c, \"ThemeProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbnRleHQvVGhlbWVDb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUU2RTtBQUVwQjtBQVF6RCxNQUFNTyw2QkFBZU4sb0RBQWFBLENBQStCTztBQUUxRCxTQUFTQzs7SUFDZCxNQUFNQyxVQUFVUixpREFBVUEsQ0FBQ0s7SUFDM0IsSUFBSSxDQUFDRyxTQUFTO1FBQ1osTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBQ0EsT0FBT0Q7QUFDVDtHQU5nQkQ7QUFhVCxTQUFTRyxjQUFjLEtBQTZFO1FBQTdFLEVBQUVDLFFBQVEsRUFBRUMsZUFBZVQscURBQVNBLENBQUNVLEtBQUssQ0FBQ0QsWUFBWSxFQUFzQixHQUE3RTs7SUFDNUIsTUFBTSxDQUFDQyxPQUFPQyxjQUFjLEdBQUdaLCtDQUFRQSxDQUFRVTtJQUMvQyxNQUFNLENBQUNHLFNBQVNDLFdBQVcsR0FBR2QsK0NBQVFBLENBQUM7SUFFdkNELGdEQUFTQTttQ0FBQztZQUNSZSxXQUFXO1lBRVgsK0JBQStCO1lBQy9CLE1BQU1DLGFBQWFDLGFBQWFDLE9BQU8sQ0FBQ2Ysd0RBQVlBLENBQUNTLEtBQUs7WUFDMUQsSUFBSUksY0FBZUEsQ0FBQUEsZUFBZSxXQUFXQSxlQUFlLE1BQUssR0FBSTtnQkFDbkVILGNBQWNHO1lBQ2hCLE9BQU87Z0JBQ0wsMEJBQTBCO2dCQUMxQixJQUFJRyxPQUFPQyxVQUFVLENBQUMsZ0NBQWdDQyxPQUFPLEVBQUU7b0JBQzdEUixjQUFjO2dCQUNoQjtZQUNGO1FBQ0Y7a0NBQUcsRUFBRTtJQUVMYixnREFBU0E7bUNBQUM7WUFDUixJQUFJLENBQUNjLFNBQVM7WUFFZCxNQUFNUSxPQUFPSCxPQUFPSSxRQUFRLENBQUNDLGVBQWU7WUFDNUNGLEtBQUtHLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDLFNBQVM7WUFDL0JKLEtBQUtHLFNBQVMsQ0FBQ0UsR0FBRyxDQUFDZjtZQUVuQix1QkFBdUI7WUFDdkJLLGFBQWFXLE9BQU8sQ0FBQ3pCLHdEQUFZQSxDQUFDUyxLQUFLLEVBQUVBO1FBQzNDO2tDQUFHO1FBQUNBO1FBQU9FO0tBQVE7SUFFbkIsTUFBTWUsY0FBYztRQUNsQmhCLGNBQWNpQixDQUFBQSxPQUFRQSxTQUFTLFVBQVUsU0FBUztJQUNwRDtJQUVBLE1BQU1DLFdBQVcsQ0FBQ0M7UUFDaEJuQixjQUFjbUI7SUFDaEI7SUFFQSxvQ0FBb0M7SUFDcEMsSUFBSSxDQUFDbEIsU0FBUztRQUNaLE9BQU87SUFDVDtJQUVBLHFCQUNFLDhEQUFDVixhQUFhNkIsUUFBUTtRQUFDQyxPQUFPO1lBQUV0QjtZQUFPaUI7WUFBYUU7UUFBUztrQkFDMURyQjs7Ozs7O0FBR1A7SUFoRGdCRDtLQUFBQSIsInNvdXJjZXMiOlsiQzpcXEVidHRpa2FyIEludGVsbGlnZW5jZSBQcm9qZWN0c1xcVGVzdC1DaGF0LUFwcFxcY29udGV4dFxcVGhlbWVDb250ZXh0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFRoZW1lIH0gZnJvbSAnQC90eXBlcydcbmltcG9ydCB7IFVJX0NPTkZJRywgU1RPUkFHRV9LRVlTIH0gZnJvbSAnQC9saWIvY29uc3RhbnRzJ1xuXG5pbnRlcmZhY2UgVGhlbWVDb250ZXh0VHlwZSB7XG4gIHRoZW1lOiBUaGVtZVxuICB0b2dnbGVUaGVtZTogKCkgPT4gdm9pZFxuICBzZXRUaGVtZTogKHRoZW1lOiBUaGVtZSkgPT4gdm9pZFxufVxuXG5jb25zdCBUaGVtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFRoZW1lQ29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZClcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRoZW1lKCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChUaGVtZUNvbnRleHQpXG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlVGhlbWUgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFRoZW1lUHJvdmlkZXInKVxuICB9XG4gIHJldHVybiBjb250ZXh0XG59XG5cbmludGVyZmFjZSBUaGVtZVByb3ZpZGVyUHJvcHMge1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG4gIGRlZmF1bHRUaGVtZT86IFRoZW1lXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBUaGVtZVByb3ZpZGVyKHsgY2hpbGRyZW4sIGRlZmF1bHRUaGVtZSA9IFVJX0NPTkZJRy50aGVtZS5kZWZhdWx0VGhlbWUgfTogVGhlbWVQcm92aWRlclByb3BzKSB7XG4gIGNvbnN0IFt0aGVtZSwgc2V0VGhlbWVTdGF0ZV0gPSB1c2VTdGF0ZTxUaGVtZT4oZGVmYXVsdFRoZW1lKVxuICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSB1c2VTdGF0ZShmYWxzZSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldE1vdW50ZWQodHJ1ZSlcbiAgICBcbiAgICAvLyBMb2FkIHRoZW1lIGZyb20gbG9jYWxTdG9yYWdlXG4gICAgY29uc3Qgc2F2ZWRUaGVtZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0VfS0VZUy50aGVtZSkgYXMgVGhlbWUgfCBudWxsXG4gICAgaWYgKHNhdmVkVGhlbWUgJiYgKHNhdmVkVGhlbWUgPT09ICdsaWdodCcgfHwgc2F2ZWRUaGVtZSA9PT0gJ2RhcmsnKSkge1xuICAgICAgc2V0VGhlbWVTdGF0ZShzYXZlZFRoZW1lKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDaGVjayBzeXN0ZW0gcHJlZmVyZW5jZVxuICAgICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKCcocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspJykubWF0Y2hlcykge1xuICAgICAgICBzZXRUaGVtZVN0YXRlKCdkYXJrJylcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtb3VudGVkKSByZXR1cm5cblxuICAgIGNvbnN0IHJvb3QgPSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XG4gICAgcm9vdC5jbGFzc0xpc3QucmVtb3ZlKCdsaWdodCcsICdkYXJrJylcbiAgICByb290LmNsYXNzTGlzdC5hZGQodGhlbWUpXG5cbiAgICAvLyBTYXZlIHRvIGxvY2FsU3RvcmFnZVxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZUy50aGVtZSwgdGhlbWUpXG4gIH0sIFt0aGVtZSwgbW91bnRlZF0pXG5cbiAgY29uc3QgdG9nZ2xlVGhlbWUgPSAoKSA9PiB7XG4gICAgc2V0VGhlbWVTdGF0ZShwcmV2ID0+IHByZXYgPT09ICdsaWdodCcgPyAnZGFyaycgOiAnbGlnaHQnKVxuICB9XG5cbiAgY29uc3Qgc2V0VGhlbWUgPSAobmV3VGhlbWU6IFRoZW1lKSA9PiB7XG4gICAgc2V0VGhlbWVTdGF0ZShuZXdUaGVtZSlcbiAgfVxuXG4gIC8vIFByZXZlbnQgZmxhc2ggb2YgdW5zdHlsZWQgY29udGVudFxuICBpZiAoIW1vdW50ZWQpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8VGhlbWVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7IHRoZW1lLCB0b2dnbGVUaGVtZSwgc2V0VGhlbWUgfX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9UaGVtZUNvbnRleHQuUHJvdmlkZXI+XG4gIClcbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiVUlfQ09ORklHIiwiU1RPUkFHRV9LRVlTIiwiVGhlbWVDb250ZXh0IiwidW5kZWZpbmVkIiwidXNlVGhlbWUiLCJjb250ZXh0IiwiRXJyb3IiLCJUaGVtZVByb3ZpZGVyIiwiY2hpbGRyZW4iLCJkZWZhdWx0VGhlbWUiLCJ0aGVtZSIsInNldFRoZW1lU3RhdGUiLCJtb3VudGVkIiwic2V0TW91bnRlZCIsInNhdmVkVGhlbWUiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwid2luZG93IiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJyb290IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGFzc0xpc3QiLCJyZW1vdmUiLCJhZGQiLCJzZXRJdGVtIiwidG9nZ2xlVGhlbWUiLCJwcmV2Iiwic2V0VGhlbWUiLCJuZXdUaGVtZSIsIlByb3ZpZGVyIiwidmFsdWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./context/ThemeContext.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/constants.ts":
/*!**************************!*\
  !*** ./lib/constants.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API_CONFIG: () => (/* binding */ API_CONFIG),\n/* harmony export */   APP_CONFIG: () => (/* binding */ APP_CONFIG),\n/* harmony export */   COLORS: () => (/* binding */ COLORS),\n/* harmony export */   ERROR_MESSAGES: () => (/* binding */ ERROR_MESSAGES),\n/* harmony export */   KEYBOARD_SHORTCUTS: () => (/* binding */ KEYBOARD_SHORTCUTS),\n/* harmony export */   STORAGE_KEYS: () => (/* binding */ STORAGE_KEYS),\n/* harmony export */   UI_CONFIG: () => (/* binding */ UI_CONFIG),\n/* harmony export */   VALIDATION_RULES: () => (/* binding */ VALIDATION_RULES)\n/* harmony export */ });\nconst APP_CONFIG = {\n    name: 'Chat Application',\n    version: '1.0.0',\n    description: 'Modern chat application with n8n workflow integration'\n};\nconst API_CONFIG = {\n    n8n: {\n        webhookUrl: \"https://n8n.srv824867.hstgr.cloud/webhook/chat-app-mock\" || 0,\n        streamingUrl: \"https://n8n.srv824867.hstgr.cloud/webhook/chat-app-mock\" || 0,\n        timeout: 30000,\n        retryAttempts: 3,\n        retryDelay: 1000\n    },\n    mockApi: {\n        baseUrl: \"https://mockapi.io/api/v1\" || 0,\n        projectId: \"your-project-id\" || 0,\n        timeout: 10000\n    }\n};\nconst UI_CONFIG = {\n    sidebar: {\n        width: 280,\n        collapsedWidth: 64,\n        animationDuration: 200\n    },\n    chat: {\n        maxMessageLength: 4000,\n        typingIndicatorDelay: 500,\n        messageRetryAttempts: 3\n    },\n    theme: {\n        defaultTheme: 'light',\n        storageKey: 'chat-theme'\n    }\n};\nconst COLORS = {\n    earth: {\n        sand: '#f5f0e1',\n        clay: '#daa578',\n        moss: '#4c6f4a',\n        stone: '#a69b8e',\n        bark: '#654321'\n    },\n    semantic: {\n        success: '#22c55e',\n        warning: '#f59e0b',\n        error: '#ef4444',\n        info: '#3b82f6'\n    }\n};\nconst KEYBOARD_SHORTCUTS = {\n    newSession: 'mod+n',\n    search: 'mod+k',\n    toggleSidebar: 'mod+\\\\',\n    toggleTheme: 'mod+shift+t',\n    sendMessage: 'enter',\n    newLine: 'shift+enter'\n};\nconst VALIDATION_RULES = {\n    session: {\n        nameMaxLength: 100,\n        nameMinLength: 1\n    },\n    message: {\n        contentMaxLength: 4000,\n        contentMinLength: 1\n    }\n};\nconst ERROR_MESSAGES = {\n    network: 'Network connection failed. Please check your internet connection.',\n    timeout: 'Request timed out. Please try again.',\n    server: 'Server error occurred. Please try again later.',\n    validation: 'Invalid input. Please check your data.',\n    notFound: 'Resource not found.',\n    rateLimit: 'Too many requests. Please wait and try again.',\n    unknown: 'An unexpected error occurred. Please try again.'\n};\nconst STORAGE_KEYS = {\n    theme: 'chat-theme',\n    sessionId: 'current-session-id',\n    sidebarCollapsed: 'sidebar-collapsed'\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9jb25zdGFudHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBTyxNQUFNQSxhQUFhO0lBQ3hCQyxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsYUFBYTtBQUNmLEVBQVc7QUFFSixNQUFNQyxhQUFhO0lBQ3hCQyxLQUFLO1FBQ0hDLFlBQVlDLHlEQUF1QyxJQUFJLENBQTRDO1FBQ25HRyxjQUFjSCx5REFBeUMsSUFBSSxDQUE4QztRQUN6R0ssU0FBUztRQUNUQyxlQUFlO1FBQ2ZDLFlBQVk7SUFDZDtJQUNBQyxTQUFTO1FBQ1BDLFNBQVNULDJCQUF3QyxJQUFJLENBQTJCO1FBQ2hGVyxXQUFXWCxpQkFBMEMsSUFBSSxDQUFpQjtRQUMxRUssU0FBUztJQUNYO0FBQ0YsRUFBVztBQUVKLE1BQU1RLFlBQVk7SUFDdkJDLFNBQVM7UUFDUEMsT0FBTztRQUNQQyxnQkFBZ0I7UUFDaEJDLG1CQUFtQjtJQUNyQjtJQUNBQyxNQUFNO1FBQ0pDLGtCQUFrQjtRQUNsQkMsc0JBQXNCO1FBQ3RCQyxzQkFBc0I7SUFDeEI7SUFDQUMsT0FBTztRQUNMQyxjQUFjO1FBQ2RDLFlBQVk7SUFDZDtBQUNGLEVBQVc7QUFFSixNQUFNQyxTQUFTO0lBQ3BCQyxPQUFPO1FBQ0xDLE1BQU07UUFDTkMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsTUFBTTtJQUNSO0lBQ0FDLFVBQVU7UUFDUkMsU0FBUztRQUNUQyxTQUFTO1FBQ1RDLE9BQU87UUFDUEMsTUFBTTtJQUNSO0FBQ0YsRUFBVztBQUVKLE1BQU1DLHFCQUFxQjtJQUNoQ0MsWUFBWTtJQUNaQyxRQUFRO0lBQ1JDLGVBQWU7SUFDZkMsYUFBYTtJQUNiQyxhQUFhO0lBQ2JDLFNBQVM7QUFDWCxFQUFXO0FBRUosTUFBTUMsbUJBQW1CO0lBQzlCQyxTQUFTO1FBQ1BDLGVBQWU7UUFDZkMsZUFBZTtJQUNqQjtJQUNBQyxTQUFTO1FBQ1BDLGtCQUFrQjtRQUNsQkMsa0JBQWtCO0lBQ3BCO0FBQ0YsRUFBVztBQUVKLE1BQU1DLGlCQUFpQjtJQUM1QkMsU0FBUztJQUNUL0MsU0FBUztJQUNUZ0QsUUFBUTtJQUNSQyxZQUFZO0lBQ1pDLFVBQVU7SUFDVkMsV0FBVztJQUNYQyxTQUFTO0FBQ1gsRUFBVztBQUVKLE1BQU1DLGVBQWU7SUFDMUJwQyxPQUFPO0lBQ1BxQyxXQUFXO0lBQ1hDLGtCQUFrQjtBQUNwQixFQUFXIiwic291cmNlcyI6WyJDOlxcRWJ0dGlrYXIgSW50ZWxsaWdlbmNlIFByb2plY3RzXFxUZXN0LUNoYXQtQXBwXFxsaWJcXGNvbnN0YW50cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgQVBQX0NPTkZJRyA9IHtcbiAgbmFtZTogJ0NoYXQgQXBwbGljYXRpb24nLFxuICB2ZXJzaW9uOiAnMS4wLjAnLFxuICBkZXNjcmlwdGlvbjogJ01vZGVybiBjaGF0IGFwcGxpY2F0aW9uIHdpdGggbjhuIHdvcmtmbG93IGludGVncmF0aW9uJyxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBBUElfQ09ORklHID0ge1xuICBuOG46IHtcbiAgICB3ZWJob29rVXJsOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19OOE5fV0VCSE9PS19VUkwgfHwgJ2h0dHBzOi8veW91ci1uOG4taW5zdGFuY2UuY29tL3dlYmhvb2svY2hhdCcsXG4gICAgc3RyZWFtaW5nVXJsOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19OOE5fU1RSRUFNSU5HX1VSTCB8fCAnaHR0cHM6Ly95b3VyLW44bi1pbnN0YW5jZS5jb20vd2ViaG9vay9zdHJlYW0nLFxuICAgIHRpbWVvdXQ6IDMwMDAwLFxuICAgIHJldHJ5QXR0ZW1wdHM6IDMsXG4gICAgcmV0cnlEZWxheTogMTAwMCxcbiAgfSxcbiAgbW9ja0FwaToge1xuICAgIGJhc2VVcmw6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX01PQ0tBUElfQkFTRV9VUkwgfHwgJ2h0dHBzOi8vbW9ja2FwaS5pby9hcGkvdjEnLFxuICAgIHByb2plY3RJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTU9DS0FQSV9QUk9KRUNUX0lEIHx8ICd5b3VyLXByb2plY3QtaWQnLFxuICAgIHRpbWVvdXQ6IDEwMDAwLFxuICB9LFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IFVJX0NPTkZJRyA9IHtcbiAgc2lkZWJhcjoge1xuICAgIHdpZHRoOiAyODAsXG4gICAgY29sbGFwc2VkV2lkdGg6IDY0LFxuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAyMDAsXG4gIH0sXG4gIGNoYXQ6IHtcbiAgICBtYXhNZXNzYWdlTGVuZ3RoOiA0MDAwLFxuICAgIHR5cGluZ0luZGljYXRvckRlbGF5OiA1MDAsXG4gICAgbWVzc2FnZVJldHJ5QXR0ZW1wdHM6IDMsXG4gIH0sXG4gIHRoZW1lOiB7XG4gICAgZGVmYXVsdFRoZW1lOiAnbGlnaHQnIGFzIGNvbnN0LFxuICAgIHN0b3JhZ2VLZXk6ICdjaGF0LXRoZW1lJyxcbiAgfSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBDT0xPUlMgPSB7XG4gIGVhcnRoOiB7XG4gICAgc2FuZDogJyNmNWYwZTEnLFxuICAgIGNsYXk6ICcjZGFhNTc4JyxcbiAgICBtb3NzOiAnIzRjNmY0YScsXG4gICAgc3RvbmU6ICcjYTY5YjhlJyxcbiAgICBiYXJrOiAnIzY1NDMyMScsXG4gIH0sXG4gIHNlbWFudGljOiB7XG4gICAgc3VjY2VzczogJyMyMmM1NWUnLFxuICAgIHdhcm5pbmc6ICcjZjU5ZTBiJyxcbiAgICBlcnJvcjogJyNlZjQ0NDQnLFxuICAgIGluZm86ICcjM2I4MmY2JyxcbiAgfSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBLRVlCT0FSRF9TSE9SVENVVFMgPSB7XG4gIG5ld1Nlc3Npb246ICdtb2QrbicsXG4gIHNlYXJjaDogJ21vZCtrJyxcbiAgdG9nZ2xlU2lkZWJhcjogJ21vZCtcXFxcJyxcbiAgdG9nZ2xlVGhlbWU6ICdtb2Qrc2hpZnQrdCcsXG4gIHNlbmRNZXNzYWdlOiAnZW50ZXInLFxuICBuZXdMaW5lOiAnc2hpZnQrZW50ZXInLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IFZBTElEQVRJT05fUlVMRVMgPSB7XG4gIHNlc3Npb246IHtcbiAgICBuYW1lTWF4TGVuZ3RoOiAxMDAsXG4gICAgbmFtZU1pbkxlbmd0aDogMSxcbiAgfSxcbiAgbWVzc2FnZToge1xuICAgIGNvbnRlbnRNYXhMZW5ndGg6IDQwMDAsXG4gICAgY29udGVudE1pbkxlbmd0aDogMSxcbiAgfSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBFUlJPUl9NRVNTQUdFUyA9IHtcbiAgbmV0d29yazogJ05ldHdvcmsgY29ubmVjdGlvbiBmYWlsZWQuIFBsZWFzZSBjaGVjayB5b3VyIGludGVybmV0IGNvbm5lY3Rpb24uJyxcbiAgdGltZW91dDogJ1JlcXVlc3QgdGltZWQgb3V0LiBQbGVhc2UgdHJ5IGFnYWluLicsXG4gIHNlcnZlcjogJ1NlcnZlciBlcnJvciBvY2N1cnJlZC4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci4nLFxuICB2YWxpZGF0aW9uOiAnSW52YWxpZCBpbnB1dC4gUGxlYXNlIGNoZWNrIHlvdXIgZGF0YS4nLFxuICBub3RGb3VuZDogJ1Jlc291cmNlIG5vdCBmb3VuZC4nLFxuICByYXRlTGltaXQ6ICdUb28gbWFueSByZXF1ZXN0cy4gUGxlYXNlIHdhaXQgYW5kIHRyeSBhZ2Fpbi4nLFxuICB1bmtub3duOiAnQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZC4gUGxlYXNlIHRyeSBhZ2Fpbi4nLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IFNUT1JBR0VfS0VZUyA9IHtcbiAgdGhlbWU6ICdjaGF0LXRoZW1lJyxcbiAgc2Vzc2lvbklkOiAnY3VycmVudC1zZXNzaW9uLWlkJyxcbiAgc2lkZWJhckNvbGxhcHNlZDogJ3NpZGViYXItY29sbGFwc2VkJyxcbn0gYXMgY29uc3Q7Il0sIm5hbWVzIjpbIkFQUF9DT05GSUciLCJuYW1lIiwidmVyc2lvbiIsImRlc2NyaXB0aW9uIiwiQVBJX0NPTkZJRyIsIm44biIsIndlYmhvb2tVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfTjhOX1dFQkhPT0tfVVJMIiwic3RyZWFtaW5nVXJsIiwiTkVYVF9QVUJMSUNfTjhOX1NUUkVBTUlOR19VUkwiLCJ0aW1lb3V0IiwicmV0cnlBdHRlbXB0cyIsInJldHJ5RGVsYXkiLCJtb2NrQXBpIiwiYmFzZVVybCIsIk5FWFRfUFVCTElDX01PQ0tBUElfQkFTRV9VUkwiLCJwcm9qZWN0SWQiLCJORVhUX1BVQkxJQ19NT0NLQVBJX1BST0pFQ1RfSUQiLCJVSV9DT05GSUciLCJzaWRlYmFyIiwid2lkdGgiLCJjb2xsYXBzZWRXaWR0aCIsImFuaW1hdGlvbkR1cmF0aW9uIiwiY2hhdCIsIm1heE1lc3NhZ2VMZW5ndGgiLCJ0eXBpbmdJbmRpY2F0b3JEZWxheSIsIm1lc3NhZ2VSZXRyeUF0dGVtcHRzIiwidGhlbWUiLCJkZWZhdWx0VGhlbWUiLCJzdG9yYWdlS2V5IiwiQ09MT1JTIiwiZWFydGgiLCJzYW5kIiwiY2xheSIsIm1vc3MiLCJzdG9uZSIsImJhcmsiLCJzZW1hbnRpYyIsInN1Y2Nlc3MiLCJ3YXJuaW5nIiwiZXJyb3IiLCJpbmZvIiwiS0VZQk9BUkRfU0hPUlRDVVRTIiwibmV3U2Vzc2lvbiIsInNlYXJjaCIsInRvZ2dsZVNpZGViYXIiLCJ0b2dnbGVUaGVtZSIsInNlbmRNZXNzYWdlIiwibmV3TGluZSIsIlZBTElEQVRJT05fUlVMRVMiLCJzZXNzaW9uIiwibmFtZU1heExlbmd0aCIsIm5hbWVNaW5MZW5ndGgiLCJtZXNzYWdlIiwiY29udGVudE1heExlbmd0aCIsImNvbnRlbnRNaW5MZW5ndGgiLCJFUlJPUl9NRVNTQUdFUyIsIm5ldHdvcmsiLCJzZXJ2ZXIiLCJ2YWxpZGF0aW9uIiwibm90Rm91bmQiLCJyYXRlTGltaXQiLCJ1bmtub3duIiwiU1RPUkFHRV9LRVlTIiwic2Vzc2lvbklkIiwic2lkZWJhckNvbGxhcHNlZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/constants.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/mockapi-client.ts":
/*!*******************************!*\
  !*** ./lib/mockapi-client.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MockAPIClient: () => (/* binding */ MockAPIClient),\n/* harmony export */   MockAPIError: () => (/* binding */ MockAPIError),\n/* harmony export */   createMockAPIClient: () => (/* binding */ createMockAPIClient),\n/* harmony export */   mockAPIUtils: () => (/* binding */ mockAPIUtils),\n/* harmony export */   useMockAPIClient: () => (/* binding */ useMockAPIClient)\n/* harmony export */ });\n/**\n * MockAPI Client with localStorage fallback\n * Handles session and message persistence using MockAPI service or localStorage\n */ class MockAPIError extends Error {\n    constructor(message, status, details){\n        super(message), this.status = status, this.details = details;\n        this.name = 'MockAPIError';\n    }\n}\n// LocalStorage fallback implementation\nclass LocalStorageMockAPIClient {\n    generateId() {\n        return Date.now().toString(36) + Math.random().toString(36).substr(2);\n    }\n    getStorageData(key) {\n        if (false) {}\n        try {\n            const data = localStorage.getItem(key);\n            return data ? JSON.parse(data) : [];\n        } catch (e) {\n            return [];\n        }\n    }\n    setStorageData(key, data) {\n        if (false) {}\n        try {\n            localStorage.setItem(key, JSON.stringify(data));\n        } catch (error) {\n            console.error('Failed to save to localStorage:', error);\n        }\n    }\n    // Session Management\n    async getSessions() {\n        const sessions = this.getStorageData(this.SESSIONS_KEY);\n        return sessions.map(this.transformSession);\n    }\n    async getSession(id) {\n        const sessions = this.getStorageData(this.SESSIONS_KEY);\n        const session = sessions.find((s)=>s.id === id);\n        return session ? this.transformSession(session) : null;\n    }\n    async createSession(name) {\n        const now = new Date().toISOString();\n        const sessionData = {\n            id: this.generateId(),\n            name,\n            createdAt: now,\n            updatedAt: now,\n            messageCount: 0,\n            lastActivity: now,\n            isActive: true\n        };\n        const sessions = this.getStorageData(this.SESSIONS_KEY);\n        sessions.push(sessionData);\n        this.setStorageData(this.SESSIONS_KEY, sessions);\n        return this.transformSession(sessionData);\n    }\n    async updateSession(id, updates) {\n        const sessions = this.getStorageData(this.SESSIONS_KEY);\n        const index = sessions.findIndex((s)=>s.id === id);\n        if (index === -1) {\n            throw new MockAPIError('Session not found', 404);\n        }\n        sessions[index] = {\n            ...sessions[index],\n            ...updates,\n            updatedAt: new Date().toISOString()\n        };\n        this.setStorageData(this.SESSIONS_KEY, sessions);\n        return this.transformSession(sessions[index]);\n    }\n    async deleteSession(id) {\n        const sessions = this.getStorageData(this.SESSIONS_KEY);\n        const filteredSessions = sessions.filter((s)=>s.id !== id);\n        this.setStorageData(this.SESSIONS_KEY, filteredSessions);\n        // Also delete associated messages\n        const messages = this.getStorageData(this.MESSAGES_KEY);\n        const filteredMessages = messages.filter((m)=>m.sessionId !== id);\n        this.setStorageData(this.MESSAGES_KEY, filteredMessages);\n    }\n    async updateSessionActivity(id) {\n        const sessions = this.getStorageData(this.SESSIONS_KEY);\n        const index = sessions.findIndex((s)=>s.id === id);\n        if (index !== -1) {\n            sessions[index].lastActivity = new Date().toISOString();\n            sessions[index].updatedAt = new Date().toISOString();\n            this.setStorageData(this.SESSIONS_KEY, sessions);\n        }\n    }\n    // Message Management\n    async getMessages(sessionId) {\n        const messages = this.getStorageData(this.MESSAGES_KEY);\n        return messages.filter((m)=>m.sessionId === sessionId).map(this.transformMessage).sort((a, b)=>new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());\n    }\n    async createMessage(message) {\n        var _message_responseData, _message_responseData1, _message_responseData2;\n        const messageId = this.generateId();\n        console.log('LocalStorage: Creating message with ID:', messageId, 'type:', message.type);\n        const messageData = {\n            id: messageId,\n            sessionId: message.sessionId,\n            content: message.content,\n            type: message.type,\n            timestamp: message.timestamp.toISOString(),\n            responseType: (_message_responseData = message.responseData) === null || _message_responseData === void 0 ? void 0 : _message_responseData.type,\n            responseContent: (_message_responseData1 = message.responseData) === null || _message_responseData1 === void 0 ? void 0 : _message_responseData1.content,\n            responseMetadata: (_message_responseData2 = message.responseData) === null || _message_responseData2 === void 0 ? void 0 : _message_responseData2.metadata\n        };\n        const messages = this.getStorageData(this.MESSAGES_KEY);\n        // Check if a similar message already exists (same content, type, session)\n        const existingMessage = messages.find((m)=>m.sessionId === message.sessionId && m.content === message.content && m.type === message.type && Math.abs(new Date(m.timestamp).getTime() - message.timestamp.getTime()) < 1000 // Within 1 second\n        );\n        if (existingMessage) {\n            console.log('LocalStorage: Similar message already exists, returning existing:', existingMessage.id);\n            return this.transformMessage(existingMessage);\n        }\n        messages.push(messageData);\n        this.setStorageData(this.MESSAGES_KEY, messages);\n        console.log('LocalStorage: Message saved successfully:', messageId);\n        // Update session message count\n        await this.incrementSessionMessageCount(message.sessionId);\n        return this.transformMessage(messageData);\n    }\n    async updateMessage(id, updates) {\n        var _updates_responseData, _updates_responseData1, _updates_responseData2;\n        const messages = this.getStorageData(this.MESSAGES_KEY);\n        const index = messages.findIndex((m)=>m.id === id);\n        if (index === -1) {\n            throw new MockAPIError('Message not found', 404);\n        }\n        messages[index] = {\n            ...messages[index],\n            content: updates.content || messages[index].content,\n            responseType: ((_updates_responseData = updates.responseData) === null || _updates_responseData === void 0 ? void 0 : _updates_responseData.type) || messages[index].responseType,\n            responseContent: ((_updates_responseData1 = updates.responseData) === null || _updates_responseData1 === void 0 ? void 0 : _updates_responseData1.content) || messages[index].responseContent,\n            responseMetadata: ((_updates_responseData2 = updates.responseData) === null || _updates_responseData2 === void 0 ? void 0 : _updates_responseData2.metadata) || messages[index].responseMetadata\n        };\n        this.setStorageData(this.MESSAGES_KEY, messages);\n        return this.transformMessage(messages[index]);\n    }\n    async deleteMessage(id) {\n        const messages = this.getStorageData(this.MESSAGES_KEY);\n        const filteredMessages = messages.filter((m)=>m.id !== id);\n        this.setStorageData(this.MESSAGES_KEY, filteredMessages);\n    }\n    async incrementSessionMessageCount(sessionId) {\n        const sessions = this.getStorageData(this.SESSIONS_KEY);\n        const index = sessions.findIndex((s)=>s.id === sessionId);\n        if (index !== -1) {\n            sessions[index].messageCount += 1;\n            sessions[index].lastActivity = new Date().toISOString();\n            sessions[index].updatedAt = new Date().toISOString();\n            this.setStorageData(this.SESSIONS_KEY, sessions);\n        }\n    }\n    transformSession(session) {\n        return {\n            id: session.id,\n            name: session.name,\n            createdAt: new Date(session.createdAt),\n            updatedAt: new Date(session.updatedAt),\n            messages: [],\n            metadata: {\n                messageCount: session.messageCount,\n                lastActivity: new Date(session.lastActivity),\n                isActive: session.isActive\n            }\n        };\n    }\n    transformMessage(message) {\n        let responseData = undefined;\n        if (message.responseType) {\n            // Check if stored content is the problematic mixed format\n            let processedContent = message.responseContent;\n            let processedType = message.responseType;\n            // If we have content that looks like mixed format but wasn't detected properly\n            if (processedContent && typeof processedContent === 'object' && !Array.isArray(processedContent)) {\n                const keys = Object.keys(processedContent);\n                const hasText = keys.some((key)=>key.startsWith('text'));\n                const hasChart = keys.some((key)=>key.startsWith('chart'));\n                if (hasText || hasChart) {\n                    // Convert to mixed format and wrap in array\n                    processedContent = [\n                        processedContent\n                    ];\n                    processedType = 'mixed';\n                    console.log('MockAPI: Converted stored mixed content to array format');\n                }\n            }\n            responseData = {\n                type: processedType,\n                content: processedContent,\n                metadata: message.responseMetadata\n            };\n        }\n        return {\n            id: message.id,\n            sessionId: message.sessionId,\n            content: message.content,\n            type: message.type,\n            timestamp: new Date(message.timestamp),\n            responseData\n        };\n    }\n    async healthCheck() {\n        return  true && 'localStorage' in window;\n    }\n    async clearAllData() {\n        if (true) {\n            localStorage.removeItem(this.SESSIONS_KEY);\n            localStorage.removeItem(this.MESSAGES_KEY);\n        }\n    }\n    constructor(){\n        this.SESSIONS_KEY = 'chat-sessions';\n        this.MESSAGES_KEY = 'chat-messages';\n    }\n}\nclass MockAPIClient {\n    /**\n   * Generic API request handler\n   */ async request(endpoint) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        if (this.useFallback) {\n            throw new MockAPIError('Using fallback client', 0);\n        }\n        const url = \"\".concat(this.baseUrl).concat(endpoint);\n        const { timeout } = this.config;\n        try {\n            const response = await fetch(url, {\n                headers: {\n                    'Content-Type': 'application/json',\n                    ...options.headers\n                },\n                signal: AbortSignal.timeout(timeout),\n                ...options\n            });\n            if (!response.ok) {\n                throw new MockAPIError(\"HTTP \".concat(response.status, \": \").concat(response.statusText), response.status);\n            }\n            const data = await response.json();\n            return data;\n        } catch (error) {\n            if (error instanceof MockAPIError) {\n                throw error;\n            }\n            if (error instanceof Error) {\n                if (error.name === 'TimeoutError') {\n                    throw new MockAPIError('Request timeout');\n                }\n                if (error.message.includes('fetch')) {\n                    throw new MockAPIError('Network error', undefined, error);\n                }\n            }\n            throw new MockAPIError('Unexpected error', undefined, error);\n        }\n    }\n    // Session Management\n    async getSessions() {\n        try {\n            if (this.useFallback) {\n                return await this.fallbackClient.getSessions();\n            }\n            const sessions = await this.request('/sessions');\n            return sessions.map(this.transformSession);\n        } catch (error) {\n            console.warn('MockAPI failed, using localStorage fallback:', error);\n            return await this.fallbackClient.getSessions();\n        }\n    }\n    async getSession(id) {\n        try {\n            if (this.useFallback) {\n                return await this.fallbackClient.getSession(id);\n            }\n            const session = await this.request(\"/sessions/\".concat(id));\n            return this.transformSession(session);\n        } catch (error) {\n            if (error instanceof MockAPIError && error.status === 404) {\n                return null;\n            }\n            console.warn('MockAPI failed, using localStorage fallback:', error);\n            return await this.fallbackClient.getSession(id);\n        }\n    }\n    async createSession(name) {\n        try {\n            if (this.useFallback) {\n                return await this.fallbackClient.createSession(name);\n            }\n            const now = new Date().toISOString();\n            const sessionData = {\n                name,\n                createdAt: now,\n                updatedAt: now,\n                messageCount: 0,\n                lastActivity: now,\n                isActive: true\n            };\n            const session = await this.request('/sessions', {\n                method: 'POST',\n                body: JSON.stringify(sessionData)\n            });\n            return this.transformSession(session);\n        } catch (error) {\n            console.warn('MockAPI failed, using localStorage fallback:', error);\n            return await this.fallbackClient.createSession(name);\n        }\n    }\n    async updateSession(id, updates) {\n        try {\n            if (this.useFallback) {\n                return await this.fallbackClient.updateSession(id, updates);\n            }\n            const updateData = {\n                ...updates,\n                updatedAt: new Date().toISOString()\n            };\n            const session = await this.request(\"/sessions/\".concat(id), {\n                method: 'PUT',\n                body: JSON.stringify(updateData)\n            });\n            return this.transformSession(session);\n        } catch (error) {\n            console.warn('MockAPI failed, using localStorage fallback:', error);\n            return await this.fallbackClient.updateSession(id, updates);\n        }\n    }\n    async deleteSession(id) {\n        try {\n            if (this.useFallback) {\n                return await this.fallbackClient.deleteSession(id);\n            }\n            await this.request(\"/sessions/\".concat(id), {\n                method: 'DELETE'\n            });\n        } catch (error) {\n            console.warn('MockAPI failed, using localStorage fallback:', error);\n            return await this.fallbackClient.deleteSession(id);\n        }\n    }\n    async updateSessionActivity(id) {\n        try {\n            if (this.useFallback) {\n                return await this.fallbackClient.updateSessionActivity(id);\n            }\n            const updateData = {\n                lastActivity: new Date().toISOString(),\n                updatedAt: new Date().toISOString()\n            };\n            await this.request(\"/sessions/\".concat(id), {\n                method: 'PUT',\n                body: JSON.stringify(updateData)\n            });\n        } catch (error) {\n            console.warn('MockAPI failed, using localStorage fallback:', error);\n            return await this.fallbackClient.updateSessionActivity(id);\n        }\n    }\n    // Message Management\n    async getMessages(sessionId) {\n        try {\n            if (this.useFallback) {\n                return await this.fallbackClient.getMessages(sessionId);\n            }\n            const messages = await this.request(\"/messages?sessionId=\".concat(sessionId));\n            return messages.map(this.transformMessage).sort((a, b)=>new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());\n        } catch (error) {\n            console.warn('MockAPI failed, using localStorage fallback:', error);\n            return await this.fallbackClient.getMessages(sessionId);\n        }\n    }\n    async createMessage(message) {\n        try {\n            var _message_responseData, _message_responseData1, _message_responseData2;\n            if (this.useFallback) {\n                return await this.fallbackClient.createMessage(message);\n            }\n            const messageData = {\n                sessionId: message.sessionId,\n                content: message.content,\n                type: message.type,\n                timestamp: message.timestamp.toISOString(),\n                responseType: (_message_responseData = message.responseData) === null || _message_responseData === void 0 ? void 0 : _message_responseData.type,\n                responseContent: (_message_responseData1 = message.responseData) === null || _message_responseData1 === void 0 ? void 0 : _message_responseData1.content,\n                responseMetadata: (_message_responseData2 = message.responseData) === null || _message_responseData2 === void 0 ? void 0 : _message_responseData2.metadata\n            };\n            const createdMessage = await this.request('/messages', {\n                method: 'POST',\n                body: JSON.stringify(messageData)\n            });\n            // Update session message count and activity\n            await this.incrementSessionMessageCount(message.sessionId);\n            return this.transformMessage(createdMessage);\n        } catch (error) {\n            console.warn('MockAPI failed, using localStorage fallback:', error);\n            return await this.fallbackClient.createMessage(message);\n        }\n    }\n    async updateMessage(id, updates) {\n        try {\n            var _updates_responseData, _updates_responseData1, _updates_responseData2;\n            if (this.useFallback) {\n                return await this.fallbackClient.updateMessage(id, updates);\n            }\n            const updateData = {\n                content: updates.content,\n                responseType: (_updates_responseData = updates.responseData) === null || _updates_responseData === void 0 ? void 0 : _updates_responseData.type,\n                responseContent: (_updates_responseData1 = updates.responseData) === null || _updates_responseData1 === void 0 ? void 0 : _updates_responseData1.content,\n                responseMetadata: (_updates_responseData2 = updates.responseData) === null || _updates_responseData2 === void 0 ? void 0 : _updates_responseData2.metadata\n            };\n            const message = await this.request(\"/messages/\".concat(id), {\n                method: 'PUT',\n                body: JSON.stringify(updateData)\n            });\n            return this.transformMessage(message);\n        } catch (error) {\n            console.warn('MockAPI failed, using localStorage fallback:', error);\n            return await this.fallbackClient.updateMessage(id, updates);\n        }\n    }\n    async deleteMessage(id) {\n        try {\n            if (this.useFallback) {\n                return await this.fallbackClient.deleteMessage(id);\n            }\n            await this.request(\"/messages/\".concat(id), {\n                method: 'DELETE'\n            });\n        } catch (error) {\n            console.warn('MockAPI failed, using localStorage fallback:', error);\n            return await this.fallbackClient.deleteMessage(id);\n        }\n    }\n    // Utility Methods\n    async incrementSessionMessageCount(sessionId) {\n        const session = await this.getSession(sessionId);\n        if (session) {\n            try {\n                await this.request(\"/sessions/\".concat(sessionId), {\n                    method: 'PUT',\n                    body: JSON.stringify({\n                        messageCount: session.metadata.messageCount + 1,\n                        lastActivity: new Date().toISOString(),\n                        updatedAt: new Date().toISOString()\n                    })\n                });\n            } catch (error) {\n                console.warn('Failed to update session message count:', error);\n            }\n        }\n    }\n    transformSession(session) {\n        return {\n            id: session.id,\n            name: session.name,\n            createdAt: new Date(session.createdAt),\n            updatedAt: new Date(session.updatedAt),\n            messages: [],\n            metadata: {\n                messageCount: session.messageCount,\n                lastActivity: new Date(session.lastActivity),\n                isActive: session.isActive\n            }\n        };\n    }\n    transformMessage(message) {\n        let responseData = undefined;\n        if (message.responseType) {\n            // Check if stored content is the problematic mixed format\n            let processedContent = message.responseContent;\n            let processedType = message.responseType;\n            // If we have content that looks like mixed format but wasn't detected properly\n            if (processedContent && typeof processedContent === 'object' && !Array.isArray(processedContent)) {\n                const keys = Object.keys(processedContent);\n                const hasText = keys.some((key)=>key.startsWith('text'));\n                const hasChart = keys.some((key)=>key.startsWith('chart'));\n                if (hasText || hasChart) {\n                    // Convert to mixed format and wrap in array\n                    processedContent = [\n                        processedContent\n                    ];\n                    processedType = 'mixed';\n                    console.log('MockAPI: Converted stored mixed content to array format');\n                }\n            }\n            responseData = {\n                type: processedType,\n                content: processedContent,\n                metadata: message.responseMetadata\n            };\n        }\n        return {\n            id: message.id,\n            sessionId: message.sessionId,\n            content: message.content,\n            type: message.type,\n            timestamp: new Date(message.timestamp),\n            responseData\n        };\n    }\n    async healthCheck() {\n        try {\n            if (this.useFallback) {\n                return await this.fallbackClient.healthCheck();\n            }\n            await this.request('/sessions?limit=1');\n            return true;\n        } catch (e) {\n            return await this.fallbackClient.healthCheck();\n        }\n    }\n    async clearAllData() {\n        try {\n            if (this.useFallback) {\n                return await this.fallbackClient.clearAllData();\n            }\n            const [sessions, messages] = await Promise.all([\n                this.getSessions(),\n                this.request('/messages')\n            ]);\n            // Delete all messages\n            await Promise.all(messages.map((message)=>this.deleteMessage(message.id)));\n            // Delete all sessions\n            await Promise.all(sessions.map((session)=>this.deleteSession(session.id)));\n        } catch (error) {\n            console.warn('MockAPI failed, using localStorage fallback:', error);\n            return await this.fallbackClient.clearAllData();\n        }\n    }\n    constructor(config){\n        this.useFallback = false;\n        this.config = {\n            timeout: 10000,\n            ...config\n        };\n        this.baseUrl = \"\".concat(this.config.baseUrl, \"/projects/\").concat(this.config.projectId);\n        this.fallbackClient = new LocalStorageMockAPIClient();\n        // Check if we should use fallback (invalid URLs indicate development mode)\n        this.useFallback = config.baseUrl.includes('mockapi.io') && config.projectId === 'your-project-id';\n    }\n}\n// Factory function\nfunction createMockAPIClient(config) {\n    return new MockAPIClient(config);\n}\n// Hook for React components\nfunction useMockAPIClient() {\n    const client = createMockAPIClient({\n        baseUrl: \"https://mockapi.io/api/v1\" || 0,\n        projectId: \"your-project-id\" || 0\n    });\n    return client;\n}\n// Utility functions\nconst mockAPIUtils = {\n    /**\n   * Format error for user display\n   */ formatError (error) {\n        if (error.status === 404) {\n            return 'Resource not found';\n        }\n        if (error.status === 429) {\n            return 'Too many requests. Please wait and try again.';\n        }\n        if (error.status && error.status >= 500) {\n            return 'Server error. Please try again later.';\n        }\n        return 'An error occurred. Please try again.';\n    },\n    /**\n   * Validate session name\n   */ validateSessionName (name) {\n        if (!name.trim()) {\n            return 'Session name cannot be empty';\n        }\n        if (name.length > 100) {\n            return 'Session name cannot exceed 100 characters';\n        }\n        return null;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9tb2NrYXBpLWNsaWVudC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Q0FHQyxHQUlNLE1BQU1BLHFCQUFxQkM7SUFDaEMsWUFDRUMsT0FBZSxFQUNmLE1BQXNCLEVBQ3RCLE9BQW9CLENBQ3BCO1FBQ0EsS0FBSyxDQUFDQSxlQUhDQyxTQUFBQSxhQUNBQyxVQUFBQTtRQUdQLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQVFBLHVDQUF1QztBQUN2QyxNQUFNQztJQUlJQyxhQUFxQjtRQUMzQixPQUFPQyxLQUFLQyxHQUFHLEdBQUdDLFFBQVEsQ0FBQyxNQUFNQyxLQUFLQyxNQUFNLEdBQUdGLFFBQVEsQ0FBQyxJQUFJRyxNQUFNLENBQUM7SUFDckU7SUFFUUMsZUFBa0JDLEdBQVcsRUFBTztRQUMxQyxJQUFJLEtBQTZCLEVBQUUsRUFBVTtRQUM3QyxJQUFJO1lBQ0YsTUFBTUMsT0FBT0MsYUFBYUMsT0FBTyxDQUFDSDtZQUNsQyxPQUFPQyxPQUFPRyxLQUFLQyxLQUFLLENBQUNKLFFBQVEsRUFBRTtRQUNyQyxFQUFFLFVBQU07WUFDTixPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRVFLLGVBQWtCTixHQUFXLEVBQUVDLElBQVMsRUFBUTtRQUN0RCxJQUFJLEtBQTZCLEVBQUUsRUFBTztRQUMxQyxJQUFJO1lBQ0ZDLGFBQWFLLE9BQU8sQ0FBQ1AsS0FBS0ksS0FBS0ksU0FBUyxDQUFDUDtRQUMzQyxFQUFFLE9BQU9RLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLG1DQUFtQ0E7UUFDbkQ7SUFDRjtJQUVBLHFCQUFxQjtJQUNyQixNQUFNRSxjQUFzQztRQUMxQyxNQUFNQyxXQUFXLElBQUksQ0FBQ2IsY0FBYyxDQUFpQixJQUFJLENBQUNjLFlBQVk7UUFDdEUsT0FBT0QsU0FBU0UsR0FBRyxDQUFDLElBQUksQ0FBQ0MsZ0JBQWdCO0lBQzNDO0lBRUEsTUFBTUMsV0FBV0MsRUFBVSxFQUErQjtRQUN4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YixNQUFNSyxlQUFlO0lBQzFCOztHQUVDLEdBQ0RDLGFBQVkzRyxLQUFtQjtRQUM3QixJQUFJQSxNQUFNckIsTUFBTSxLQUFLLEtBQUs7WUFDeEIsT0FBTztRQUNUO1FBQ0EsSUFBSXFCLE1BQU1yQixNQUFNLEtBQUssS0FBSztZQUN4QixPQUFPO1FBQ1Q7UUFDQSxJQUFJcUIsTUFBTXJCLE1BQU0sSUFBSXFCLE1BQU1yQixNQUFNLElBQUksS0FBSztZQUN2QyxPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7SUFFQTs7R0FFQyxHQUNEaUkscUJBQW9CL0gsSUFBWTtRQUM5QixJQUFJLENBQUNBLEtBQUtnSSxJQUFJLElBQUk7WUFDaEIsT0FBTztRQUNUO1FBQ0EsSUFBSWhJLEtBQUtpSSxNQUFNLEdBQUcsS0FBSztZQUNyQixPQUFPO1FBQ1Q7UUFDQSxPQUFPO0lBQ1Q7QUFDRixFQUFFIiwic291cmNlcyI6WyJDOlxcRWJ0dGlrYXIgSW50ZWxsaWdlbmNlIFByb2plY3RzXFxUZXN0LUNoYXQtQXBwXFxsaWJcXG1vY2thcGktY2xpZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTW9ja0FQSSBDbGllbnQgd2l0aCBsb2NhbFN0b3JhZ2UgZmFsbGJhY2tcbiAqIEhhbmRsZXMgc2Vzc2lvbiBhbmQgbWVzc2FnZSBwZXJzaXN0ZW5jZSB1c2luZyBNb2NrQVBJIHNlcnZpY2Ugb3IgbG9jYWxTdG9yYWdlXG4gKi9cblxuaW1wb3J0IHsgQ2hhdFNlc3Npb24sIE1lc3NhZ2UsIE1vY2tBUElTZXNzaW9uLCBNb2NrQVBJTWVzc2FnZSwgQXBpUmVzcG9uc2UgfSBmcm9tICdAL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIE1vY2tBUElFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIHB1YmxpYyBzdGF0dXM/OiBudW1iZXIsXG4gICAgcHVibGljIGRldGFpbHM/OiBhbnlcbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ01vY2tBUElFcnJvcic7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb2NrQVBJQ29uZmlnIHtcbiAgYmFzZVVybDogc3RyaW5nO1xuICBwcm9qZWN0SWQ6IHN0cmluZztcbiAgdGltZW91dD86IG51bWJlcjtcbn1cblxuLy8gTG9jYWxTdG9yYWdlIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uXG5jbGFzcyBMb2NhbFN0b3JhZ2VNb2NrQVBJQ2xpZW50IHtcbiAgcHJpdmF0ZSByZWFkb25seSBTRVNTSU9OU19LRVkgPSAnY2hhdC1zZXNzaW9ucyc7XG4gIHByaXZhdGUgcmVhZG9ubHkgTUVTU0FHRVNfS0VZID0gJ2NoYXQtbWVzc2FnZXMnO1xuXG4gIHByaXZhdGUgZ2VuZXJhdGVJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0U3RvcmFnZURhdGE8VD4oa2V5OiBzdHJpbmcpOiBUW10ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIFtdO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgIHJldHVybiBkYXRhID8gSlNPTi5wYXJzZShkYXRhKSA6IFtdO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0U3RvcmFnZURhdGE8VD4oa2V5OiBzdHJpbmcsIGRhdGE6IFRbXSk6IHZvaWQge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgdG8gbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvLyBTZXNzaW9uIE1hbmFnZW1lbnRcbiAgYXN5bmMgZ2V0U2Vzc2lvbnMoKTogUHJvbWlzZTxDaGF0U2Vzc2lvbltdPiB7XG4gICAgY29uc3Qgc2Vzc2lvbnMgPSB0aGlzLmdldFN0b3JhZ2VEYXRhPE1vY2tBUElTZXNzaW9uPih0aGlzLlNFU1NJT05TX0tFWSk7XG4gICAgcmV0dXJuIHNlc3Npb25zLm1hcCh0aGlzLnRyYW5zZm9ybVNlc3Npb24pO1xuICB9XG5cbiAgYXN5bmMgZ2V0U2Vzc2lvbihpZDogc3RyaW5nKTogUHJvbWlzZTxDaGF0U2Vzc2lvbiB8IG51bGw+IHtcbiAgICBjb25zdCBzZXNzaW9ucyA9IHRoaXMuZ2V0U3RvcmFnZURhdGE8TW9ja0FQSVNlc3Npb24+KHRoaXMuU0VTU0lPTlNfS0VZKTtcbiAgICBjb25zdCBzZXNzaW9uID0gc2Vzc2lvbnMuZmluZChzID0+IHMuaWQgPT09IGlkKTtcbiAgICByZXR1cm4gc2Vzc2lvbiA/IHRoaXMudHJhbnNmb3JtU2Vzc2lvbihzZXNzaW9uKSA6IG51bGw7XG4gIH1cblxuICBhc3luYyBjcmVhdGVTZXNzaW9uKG5hbWU6IHN0cmluZyk6IFByb21pc2U8Q2hhdFNlc3Npb24+IHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgY29uc3Qgc2Vzc2lvbkRhdGE6IE1vY2tBUElTZXNzaW9uID0ge1xuICAgICAgaWQ6IHRoaXMuZ2VuZXJhdGVJZCgpLFxuICAgICAgbmFtZSxcbiAgICAgIGNyZWF0ZWRBdDogbm93LFxuICAgICAgdXBkYXRlZEF0OiBub3csXG4gICAgICBtZXNzYWdlQ291bnQ6IDAsXG4gICAgICBsYXN0QWN0aXZpdHk6IG5vdyxcbiAgICAgIGlzQWN0aXZlOiB0cnVlXG4gICAgfTtcblxuICAgIGNvbnN0IHNlc3Npb25zID0gdGhpcy5nZXRTdG9yYWdlRGF0YTxNb2NrQVBJU2Vzc2lvbj4odGhpcy5TRVNTSU9OU19LRVkpO1xuICAgIHNlc3Npb25zLnB1c2goc2Vzc2lvbkRhdGEpO1xuICAgIHRoaXMuc2V0U3RvcmFnZURhdGEodGhpcy5TRVNTSU9OU19LRVksIHNlc3Npb25zKTtcblxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVNlc3Npb24oc2Vzc2lvbkRhdGEpO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlU2Vzc2lvbihpZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPFBpY2s8Q2hhdFNlc3Npb24sICduYW1lJz4+KTogUHJvbWlzZTxDaGF0U2Vzc2lvbj4ge1xuICAgIGNvbnN0IHNlc3Npb25zID0gdGhpcy5nZXRTdG9yYWdlRGF0YTxNb2NrQVBJU2Vzc2lvbj4odGhpcy5TRVNTSU9OU19LRVkpO1xuICAgIGNvbnN0IGluZGV4ID0gc2Vzc2lvbnMuZmluZEluZGV4KHMgPT4gcy5pZCA9PT0gaWQpO1xuICAgIFxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBNb2NrQVBJRXJyb3IoJ1Nlc3Npb24gbm90IGZvdW5kJywgNDA0KTtcbiAgICB9XG5cbiAgICBzZXNzaW9uc1tpbmRleF0gPSB7IFxuICAgICAgLi4uc2Vzc2lvbnNbaW5kZXhdLCBcbiAgICAgIC4uLnVwZGF0ZXMsXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH07XG4gICAgXG4gICAgdGhpcy5zZXRTdG9yYWdlRGF0YSh0aGlzLlNFU1NJT05TX0tFWSwgc2Vzc2lvbnMpO1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVNlc3Npb24oc2Vzc2lvbnNbaW5kZXhdKTtcbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZVNlc3Npb24oaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHNlc3Npb25zID0gdGhpcy5nZXRTdG9yYWdlRGF0YTxNb2NrQVBJU2Vzc2lvbj4odGhpcy5TRVNTSU9OU19LRVkpO1xuICAgIGNvbnN0IGZpbHRlcmVkU2Vzc2lvbnMgPSBzZXNzaW9ucy5maWx0ZXIocyA9PiBzLmlkICE9PSBpZCk7XG4gICAgdGhpcy5zZXRTdG9yYWdlRGF0YSh0aGlzLlNFU1NJT05TX0tFWSwgZmlsdGVyZWRTZXNzaW9ucyk7XG4gICAgXG4gICAgLy8gQWxzbyBkZWxldGUgYXNzb2NpYXRlZCBtZXNzYWdlc1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gdGhpcy5nZXRTdG9yYWdlRGF0YTxNb2NrQVBJTWVzc2FnZT4odGhpcy5NRVNTQUdFU19LRVkpO1xuICAgIGNvbnN0IGZpbHRlcmVkTWVzc2FnZXMgPSBtZXNzYWdlcy5maWx0ZXIobSA9PiBtLnNlc3Npb25JZCAhPT0gaWQpO1xuICAgIHRoaXMuc2V0U3RvcmFnZURhdGEodGhpcy5NRVNTQUdFU19LRVksIGZpbHRlcmVkTWVzc2FnZXMpO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlU2Vzc2lvbkFjdGl2aXR5KGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBzZXNzaW9ucyA9IHRoaXMuZ2V0U3RvcmFnZURhdGE8TW9ja0FQSVNlc3Npb24+KHRoaXMuU0VTU0lPTlNfS0VZKTtcbiAgICBjb25zdCBpbmRleCA9IHNlc3Npb25zLmZpbmRJbmRleChzID0+IHMuaWQgPT09IGlkKTtcbiAgICBcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzZXNzaW9uc1tpbmRleF0ubGFzdEFjdGl2aXR5ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgc2Vzc2lvbnNbaW5kZXhdLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIHRoaXMuc2V0U3RvcmFnZURhdGEodGhpcy5TRVNTSU9OU19LRVksIHNlc3Npb25zKTtcbiAgICB9XG4gIH1cblxuICAvLyBNZXNzYWdlIE1hbmFnZW1lbnRcbiAgYXN5bmMgZ2V0TWVzc2FnZXMoc2Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPE1lc3NhZ2VbXT4ge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gdGhpcy5nZXRTdG9yYWdlRGF0YTxNb2NrQVBJTWVzc2FnZT4odGhpcy5NRVNTQUdFU19LRVkpO1xuICAgIHJldHVybiBtZXNzYWdlc1xuICAgICAgLmZpbHRlcihtID0+IG0uc2Vzc2lvbklkID09PSBzZXNzaW9uSWQpXG4gICAgICAubWFwKHRoaXMudHJhbnNmb3JtTWVzc2FnZSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShhLnRpbWVzdGFtcCkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYi50aW1lc3RhbXApLmdldFRpbWUoKSk7XG4gIH1cblxuICBhc3luYyBjcmVhdGVNZXNzYWdlKG1lc3NhZ2U6IE9taXQ8TWVzc2FnZSwgJ2lkJz4pOiBQcm9taXNlPE1lc3NhZ2U+IHtcbiAgICBjb25zdCBtZXNzYWdlSWQgPSB0aGlzLmdlbmVyYXRlSWQoKTtcbiAgICBjb25zb2xlLmxvZygnTG9jYWxTdG9yYWdlOiBDcmVhdGluZyBtZXNzYWdlIHdpdGggSUQ6JywgbWVzc2FnZUlkLCAndHlwZTonLCBtZXNzYWdlLnR5cGUpO1xuICAgIFxuICAgIGNvbnN0IG1lc3NhZ2VEYXRhOiBNb2NrQVBJTWVzc2FnZSA9IHtcbiAgICAgIGlkOiBtZXNzYWdlSWQsXG4gICAgICBzZXNzaW9uSWQ6IG1lc3NhZ2Uuc2Vzc2lvbklkLFxuICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LFxuICAgICAgdHlwZTogbWVzc2FnZS50eXBlLFxuICAgICAgdGltZXN0YW1wOiBtZXNzYWdlLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgcmVzcG9uc2VUeXBlOiBtZXNzYWdlLnJlc3BvbnNlRGF0YT8udHlwZSxcbiAgICAgIHJlc3BvbnNlQ29udGVudDogbWVzc2FnZS5yZXNwb25zZURhdGE/LmNvbnRlbnQsXG4gICAgICByZXNwb25zZU1ldGFkYXRhOiBtZXNzYWdlLnJlc3BvbnNlRGF0YT8ubWV0YWRhdGFcbiAgICB9O1xuXG4gICAgY29uc3QgbWVzc2FnZXMgPSB0aGlzLmdldFN0b3JhZ2VEYXRhPE1vY2tBUElNZXNzYWdlPih0aGlzLk1FU1NBR0VTX0tFWSk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgYSBzaW1pbGFyIG1lc3NhZ2UgYWxyZWFkeSBleGlzdHMgKHNhbWUgY29udGVudCwgdHlwZSwgc2Vzc2lvbilcbiAgICBjb25zdCBleGlzdGluZ01lc3NhZ2UgPSBtZXNzYWdlcy5maW5kKG0gPT4gXG4gICAgICBtLnNlc3Npb25JZCA9PT0gbWVzc2FnZS5zZXNzaW9uSWQgJiYgXG4gICAgICBtLmNvbnRlbnQgPT09IG1lc3NhZ2UuY29udGVudCAmJiBcbiAgICAgIG0udHlwZSA9PT0gbWVzc2FnZS50eXBlICYmXG4gICAgICBNYXRoLmFicyhuZXcgRGF0ZShtLnRpbWVzdGFtcCkuZ2V0VGltZSgpIC0gbWVzc2FnZS50aW1lc3RhbXAuZ2V0VGltZSgpKSA8IDEwMDAgLy8gV2l0aGluIDEgc2Vjb25kXG4gICAgKTtcbiAgICBcbiAgICBpZiAoZXhpc3RpbmdNZXNzYWdlKSB7XG4gICAgICBjb25zb2xlLmxvZygnTG9jYWxTdG9yYWdlOiBTaW1pbGFyIG1lc3NhZ2UgYWxyZWFkeSBleGlzdHMsIHJldHVybmluZyBleGlzdGluZzonLCBleGlzdGluZ01lc3NhZ2UuaWQpO1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtTWVzc2FnZShleGlzdGluZ01lc3NhZ2UpO1xuICAgIH1cbiAgICBcbiAgICBtZXNzYWdlcy5wdXNoKG1lc3NhZ2VEYXRhKTtcbiAgICB0aGlzLnNldFN0b3JhZ2VEYXRhKHRoaXMuTUVTU0FHRVNfS0VZLCBtZXNzYWdlcyk7XG4gICAgY29uc29sZS5sb2coJ0xvY2FsU3RvcmFnZTogTWVzc2FnZSBzYXZlZCBzdWNjZXNzZnVsbHk6JywgbWVzc2FnZUlkKTtcblxuICAgIC8vIFVwZGF0ZSBzZXNzaW9uIG1lc3NhZ2UgY291bnRcbiAgICBhd2FpdCB0aGlzLmluY3JlbWVudFNlc3Npb25NZXNzYWdlQ291bnQobWVzc2FnZS5zZXNzaW9uSWQpO1xuXG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtTWVzc2FnZShtZXNzYWdlRGF0YSk7XG4gIH1cblxuICBhc3luYyB1cGRhdGVNZXNzYWdlKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8TWVzc2FnZT4pOiBQcm9taXNlPE1lc3NhZ2U+IHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IHRoaXMuZ2V0U3RvcmFnZURhdGE8TW9ja0FQSU1lc3NhZ2U+KHRoaXMuTUVTU0FHRVNfS0VZKTtcbiAgICBjb25zdCBpbmRleCA9IG1lc3NhZ2VzLmZpbmRJbmRleChtID0+IG0uaWQgPT09IGlkKTtcbiAgICBcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgTW9ja0FQSUVycm9yKCdNZXNzYWdlIG5vdCBmb3VuZCcsIDQwNCk7XG4gICAgfVxuXG4gICAgbWVzc2FnZXNbaW5kZXhdID0ge1xuICAgICAgLi4ubWVzc2FnZXNbaW5kZXhdLFxuICAgICAgY29udGVudDogdXBkYXRlcy5jb250ZW50IHx8IG1lc3NhZ2VzW2luZGV4XS5jb250ZW50LFxuICAgICAgcmVzcG9uc2VUeXBlOiB1cGRhdGVzLnJlc3BvbnNlRGF0YT8udHlwZSB8fCBtZXNzYWdlc1tpbmRleF0ucmVzcG9uc2VUeXBlLFxuICAgICAgcmVzcG9uc2VDb250ZW50OiB1cGRhdGVzLnJlc3BvbnNlRGF0YT8uY29udGVudCB8fCBtZXNzYWdlc1tpbmRleF0ucmVzcG9uc2VDb250ZW50LFxuICAgICAgcmVzcG9uc2VNZXRhZGF0YTogdXBkYXRlcy5yZXNwb25zZURhdGE/Lm1ldGFkYXRhIHx8IG1lc3NhZ2VzW2luZGV4XS5yZXNwb25zZU1ldGFkYXRhXG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnNldFN0b3JhZ2VEYXRhKHRoaXMuTUVTU0FHRVNfS0VZLCBtZXNzYWdlcyk7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtTWVzc2FnZShtZXNzYWdlc1tpbmRleF0pO1xuICB9XG5cbiAgYXN5bmMgZGVsZXRlTWVzc2FnZShpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgbWVzc2FnZXMgPSB0aGlzLmdldFN0b3JhZ2VEYXRhPE1vY2tBUElNZXNzYWdlPih0aGlzLk1FU1NBR0VTX0tFWSk7XG4gICAgY29uc3QgZmlsdGVyZWRNZXNzYWdlcyA9IG1lc3NhZ2VzLmZpbHRlcihtID0+IG0uaWQgIT09IGlkKTtcbiAgICB0aGlzLnNldFN0b3JhZ2VEYXRhKHRoaXMuTUVTU0FHRVNfS0VZLCBmaWx0ZXJlZE1lc3NhZ2VzKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW5jcmVtZW50U2Vzc2lvbk1lc3NhZ2VDb3VudChzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHNlc3Npb25zID0gdGhpcy5nZXRTdG9yYWdlRGF0YTxNb2NrQVBJU2Vzc2lvbj4odGhpcy5TRVNTSU9OU19LRVkpO1xuICAgIGNvbnN0IGluZGV4ID0gc2Vzc2lvbnMuZmluZEluZGV4KHMgPT4gcy5pZCA9PT0gc2Vzc2lvbklkKTtcbiAgICBcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzZXNzaW9uc1tpbmRleF0ubWVzc2FnZUNvdW50ICs9IDE7XG4gICAgICBzZXNzaW9uc1tpbmRleF0ubGFzdEFjdGl2aXR5ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgc2Vzc2lvbnNbaW5kZXhdLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgIHRoaXMuc2V0U3RvcmFnZURhdGEodGhpcy5TRVNTSU9OU19LRVksIHNlc3Npb25zKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyYW5zZm9ybVNlc3Npb24oc2Vzc2lvbjogTW9ja0FQSVNlc3Npb24pOiBDaGF0U2Vzc2lvbiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBzZXNzaW9uLmlkLFxuICAgICAgbmFtZTogc2Vzc2lvbi5uYW1lLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShzZXNzaW9uLmNyZWF0ZWRBdCksXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKHNlc3Npb24udXBkYXRlZEF0KSxcbiAgICAgIG1lc3NhZ2VzOiBbXSwgLy8gTWVzc2FnZXMgYXJlIGxvYWRlZCBzZXBhcmF0ZWx5XG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBtZXNzYWdlQ291bnQ6IHNlc3Npb24ubWVzc2FnZUNvdW50LFxuICAgICAgICBsYXN0QWN0aXZpdHk6IG5ldyBEYXRlKHNlc3Npb24ubGFzdEFjdGl2aXR5KSxcbiAgICAgICAgaXNBY3RpdmU6IHNlc3Npb24uaXNBY3RpdmVcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSB0cmFuc2Zvcm1NZXNzYWdlKG1lc3NhZ2U6IE1vY2tBUElNZXNzYWdlKTogTWVzc2FnZSB7XG4gICAgbGV0IHJlc3BvbnNlRGF0YSA9IHVuZGVmaW5lZDtcbiAgICBcbiAgICBpZiAobWVzc2FnZS5yZXNwb25zZVR5cGUpIHtcbiAgICAgIC8vIENoZWNrIGlmIHN0b3JlZCBjb250ZW50IGlzIHRoZSBwcm9ibGVtYXRpYyBtaXhlZCBmb3JtYXRcbiAgICAgIGxldCBwcm9jZXNzZWRDb250ZW50ID0gbWVzc2FnZS5yZXNwb25zZUNvbnRlbnQ7XG4gICAgICBsZXQgcHJvY2Vzc2VkVHlwZSA9IG1lc3NhZ2UucmVzcG9uc2VUeXBlO1xuICAgICAgXG4gICAgICAvLyBJZiB3ZSBoYXZlIGNvbnRlbnQgdGhhdCBsb29rcyBsaWtlIG1peGVkIGZvcm1hdCBidXQgd2Fzbid0IGRldGVjdGVkIHByb3Blcmx5XG4gICAgICBpZiAocHJvY2Vzc2VkQ29udGVudCAmJiB0eXBlb2YgcHJvY2Vzc2VkQ29udGVudCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocHJvY2Vzc2VkQ29udGVudCkpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb2Nlc3NlZENvbnRlbnQpO1xuICAgICAgICBjb25zdCBoYXNUZXh0ID0ga2V5cy5zb21lKGtleSA9PiBrZXkuc3RhcnRzV2l0aCgndGV4dCcpKTtcbiAgICAgICAgY29uc3QgaGFzQ2hhcnQgPSBrZXlzLnNvbWUoa2V5ID0+IGtleS5zdGFydHNXaXRoKCdjaGFydCcpKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChoYXNUZXh0IHx8IGhhc0NoYXJ0KSB7XG4gICAgICAgICAgLy8gQ29udmVydCB0byBtaXhlZCBmb3JtYXQgYW5kIHdyYXAgaW4gYXJyYXlcbiAgICAgICAgICBwcm9jZXNzZWRDb250ZW50ID0gW3Byb2Nlc3NlZENvbnRlbnRdO1xuICAgICAgICAgIHByb2Nlc3NlZFR5cGUgPSAnbWl4ZWQnO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdNb2NrQVBJOiBDb252ZXJ0ZWQgc3RvcmVkIG1peGVkIGNvbnRlbnQgdG8gYXJyYXkgZm9ybWF0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmVzcG9uc2VEYXRhID0ge1xuICAgICAgICB0eXBlOiBwcm9jZXNzZWRUeXBlLFxuICAgICAgICBjb250ZW50OiBwcm9jZXNzZWRDb250ZW50LFxuICAgICAgICBtZXRhZGF0YTogbWVzc2FnZS5yZXNwb25zZU1ldGFkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IG1lc3NhZ2UuaWQsXG4gICAgICBzZXNzaW9uSWQ6IG1lc3NhZ2Uuc2Vzc2lvbklkLFxuICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LFxuICAgICAgdHlwZTogbWVzc2FnZS50eXBlLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZShtZXNzYWdlLnRpbWVzdGFtcCksXG4gICAgICByZXNwb25zZURhdGFcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgaGVhbHRoQ2hlY2soKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICdsb2NhbFN0b3JhZ2UnIGluIHdpbmRvdztcbiAgfVxuXG4gIGFzeW5jIGNsZWFyQWxsRGF0YSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuU0VTU0lPTlNfS0VZKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuTUVTU0FHRVNfS0VZKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1vY2tBUElDbGllbnQge1xuICBwcml2YXRlIGNvbmZpZzogUmVxdWlyZWQ8TW9ja0FQSUNvbmZpZz47XG4gIHByaXZhdGUgYmFzZVVybDogc3RyaW5nO1xuICBwcml2YXRlIGZhbGxiYWNrQ2xpZW50OiBMb2NhbFN0b3JhZ2VNb2NrQVBJQ2xpZW50O1xuICBwcml2YXRlIHVzZUZhbGxiYWNrOiBib29sZWFuID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBNb2NrQVBJQ29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICB0aW1lb3V0OiAxMDAwMCxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG4gICAgdGhpcy5iYXNlVXJsID0gYCR7dGhpcy5jb25maWcuYmFzZVVybH0vcHJvamVjdHMvJHt0aGlzLmNvbmZpZy5wcm9qZWN0SWR9YDtcbiAgICB0aGlzLmZhbGxiYWNrQ2xpZW50ID0gbmV3IExvY2FsU3RvcmFnZU1vY2tBUElDbGllbnQoKTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgdXNlIGZhbGxiYWNrIChpbnZhbGlkIFVSTHMgaW5kaWNhdGUgZGV2ZWxvcG1lbnQgbW9kZSlcbiAgICB0aGlzLnVzZUZhbGxiYWNrID0gY29uZmlnLmJhc2VVcmwuaW5jbHVkZXMoJ21vY2thcGkuaW8nKSAmJiBjb25maWcucHJvamVjdElkID09PSAneW91ci1wcm9qZWN0LWlkJztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmljIEFQSSByZXF1ZXN0IGhhbmRsZXJcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcmVxdWVzdDxUPihcbiAgICBlbmRwb2ludDogc3RyaW5nLFxuICAgIG9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge31cbiAgKTogUHJvbWlzZTxUPiB7XG4gICAgaWYgKHRoaXMudXNlRmFsbGJhY2spIHtcbiAgICAgIHRocm93IG5ldyBNb2NrQVBJRXJyb3IoJ1VzaW5nIGZhbGxiYWNrIGNsaWVudCcsIDApO1xuICAgIH1cblxuICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYmFzZVVybH0ke2VuZHBvaW50fWA7XG4gICAgY29uc3QgeyB0aW1lb3V0IH0gPSB0aGlzLmNvbmZpZztcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aW1lb3V0KSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBNb2NrQVBJRXJyb3IoXG4gICAgICAgICAgYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCxcbiAgICAgICAgICByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBNb2NrQVBJRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnVGltZW91dEVycm9yJykge1xuICAgICAgICAgIHRocm93IG5ldyBNb2NrQVBJRXJyb3IoJ1JlcXVlc3QgdGltZW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZmV0Y2gnKSkge1xuICAgICAgICAgIHRocm93IG5ldyBNb2NrQVBJRXJyb3IoJ05ldHdvcmsgZXJyb3InLCB1bmRlZmluZWQsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBuZXcgTW9ja0FQSUVycm9yKCdVbmV4cGVjdGVkIGVycm9yJywgdW5kZWZpbmVkLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLy8gU2Vzc2lvbiBNYW5hZ2VtZW50XG4gIGFzeW5jIGdldFNlc3Npb25zKCk6IFByb21pc2U8Q2hhdFNlc3Npb25bXT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy51c2VGYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mYWxsYmFja0NsaWVudC5nZXRTZXNzaW9ucygpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2Vzc2lvbnMgPSBhd2FpdCB0aGlzLnJlcXVlc3Q8TW9ja0FQSVNlc3Npb25bXT4oJy9zZXNzaW9ucycpO1xuICAgICAgcmV0dXJuIHNlc3Npb25zLm1hcCh0aGlzLnRyYW5zZm9ybVNlc3Npb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ01vY2tBUEkgZmFpbGVkLCB1c2luZyBsb2NhbFN0b3JhZ2UgZmFsbGJhY2s6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmFsbGJhY2tDbGllbnQuZ2V0U2Vzc2lvbnMoKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRTZXNzaW9uKGlkOiBzdHJpbmcpOiBQcm9taXNlPENoYXRTZXNzaW9uIHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy51c2VGYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mYWxsYmFja0NsaWVudC5nZXRTZXNzaW9uKGlkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCB0aGlzLnJlcXVlc3Q8TW9ja0FQSVNlc3Npb24+KGAvc2Vzc2lvbnMvJHtpZH1gKTtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVNlc3Npb24oc2Vzc2lvbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE1vY2tBUElFcnJvciAmJiBlcnJvci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybignTW9ja0FQSSBmYWlsZWQsIHVzaW5nIGxvY2FsU3RvcmFnZSBmYWxsYmFjazonLCBlcnJvcik7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5mYWxsYmFja0NsaWVudC5nZXRTZXNzaW9uKGlkKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBjcmVhdGVTZXNzaW9uKG5hbWU6IHN0cmluZyk6IFByb21pc2U8Q2hhdFNlc3Npb24+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMudXNlRmFsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmFsbGJhY2tDbGllbnQuY3JlYXRlU2Vzc2lvbihuYW1lKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgY29uc3Qgc2Vzc2lvbkRhdGE6IE9taXQ8TW9ja0FQSVNlc3Npb24sICdpZCc+ID0ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBjcmVhdGVkQXQ6IG5vdyxcbiAgICAgICAgdXBkYXRlZEF0OiBub3csXG4gICAgICAgIG1lc3NhZ2VDb3VudDogMCxcbiAgICAgICAgbGFzdEFjdGl2aXR5OiBub3csXG4gICAgICAgIGlzQWN0aXZlOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgdGhpcy5yZXF1ZXN0PE1vY2tBUElTZXNzaW9uPignL3Nlc3Npb25zJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoc2Vzc2lvbkRhdGEpLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVNlc3Npb24oc2Vzc2lvbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignTW9ja0FQSSBmYWlsZWQsIHVzaW5nIGxvY2FsU3RvcmFnZSBmYWxsYmFjazonLCBlcnJvcik7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5mYWxsYmFja0NsaWVudC5jcmVhdGVTZXNzaW9uKG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZVNlc3Npb24oaWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxQaWNrPENoYXRTZXNzaW9uLCAnbmFtZSc+Pik6IFByb21pc2U8Q2hhdFNlc3Npb24+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMudXNlRmFsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmFsbGJhY2tDbGllbnQudXBkYXRlU2Vzc2lvbihpZCwgdXBkYXRlcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVwZGF0ZURhdGE6IFBhcnRpYWw8TW9ja0FQSVNlc3Npb24+ID0ge1xuICAgICAgICAuLi51cGRhdGVzLFxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfTtcblxuICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IHRoaXMucmVxdWVzdDxNb2NrQVBJU2Vzc2lvbj4oYC9zZXNzaW9ucy8ke2lkfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXBkYXRlRGF0YSksXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU2Vzc2lvbihzZXNzaW9uKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdNb2NrQVBJIGZhaWxlZCwgdXNpbmcgbG9jYWxTdG9yYWdlIGZhbGxiYWNrOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZhbGxiYWNrQ2xpZW50LnVwZGF0ZVNlc3Npb24oaWQsIHVwZGF0ZXMpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZVNlc3Npb24oaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy51c2VGYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mYWxsYmFja0NsaWVudC5kZWxldGVTZXNzaW9uKGlkKTtcbiAgICAgIH1cblxuICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0KGAvc2Vzc2lvbnMvJHtpZH1gLCB7XG4gICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdNb2NrQVBJIGZhaWxlZCwgdXNpbmcgbG9jYWxTdG9yYWdlIGZhbGxiYWNrOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZhbGxiYWNrQ2xpZW50LmRlbGV0ZVNlc3Npb24oaWQpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZVNlc3Npb25BY3Rpdml0eShpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLnVzZUZhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZhbGxiYWNrQ2xpZW50LnVwZGF0ZVNlc3Npb25BY3Rpdml0eShpZCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVwZGF0ZURhdGEgPSB7XG4gICAgICAgIGxhc3RBY3Rpdml0eTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfTtcblxuICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0KGAvc2Vzc2lvbnMvJHtpZH1gLCB7XG4gICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZURhdGEpLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignTW9ja0FQSSBmYWlsZWQsIHVzaW5nIGxvY2FsU3RvcmFnZSBmYWxsYmFjazonLCBlcnJvcik7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5mYWxsYmFja0NsaWVudC51cGRhdGVTZXNzaW9uQWN0aXZpdHkoaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1lc3NhZ2UgTWFuYWdlbWVudFxuICBhc3luYyBnZXRNZXNzYWdlcyhzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8TWVzc2FnZVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLnVzZUZhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZhbGxiYWNrQ2xpZW50LmdldE1lc3NhZ2VzKHNlc3Npb25JZCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gYXdhaXQgdGhpcy5yZXF1ZXN0PE1vY2tBUElNZXNzYWdlW10+KGAvbWVzc2FnZXM/c2Vzc2lvbklkPSR7c2Vzc2lvbklkfWApO1xuICAgICAgcmV0dXJuIG1lc3NhZ2VzLm1hcCh0aGlzLnRyYW5zZm9ybU1lc3NhZ2UpLnNvcnQoKGEsIGIpID0+IFxuICAgICAgICBuZXcgRGF0ZShhLnRpbWVzdGFtcCkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYi50aW1lc3RhbXApLmdldFRpbWUoKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdNb2NrQVBJIGZhaWxlZCwgdXNpbmcgbG9jYWxTdG9yYWdlIGZhbGxiYWNrOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZhbGxiYWNrQ2xpZW50LmdldE1lc3NhZ2VzKHNlc3Npb25JZCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgY3JlYXRlTWVzc2FnZShtZXNzYWdlOiBPbWl0PE1lc3NhZ2UsICdpZCc+KTogUHJvbWlzZTxNZXNzYWdlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLnVzZUZhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZhbGxiYWNrQ2xpZW50LmNyZWF0ZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1lc3NhZ2VEYXRhOiBPbWl0PE1vY2tBUElNZXNzYWdlLCAnaWQnPiA9IHtcbiAgICAgICAgc2Vzc2lvbklkOiBtZXNzYWdlLnNlc3Npb25JZCxcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LFxuICAgICAgICB0eXBlOiBtZXNzYWdlLnR5cGUsXG4gICAgICAgIHRpbWVzdGFtcDogbWVzc2FnZS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiBtZXNzYWdlLnJlc3BvbnNlRGF0YT8udHlwZSxcbiAgICAgICAgcmVzcG9uc2VDb250ZW50OiBtZXNzYWdlLnJlc3BvbnNlRGF0YT8uY29udGVudCxcbiAgICAgICAgcmVzcG9uc2VNZXRhZGF0YTogbWVzc2FnZS5yZXNwb25zZURhdGE/Lm1ldGFkYXRhXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjcmVhdGVkTWVzc2FnZSA9IGF3YWl0IHRoaXMucmVxdWVzdDxNb2NrQVBJTWVzc2FnZT4oJy9tZXNzYWdlcycsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2VEYXRhKSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBVcGRhdGUgc2Vzc2lvbiBtZXNzYWdlIGNvdW50IGFuZCBhY3Rpdml0eVxuICAgICAgYXdhaXQgdGhpcy5pbmNyZW1lbnRTZXNzaW9uTWVzc2FnZUNvdW50KG1lc3NhZ2Uuc2Vzc2lvbklkKTtcblxuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtTWVzc2FnZShjcmVhdGVkTWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignTW9ja0FQSSBmYWlsZWQsIHVzaW5nIGxvY2FsU3RvcmFnZSBmYWxsYmFjazonLCBlcnJvcik7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5mYWxsYmFja0NsaWVudC5jcmVhdGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZU1lc3NhZ2UoaWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxNZXNzYWdlPik6IFByb21pc2U8TWVzc2FnZT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy51c2VGYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mYWxsYmFja0NsaWVudC51cGRhdGVNZXNzYWdlKGlkLCB1cGRhdGVzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXBkYXRlRGF0YTogUGFydGlhbDxNb2NrQVBJTWVzc2FnZT4gPSB7XG4gICAgICAgIGNvbnRlbnQ6IHVwZGF0ZXMuY29udGVudCxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiB1cGRhdGVzLnJlc3BvbnNlRGF0YT8udHlwZSxcbiAgICAgICAgcmVzcG9uc2VDb250ZW50OiB1cGRhdGVzLnJlc3BvbnNlRGF0YT8uY29udGVudCxcbiAgICAgICAgcmVzcG9uc2VNZXRhZGF0YTogdXBkYXRlcy5yZXNwb25zZURhdGE/Lm1ldGFkYXRhXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtZXNzYWdlID0gYXdhaXQgdGhpcy5yZXF1ZXN0PE1vY2tBUElNZXNzYWdlPihgL21lc3NhZ2VzLyR7aWR9YCwge1xuICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVEYXRhKSxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1NZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ01vY2tBUEkgZmFpbGVkLCB1c2luZyBsb2NhbFN0b3JhZ2UgZmFsbGJhY2s6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmFsbGJhY2tDbGllbnQudXBkYXRlTWVzc2FnZShpZCwgdXBkYXRlcyk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZGVsZXRlTWVzc2FnZShpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLnVzZUZhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmZhbGxiYWNrQ2xpZW50LmRlbGV0ZU1lc3NhZ2UoaWQpO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCB0aGlzLnJlcXVlc3QoYC9tZXNzYWdlcy8ke2lkfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ01vY2tBUEkgZmFpbGVkLCB1c2luZyBsb2NhbFN0b3JhZ2UgZmFsbGJhY2s6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmFsbGJhY2tDbGllbnQuZGVsZXRlTWVzc2FnZShpZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXRpbGl0eSBNZXRob2RzXG4gIHByaXZhdGUgYXN5bmMgaW5jcmVtZW50U2Vzc2lvbk1lc3NhZ2VDb3VudChzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCB0aGlzLmdldFNlc3Npb24oc2Vzc2lvbklkKTtcbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0KGAvc2Vzc2lvbnMvJHtzZXNzaW9uSWR9YCwge1xuICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgbWVzc2FnZUNvdW50OiBzZXNzaW9uLm1ldGFkYXRhLm1lc3NhZ2VDb3VudCArIDEsXG4gICAgICAgICAgICBsYXN0QWN0aXZpdHk6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gdXBkYXRlIHNlc3Npb24gbWVzc2FnZSBjb3VudDonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cmFuc2Zvcm1TZXNzaW9uKHNlc3Npb246IE1vY2tBUElTZXNzaW9uKTogQ2hhdFNlc3Npb24ge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogc2Vzc2lvbi5pZCxcbiAgICAgIG5hbWU6IHNlc3Npb24ubmFtZSxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoc2Vzc2lvbi5jcmVhdGVkQXQpLFxuICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShzZXNzaW9uLnVwZGF0ZWRBdCksXG4gICAgICBtZXNzYWdlczogW10sIC8vIE1lc3NhZ2VzIGFyZSBsb2FkZWQgc2VwYXJhdGVseVxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgbWVzc2FnZUNvdW50OiBzZXNzaW9uLm1lc3NhZ2VDb3VudCxcbiAgICAgICAgbGFzdEFjdGl2aXR5OiBuZXcgRGF0ZShzZXNzaW9uLmxhc3RBY3Rpdml0eSksXG4gICAgICAgIGlzQWN0aXZlOiBzZXNzaW9uLmlzQWN0aXZlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgdHJhbnNmb3JtTWVzc2FnZShtZXNzYWdlOiBNb2NrQVBJTWVzc2FnZSk6IE1lc3NhZ2Uge1xuICAgIGxldCByZXNwb25zZURhdGEgPSB1bmRlZmluZWQ7XG4gICAgXG4gICAgaWYgKG1lc3NhZ2UucmVzcG9uc2VUeXBlKSB7XG4gICAgICAvLyBDaGVjayBpZiBzdG9yZWQgY29udGVudCBpcyB0aGUgcHJvYmxlbWF0aWMgbWl4ZWQgZm9ybWF0XG4gICAgICBsZXQgcHJvY2Vzc2VkQ29udGVudCA9IG1lc3NhZ2UucmVzcG9uc2VDb250ZW50O1xuICAgICAgbGV0IHByb2Nlc3NlZFR5cGUgPSBtZXNzYWdlLnJlc3BvbnNlVHlwZTtcbiAgICAgIFxuICAgICAgLy8gSWYgd2UgaGF2ZSBjb250ZW50IHRoYXQgbG9va3MgbGlrZSBtaXhlZCBmb3JtYXQgYnV0IHdhc24ndCBkZXRlY3RlZCBwcm9wZXJseVxuICAgICAgaWYgKHByb2Nlc3NlZENvbnRlbnQgJiYgdHlwZW9mIHByb2Nlc3NlZENvbnRlbnQgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHByb2Nlc3NlZENvbnRlbnQpKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9jZXNzZWRDb250ZW50KTtcbiAgICAgICAgY29uc3QgaGFzVGV4dCA9IGtleXMuc29tZShrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ3RleHQnKSk7XG4gICAgICAgIGNvbnN0IGhhc0NoYXJ0ID0ga2V5cy5zb21lKGtleSA9PiBrZXkuc3RhcnRzV2l0aCgnY2hhcnQnKSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoaGFzVGV4dCB8fCBoYXNDaGFydCkge1xuICAgICAgICAgIC8vIENvbnZlcnQgdG8gbWl4ZWQgZm9ybWF0IGFuZCB3cmFwIGluIGFycmF5XG4gICAgICAgICAgcHJvY2Vzc2VkQ29udGVudCA9IFtwcm9jZXNzZWRDb250ZW50XTtcbiAgICAgICAgICBwcm9jZXNzZWRUeXBlID0gJ21peGVkJztcbiAgICAgICAgICBjb25zb2xlLmxvZygnTW9ja0FQSTogQ29udmVydGVkIHN0b3JlZCBtaXhlZCBjb250ZW50IHRvIGFycmF5IGZvcm1hdCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJlc3BvbnNlRGF0YSA9IHtcbiAgICAgICAgdHlwZTogcHJvY2Vzc2VkVHlwZSxcbiAgICAgICAgY29udGVudDogcHJvY2Vzc2VkQ29udGVudCxcbiAgICAgICAgbWV0YWRhdGE6IG1lc3NhZ2UucmVzcG9uc2VNZXRhZGF0YVxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBtZXNzYWdlLmlkLFxuICAgICAgc2Vzc2lvbklkOiBtZXNzYWdlLnNlc3Npb25JZCxcbiAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCxcbiAgICAgIHR5cGU6IG1lc3NhZ2UudHlwZSxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUobWVzc2FnZS50aW1lc3RhbXApLFxuICAgICAgcmVzcG9uc2VEYXRhXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGhlYWx0aENoZWNrKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy51c2VGYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mYWxsYmFja0NsaWVudC5oZWFsdGhDaGVjaygpO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0KCcvc2Vzc2lvbnM/bGltaXQ9MScpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5mYWxsYmFja0NsaWVudC5oZWFsdGhDaGVjaygpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNsZWFyQWxsRGF0YSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMudXNlRmFsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmFsbGJhY2tDbGllbnQuY2xlYXJBbGxEYXRhKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IFtzZXNzaW9ucywgbWVzc2FnZXNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICB0aGlzLmdldFNlc3Npb25zKCksXG4gICAgICAgIHRoaXMucmVxdWVzdDxNb2NrQVBJTWVzc2FnZVtdPignL21lc3NhZ2VzJylcbiAgICAgIF0pO1xuXG4gICAgICAvLyBEZWxldGUgYWxsIG1lc3NhZ2VzXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgbWVzc2FnZXMubWFwKG1lc3NhZ2UgPT4gdGhpcy5kZWxldGVNZXNzYWdlKG1lc3NhZ2UuaWQpKVxuICAgICAgKTtcblxuICAgICAgLy8gRGVsZXRlIGFsbCBzZXNzaW9uc1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHNlc3Npb25zLm1hcChzZXNzaW9uID0+IHRoaXMuZGVsZXRlU2Vzc2lvbihzZXNzaW9uLmlkKSlcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignTW9ja0FQSSBmYWlsZWQsIHVzaW5nIGxvY2FsU3RvcmFnZSBmYWxsYmFjazonLCBlcnJvcik7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5mYWxsYmFja0NsaWVudC5jbGVhckFsbERhdGEoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRmFjdG9yeSBmdW5jdGlvblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1vY2tBUElDbGllbnQoY29uZmlnOiBNb2NrQVBJQ29uZmlnKTogTW9ja0FQSUNsaWVudCB7XG4gIHJldHVybiBuZXcgTW9ja0FQSUNsaWVudChjb25maWcpO1xufVxuXG4vLyBIb29rIGZvciBSZWFjdCBjb21wb25lbnRzXG5leHBvcnQgZnVuY3Rpb24gdXNlTW9ja0FQSUNsaWVudCgpIHtcbiAgY29uc3QgY2xpZW50ID0gY3JlYXRlTW9ja0FQSUNsaWVudCh7XG4gICAgYmFzZVVybDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTU9DS0FQSV9CQVNFX1VSTCB8fCAnaHR0cHM6Ly9tb2NrYXBpLmlvL2FwaS92MScsXG4gICAgcHJvamVjdElkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19NT0NLQVBJX1BST0pFQ1RfSUQgfHwgJ3lvdXItcHJvamVjdC1pZCdcbiAgfSk7XG5cbiAgcmV0dXJuIGNsaWVudDtcbn1cblxuLy8gVXRpbGl0eSBmdW5jdGlvbnNcbmV4cG9ydCBjb25zdCBtb2NrQVBJVXRpbHMgPSB7XG4gIC8qKlxuICAgKiBGb3JtYXQgZXJyb3IgZm9yIHVzZXIgZGlzcGxheVxuICAgKi9cbiAgZm9ybWF0RXJyb3IoZXJyb3I6IE1vY2tBUElFcnJvcik6IHN0cmluZyB7XG4gICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICByZXR1cm4gJ1Jlc291cmNlIG5vdCBmb3VuZCc7XG4gICAgfVxuICAgIGlmIChlcnJvci5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgcmV0dXJuICdUb28gbWFueSByZXF1ZXN0cy4gUGxlYXNlIHdhaXQgYW5kIHRyeSBhZ2Fpbi4nO1xuICAgIH1cbiAgICBpZiAoZXJyb3Iuc3RhdHVzICYmIGVycm9yLnN0YXR1cyA+PSA1MDApIHtcbiAgICAgIHJldHVybiAnU2VydmVyIGVycm9yLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLic7XG4gICAgfVxuICAgIHJldHVybiAnQW4gZXJyb3Igb2NjdXJyZWQuIFBsZWFzZSB0cnkgYWdhaW4uJztcbiAgfSxcblxuICAvKipcbiAgICogVmFsaWRhdGUgc2Vzc2lvbiBuYW1lXG4gICAqL1xuICB2YWxpZGF0ZVNlc3Npb25OYW1lKG5hbWU6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIGlmICghbmFtZS50cmltKCkpIHtcbiAgICAgIHJldHVybiAnU2Vzc2lvbiBuYW1lIGNhbm5vdCBiZSBlbXB0eSc7XG4gICAgfVxuICAgIGlmIChuYW1lLmxlbmd0aCA+IDEwMCkge1xuICAgICAgcmV0dXJuICdTZXNzaW9uIG5hbWUgY2Fubm90IGV4Y2VlZCAxMDAgY2hhcmFjdGVycyc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59OyJdLCJuYW1lcyI6WyJNb2NrQVBJRXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJkZXRhaWxzIiwibmFtZSIsIkxvY2FsU3RvcmFnZU1vY2tBUElDbGllbnQiLCJnZW5lcmF0ZUlkIiwiRGF0ZSIsIm5vdyIsInRvU3RyaW5nIiwiTWF0aCIsInJhbmRvbSIsInN1YnN0ciIsImdldFN0b3JhZ2VEYXRhIiwia2V5IiwiZGF0YSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJzZXRTdG9yYWdlRGF0YSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJlcnJvciIsImNvbnNvbGUiLCJnZXRTZXNzaW9ucyIsInNlc3Npb25zIiwiU0VTU0lPTlNfS0VZIiwibWFwIiwidHJhbnNmb3JtU2Vzc2lvbiIsImdldFNlc3Npb24iLCJpZCIsInNlc3Npb24iLCJmaW5kIiwicyIsImNyZWF0ZVNlc3Npb24iLCJ0b0lTT1N0cmluZyIsInNlc3Npb25EYXRhIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwibWVzc2FnZUNvdW50IiwibGFzdEFjdGl2aXR5IiwiaXNBY3RpdmUiLCJwdXNoIiwidXBkYXRlU2Vzc2lvbiIsInVwZGF0ZXMiLCJpbmRleCIsImZpbmRJbmRleCIsImRlbGV0ZVNlc3Npb24iLCJmaWx0ZXJlZFNlc3Npb25zIiwiZmlsdGVyIiwibWVzc2FnZXMiLCJNRVNTQUdFU19LRVkiLCJmaWx0ZXJlZE1lc3NhZ2VzIiwibSIsInNlc3Npb25JZCIsInVwZGF0ZVNlc3Npb25BY3Rpdml0eSIsImdldE1lc3NhZ2VzIiwidHJhbnNmb3JtTWVzc2FnZSIsInNvcnQiLCJhIiwiYiIsInRpbWVzdGFtcCIsImdldFRpbWUiLCJjcmVhdGVNZXNzYWdlIiwibWVzc2FnZUlkIiwibG9nIiwidHlwZSIsIm1lc3NhZ2VEYXRhIiwiY29udGVudCIsInJlc3BvbnNlVHlwZSIsInJlc3BvbnNlRGF0YSIsInJlc3BvbnNlQ29udGVudCIsInJlc3BvbnNlTWV0YWRhdGEiLCJtZXRhZGF0YSIsImV4aXN0aW5nTWVzc2FnZSIsImFicyIsImluY3JlbWVudFNlc3Npb25NZXNzYWdlQ291bnQiLCJ1cGRhdGVNZXNzYWdlIiwiZGVsZXRlTWVzc2FnZSIsInVuZGVmaW5lZCIsInByb2Nlc3NlZENvbnRlbnQiLCJwcm9jZXNzZWRUeXBlIiwiQXJyYXkiLCJpc0FycmF5Iiwia2V5cyIsIk9iamVjdCIsImhhc1RleHQiLCJzb21lIiwic3RhcnRzV2l0aCIsImhhc0NoYXJ0IiwiaGVhbHRoQ2hlY2siLCJ3aW5kb3ciLCJjbGVhckFsbERhdGEiLCJyZW1vdmVJdGVtIiwiTW9ja0FQSUNsaWVudCIsInJlcXVlc3QiLCJlbmRwb2ludCIsIm9wdGlvbnMiLCJ1c2VGYWxsYmFjayIsInVybCIsImJhc2VVcmwiLCJ0aW1lb3V0IiwiY29uZmlnIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJzaWduYWwiLCJBYm9ydFNpZ25hbCIsIm9rIiwic3RhdHVzVGV4dCIsImpzb24iLCJpbmNsdWRlcyIsImZhbGxiYWNrQ2xpZW50Iiwid2FybiIsIm1ldGhvZCIsImJvZHkiLCJ1cGRhdGVEYXRhIiwiY3JlYXRlZE1lc3NhZ2UiLCJQcm9taXNlIiwiYWxsIiwicHJvamVjdElkIiwiY3JlYXRlTW9ja0FQSUNsaWVudCIsInVzZU1vY2tBUElDbGllbnQiLCJjbGllbnQiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfTU9DS0FQSV9CQVNFX1VSTCIsIk5FWFRfUFVCTElDX01PQ0tBUElfUFJPSkVDVF9JRCIsIm1vY2tBUElVdGlscyIsImZvcm1hdEVycm9yIiwidmFsaWRhdGVTZXNzaW9uTmFtZSIsInRyaW0iLCJsZW5ndGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/mockapi-client.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/n8n-client.ts":
/*!***************************!*\
  !*** ./lib/n8n-client.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   N8NClient: () => (/* binding */ N8NClient),\n/* harmony export */   N8NError: () => (/* binding */ N8NError),\n/* harmony export */   createN8NClient: () => (/* binding */ createN8NClient),\n/* harmony export */   n8nClientExample: () => (/* binding */ n8nClientExample),\n/* harmony export */   n8nUtils: () => (/* binding */ n8nUtils)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * n8n Webhook Client\n * Handles communication with n8n workflows via webhook and streaming endpoints\n */ class N8NError extends Error {\n    constructor(message, type, details){\n        super(message), this.type = type, this.details = details;\n        this.name = 'N8NError';\n    }\n}\nclass N8NClient {\n    /**\n   * Send a message to n8n webhook\n   */ async sendMessage(request) {\n        const { webhookUrl, timeout } = this.config;\n        try {\n            console.log('=== N8N WEBHOOK DEBUG ===');\n            console.log('Webhook URL:', webhookUrl);\n            console.log('Request payload:', JSON.stringify(request, null, 2));\n            const response = await fetch(webhookUrl, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Accept': 'application/json'\n                },\n                body: JSON.stringify(request)\n            });\n            console.log('Response status:', response.status);\n            console.log('Response headers:', Object.fromEntries(response.headers.entries()));\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('Error response body:', errorText);\n                throw new N8NError(\"HTTP \".concat(response.status, \": \").concat(response.statusText), 'server', {\n                    status: response.status,\n                    statusText: response.statusText,\n                    body: errorText\n                });\n            }\n            const responseText = await response.text();\n            console.log('Raw response:', responseText);\n            let data;\n            try {\n                data = JSON.parse(responseText);\n            } catch (parseError) {\n                console.log('Response is not JSON, treating as plain text');\n                data = responseText;\n            }\n            console.log('Parsed response data:', data);\n            const validatedResponse = this.validateResponse(data);\n            console.log('Validated response:', validatedResponse);\n            console.log('=== END N8N WEBHOOK DEBUG ===');\n            return validatedResponse;\n        } catch (error) {\n            console.error('=== N8N WEBHOOK ERROR ===');\n            console.error('Error details:', error);\n            console.error('Error type:', error instanceof Error ? error.constructor.name : typeof error);\n            console.error('Error message:', error instanceof Error ? error.message : String(error));\n            console.error('=== END N8N WEBHOOK ERROR ===');\n            if (error instanceof Error) {\n                if (error.name === 'TimeoutError' || error.name === 'AbortError') {\n                    throw new N8NError('Request timeout', 'timeout');\n                }\n                if (error.message.includes('fetch') || error.message.includes('network')) {\n                    throw new N8NError('Network error', 'network', error);\n                }\n            }\n            throw error;\n        }\n    }\n    /**\n   * Set up streaming connection for real-time updates\n   */ async *streamMessages(sessionId) {\n        const { streamingUrl } = this.config;\n        const url = new URL(streamingUrl);\n        url.searchParams.set('sessionId', sessionId);\n        try {\n            var _response_body;\n            const response = await fetch(url.toString(), {\n                headers: {\n                    'Accept': 'text/event-stream',\n                    'Cache-Control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                throw new N8NError(\"Streaming failed: \".concat(response.status), 'server', {\n                    status: response.status\n                });\n            }\n            const reader = (_response_body = response.body) === null || _response_body === void 0 ? void 0 : _response_body.getReader();\n            if (!reader) {\n                throw new N8NError('No response body', 'server');\n            }\n            const decoder = new TextDecoder();\n            let buffer = '';\n            try {\n                while(true){\n                    const { done, value } = await reader.read();\n                    if (done) break;\n                    buffer += decoder.decode(value, {\n                        stream: true\n                    });\n                    const lines = buffer.split('\\n');\n                    // Keep the last incomplete line in buffer\n                    buffer = lines.pop() || '';\n                    for (const line of lines){\n                        if (line.trim() === '') continue;\n                        if (line.startsWith('data: ')) {\n                            const data = line.slice(6);\n                            if (data === '[DONE]') {\n                                return;\n                            }\n                            try {\n                                const parsed = JSON.parse(data);\n                                const response = this.validateResponse(parsed);\n                                yield response;\n                            } catch (error) {\n                                console.warn('Failed to parse streaming data:', error);\n                            }\n                        }\n                    }\n                }\n            } finally{\n                reader.releaseLock();\n            }\n        } catch (error) {\n            if (error instanceof N8NError) {\n                throw error;\n            }\n            throw new N8NError('Streaming connection failed', 'network', error);\n        }\n    }\n    /**\n   * Send message with retry logic\n   */ async sendMessageWithRetry(request) {\n        const { retryAttempts, retryDelay } = this.config;\n        for(let attempt = 1; attempt <= retryAttempts; attempt++){\n            try {\n                return await this.sendMessage(request);\n            } catch (error) {\n                if (error instanceof N8NError) {\n                    // Don't retry validation errors\n                    if (error.type === 'validation') {\n                        throw error;\n                    }\n                    // Don't retry on final attempt\n                    if (attempt === retryAttempts) {\n                        throw error;\n                    }\n                    // Wait before retry\n                    await new Promise((resolve)=>setTimeout(resolve, retryDelay * attempt));\n                } else {\n                    throw error;\n                }\n            }\n        }\n        throw new N8NError('Max retry attempts reached', 'network');\n    }\n    /**\n   * Remove duplicate content from response\n   */ deduplicateContent(content) {\n        if (typeof content !== 'string') {\n            return content;\n        }\n        // Split content into lines\n        const lines = content.split('\\n');\n        const seenLines = new Set();\n        const deduplicatedLines = [];\n        for (const line of lines){\n            const trimmedLine = line.trim();\n            // Skip empty lines for deduplication check\n            if (trimmedLine === '') {\n                deduplicatedLines.push(line);\n                continue;\n            }\n            // If we haven't seen this line before, add it\n            if (!seenLines.has(trimmedLine)) {\n                seenLines.add(trimmedLine);\n                deduplicatedLines.push(line);\n            }\n        }\n        return deduplicatedLines.join('\\n');\n    }\n    /**\n   * Detect if content is mixed format (contains text and chart keys)\n   */ isMixedContent(content) {\n        if (!Array.isArray(content)) return false;\n        return content.some((item)=>{\n            if (!item || typeof item !== 'object') return false;\n            const keys = Object.keys(item);\n            const hasText = keys.some((key)=>key.startsWith('text'));\n            const hasChart = keys.some((key)=>key.startsWith('chart'));\n            return hasText || hasChart;\n        });\n    }\n    /**\n   * Validate n8n response format\n   */ validateResponse(data) {\n        if (!data || typeof data !== 'object') {\n            // If we get a simple response, wrap it in our expected format\n            return {\n                type: 'final',\n                messageType: 'text',\n                content: String(data),\n                metadata: {\n                    timestamp: new Date()\n                }\n            };\n        }\n        // Check if response already has our expected format\n        if (data.type && data.messageType && data.content !== undefined) {\n            return {\n                type: data.type,\n                messageType: data.messageType,\n                content: data.messageType === 'text' ? this.deduplicateContent(data.content) : data.content,\n                metadata: data.metadata || {\n                    timestamp: new Date()\n                }\n            };\n        }\n        // Handle various possible n8n response formats\n        let content = data.content || data.message || data.response || data.text || data.output || data;\n        let messageType = data.messageType || data.format || 'text';\n        let type = data.type || 'final';\n        // Special handling for n8n output field that contains JSON string\n        if (data.output && typeof data.output === 'string') {\n            try {\n                const parsedOutput = JSON.parse(data.output);\n                if (parsedOutput && typeof parsedOutput === 'object') {\n                    // If the output contains a valid JSON object, use it as the base\n                    content = parsedOutput.content || parsedOutput;\n                    messageType = parsedOutput.messageType || messageType;\n                    type = parsedOutput.type || type;\n                }\n            } catch (error) {\n                // If parsing fails, treat output as regular text content\n                console.warn('Failed to parse n8n output as JSON:', error);\n            }\n        }\n        // Check if this is a mixed content response (array with text/chart combinations)\n        if (this.isMixedContent(content)) {\n            messageType = 'mixed';\n        } else if (Array.isArray(content)) {\n            // If it's an array but not mixed content, treat as JSON\n            messageType = 'json';\n        }\n        // Validate messageType\n        if (![\n            'text',\n            'json',\n            'image',\n            'chart',\n            'error',\n            'mixed'\n        ].includes(messageType)) {\n            messageType = 'text';\n        }\n        // Validate type\n        if (![\n            'interim',\n            'final'\n        ].includes(type)) {\n            type = 'final';\n        }\n        return {\n            type,\n            messageType,\n            content: messageType === 'text' ? this.deduplicateContent(content) : content,\n            metadata: data.metadata || {\n                timestamp: new Date(),\n                source: 'n8n-webhook',\n                originalResponse: data\n            }\n        };\n    }\n    /**\n   * Cancel ongoing request\n   */ cancel() {\n        // Requests now use AbortSignal.timeout() which auto-cancels\n        console.log('Cancel requested - using timeout-based cancellation');\n    }\n    /**\n   * Health check endpoint\n   */ async healthCheck() {\n        try {\n            const response = await fetch(\"\".concat(this.config.webhookUrl, \"/health\"), {\n                method: 'GET',\n                signal: AbortSignal.timeout(5000)\n            });\n            return response.ok;\n        } catch (e) {\n            return false;\n        }\n    }\n    constructor(config){\n        this.config = {\n            timeout: 120000,\n            retryAttempts: 3,\n            retryDelay: 1000,\n            ...config\n        };\n    }\n}\n// Factory function for creating client instances\nfunction createN8NClient(config) {\n    return new N8NClient(config);\n}\n// Example usage\nconst n8nClientExample = ()=>{\n    const client = createN8NClient({\n        webhookUrl: process.env.N8N_WEBHOOK_URL,\n        streamingUrl: process.env.N8N_STREAMING_URL,\n        timeout: 30000,\n        retryAttempts: 3,\n        retryDelay: 1000\n    });\n    // Example: Send message\n    const sendMessage = async ()=>{\n        try {\n            const request = {\n                username: 'user123',\n                message: 'Hello, can you analyze this data?',\n                sessionId: 'session-123',\n                timestamp: new Date()\n            };\n            const response = await client.sendMessageWithRetry(request);\n            console.log('Response:', response);\n        } catch (error) {\n            if (error instanceof N8NError) {\n                console.error('N8N Error:', error.message, error.type);\n            } else {\n                console.error('Unexpected error:', error);\n            }\n        }\n    };\n    // Example: Stream messages\n    const streamMessages = async ()=>{\n        try {\n            const sessionId = 'session-123';\n            for await (const response of client.streamMessages(sessionId)){\n                console.log('Streaming response:', response);\n                if (response.type === 'final') {\n                    break;\n                }\n            }\n        } catch (error) {\n            console.error('Streaming error:', error);\n        }\n    };\n    return {\n        sendMessage,\n        streamMessages\n    };\n};\n// Utility functions for common operations\nconst n8nUtils = {\n    /**\n   * Format error for user display\n   */ formatError (error) {\n        switch(error.type){\n            case 'network':\n                return 'Network connection failed. Please check your internet connection.';\n            case 'timeout':\n                return 'Request timed out. The workflow may be taking longer than expected.';\n            case 'server':\n                return 'Server error occurred. Please try again later.';\n            case 'validation':\n                return 'Invalid data format. Please contact support.';\n            default:\n                return 'An unexpected error occurred. Please try again.';\n        }\n    },\n    /**\n   * Check if response is interim message\n   */ isInterimMessage (response) {\n        return response.type === 'interim';\n    },\n    /**\n   * Check if response is final message\n   */ isFinalMessage (response) {\n        return response.type === 'final';\n    },\n    /**\n   * Extract processing time from metadata\n   */ getProcessingTime (response) {\n        var _response_metadata;\n        return ((_response_metadata = response.metadata) === null || _response_metadata === void 0 ? void 0 : _response_metadata.processingTime) || null;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9uOG4tY2xpZW50LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQUlNLE1BQU1BLGlCQUFpQkM7SUFDNUIsWUFDRUMsT0FBZSxFQUNmLElBQTRELEVBQzVELE9BQW9CLENBQ3BCO1FBQ0EsS0FBSyxDQUFDQSxlQUhDQyxPQUFBQSxXQUNBQyxVQUFBQTtRQUdQLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2Q7QUFDRjtBQVVPLE1BQU1DO0lBWVg7O0dBRUMsR0FDRCxNQUFNQyxZQUFZQyxPQUFtQixFQUF3QjtRQUMzRCxNQUFNLEVBQUVDLFVBQVUsRUFBRUMsT0FBTyxFQUFFLEdBQUcsSUFBSSxDQUFDQyxNQUFNO1FBRTNDLElBQUk7WUFDRkMsUUFBUUMsR0FBRyxDQUFDO1lBQ1pELFFBQVFDLEdBQUcsQ0FBQyxnQkFBZ0JKO1lBQzVCRyxRQUFRQyxHQUFHLENBQUMsb0JBQW9CQyxLQUFLQyxTQUFTLENBQUNQLFNBQVMsTUFBTTtZQUU5RCxNQUFNUSxXQUFXLE1BQU1DLE1BQU1SLFlBQVk7Z0JBQ3ZDUyxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsVUFBVTtnQkFDWjtnQkFDQUMsTUFBTU4sS0FBS0MsU0FBUyxDQUFDUDtZQUN2QjtZQUVBSSxRQUFRQyxHQUFHLENBQUMsb0JBQW9CRyxTQUFTSyxNQUFNO1lBQy9DVCxRQUFRQyxHQUFHLENBQUMscUJBQXFCUyxPQUFPQyxXQUFXLENBQUNQLFNBQVNHLE9BQU8sQ0FBQ0ssT0FBTztZQUU1RSxJQUFJLENBQUNSLFNBQVNTLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsWUFBWSxNQUFNVixTQUFTVyxJQUFJO2dCQUNyQ2YsUUFBUWdCLEtBQUssQ0FBQyx3QkFBd0JGO2dCQUN0QyxNQUFNLElBQUkxQixTQUNSLFFBQTRCZ0IsT0FBcEJBLFNBQVNLLE1BQU0sRUFBQyxNQUF3QixPQUFwQkwsU0FBU2EsVUFBVSxHQUMvQyxVQUNBO29CQUFFUixRQUFRTCxTQUFTSyxNQUFNO29CQUFFUSxZQUFZYixTQUFTYSxVQUFVO29CQUFFVCxNQUFNTTtnQkFBVTtZQUVoRjtZQUVBLE1BQU1JLGVBQWUsTUFBTWQsU0FBU1csSUFBSTtZQUN4Q2YsUUFBUUMsR0FBRyxDQUFDLGlCQUFpQmlCO1lBRTdCLElBQUlDO1lBQ0osSUFBSTtnQkFDRkEsT0FBT2pCLEtBQUtrQixLQUFLLENBQUNGO1lBQ3BCLEVBQUUsT0FBT0csWUFBWTtnQkFDbkJyQixRQUFRQyxHQUFHLENBQUM7Z0JBQ1prQixPQUFPRDtZQUNUO1lBRUFsQixRQUFRQyxHQUFHLENBQUMseUJBQXlCa0I7WUFDckMsTUFBTUcsb0JBQW9CLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNKO1lBQ2hEbkIsUUFBUUMsR0FBRyxDQUFDLHVCQUF1QnFCO1lBQ25DdEIsUUFBUUMsR0FBRyxDQUFDO1lBRVosT0FBT3FCO1FBQ1QsRUFBRSxPQUFPTixPQUFPO1lBQ2RoQixRQUFRZ0IsS0FBSyxDQUFDO1lBQ2RoQixRQUFRZ0IsS0FBSyxDQUFDLGtCQUFrQkE7WUFDaENoQixRQUFRZ0IsS0FBSyxDQUFDLGVBQWVBLGlCQUFpQjNCLFFBQVEyQixNQUFNLFdBQVcsQ0FBQ3ZCLElBQUksR0FBRyxPQUFPdUI7WUFDdEZoQixRQUFRZ0IsS0FBSyxDQUFDLGtCQUFrQkEsaUJBQWlCM0IsUUFBUTJCLE1BQU0xQixPQUFPLEdBQUdrQyxPQUFPUjtZQUNoRmhCLFFBQVFnQixLQUFLLENBQUM7WUFFZCxJQUFJQSxpQkFBaUIzQixPQUFPO2dCQUMxQixJQUFJMkIsTUFBTXZCLElBQUksS0FBSyxrQkFBa0J1QixNQUFNdkIsSUFBSSxLQUFLLGNBQWM7b0JBQ2hFLE1BQU0sSUFBSUwsU0FBUyxtQkFBbUI7Z0JBQ3hDO2dCQUVBLElBQUk0QixNQUFNMUIsT0FBTyxDQUFDbUMsUUFBUSxDQUFDLFlBQVlULE1BQU0xQixPQUFPLENBQUNtQyxRQUFRLENBQUMsWUFBWTtvQkFDeEUsTUFBTSxJQUFJckMsU0FBUyxpQkFBaUIsV0FBVzRCO2dCQUNqRDtZQUNGO1lBRUEsTUFBTUE7UUFDUjtJQUNGO0lBRUE7O0dBRUMsR0FDRCxPQUFPVSxlQUFlQyxTQUFpQixFQUE4QztRQUNuRixNQUFNLEVBQUVDLFlBQVksRUFBRSxHQUFHLElBQUksQ0FBQzdCLE1BQU07UUFDcEMsTUFBTThCLE1BQU0sSUFBSUMsSUFBSUY7UUFDcEJDLElBQUlFLFlBQVksQ0FBQ0MsR0FBRyxDQUFDLGFBQWFMO1FBRWxDLElBQUk7Z0JBZ0JhdkI7WUFmZixNQUFNQSxXQUFXLE1BQU1DLE1BQU13QixJQUFJSSxRQUFRLElBQUk7Z0JBQzNDMUIsU0FBUztvQkFDUCxVQUFVO29CQUNWLGlCQUFpQjtnQkFDbkI7WUFDRjtZQUVBLElBQUksQ0FBQ0gsU0FBU1MsRUFBRSxFQUFFO2dCQUNoQixNQUFNLElBQUl6QixTQUNSLHFCQUFxQyxPQUFoQmdCLFNBQVNLLE1BQU0sR0FDcEMsVUFDQTtvQkFBRUEsUUFBUUwsU0FBU0ssTUFBTTtnQkFBQztZQUU5QjtZQUVBLE1BQU15QixVQUFTOUIsaUJBQUFBLFNBQVNJLElBQUksY0FBYkoscUNBQUFBLGVBQWUrQixTQUFTO1lBQ3ZDLElBQUksQ0FBQ0QsUUFBUTtnQkFDWCxNQUFNLElBQUk5QyxTQUFTLG9CQUFvQjtZQUN6QztZQUVBLE1BQU1nRCxVQUFVLElBQUlDO1lBQ3BCLElBQUlDLFNBQVM7WUFFYixJQUFJO2dCQUNGLE1BQU8sS0FBTTtvQkFDWCxNQUFNLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTU4sT0FBT08sSUFBSTtvQkFFekMsSUFBSUYsTUFBTTtvQkFFVkQsVUFBVUYsUUFBUU0sTUFBTSxDQUFDRixPQUFPO3dCQUFFRyxRQUFRO29CQUFLO29CQUMvQyxNQUFNQyxRQUFRTixPQUFPTyxLQUFLLENBQUM7b0JBRTNCLDBDQUEwQztvQkFDMUNQLFNBQVNNLE1BQU1FLEdBQUcsTUFBTTtvQkFFeEIsS0FBSyxNQUFNQyxRQUFRSCxNQUFPO3dCQUN4QixJQUFJRyxLQUFLQyxJQUFJLE9BQU8sSUFBSTt3QkFFeEIsSUFBSUQsS0FBS0UsVUFBVSxDQUFDLFdBQVc7NEJBQzdCLE1BQU05QixPQUFPNEIsS0FBS0csS0FBSyxDQUFDOzRCQUV4QixJQUFJL0IsU0FBUyxVQUFVO2dDQUNyQjs0QkFDRjs0QkFFQSxJQUFJO2dDQUNGLE1BQU1nQyxTQUFTakQsS0FBS2tCLEtBQUssQ0FBQ0Q7Z0NBQzFCLE1BQU1mLFdBQVcsSUFBSSxDQUFDbUIsZ0JBQWdCLENBQUM0QjtnQ0FDdkMsTUFBTS9DOzRCQUNSLEVBQUUsT0FBT1ksT0FBTztnQ0FDZGhCLFFBQVFvRCxJQUFJLENBQUMsbUNBQW1DcEM7NEJBQ2xEO3dCQUNGO29CQUNGO2dCQUNGO1lBQ0YsU0FBVTtnQkFDUmtCLE9BQU9tQixXQUFXO1lBQ3BCO1FBQ0YsRUFBRSxPQUFPckMsT0FBTztZQUNkLElBQUlBLGlCQUFpQjVCLFVBQVU7Z0JBQzdCLE1BQU00QjtZQUNSO1lBRUEsTUFBTSxJQUFJNUIsU0FDUiwrQkFDQSxXQUNBNEI7UUFFSjtJQUNGO0lBRUE7O0dBRUMsR0FDRCxNQUFNc0MscUJBQXFCMUQsT0FBbUIsRUFBd0I7UUFDcEUsTUFBTSxFQUFFMkQsYUFBYSxFQUFFQyxVQUFVLEVBQUUsR0FBRyxJQUFJLENBQUN6RCxNQUFNO1FBRWpELElBQUssSUFBSTBELFVBQVUsR0FBR0EsV0FBV0YsZUFBZUUsVUFBVztZQUN6RCxJQUFJO2dCQUNGLE9BQU8sTUFBTSxJQUFJLENBQUM5RCxXQUFXLENBQUNDO1lBQ2hDLEVBQUUsT0FBT29CLE9BQU87Z0JBQ2QsSUFBSUEsaUJBQWlCNUIsVUFBVTtvQkFDN0IsZ0NBQWdDO29CQUNoQyxJQUFJNEIsTUFBTXpCLElBQUksS0FBSyxjQUFjO3dCQUMvQixNQUFNeUI7b0JBQ1I7b0JBRUEsK0JBQStCO29CQUMvQixJQUFJeUMsWUFBWUYsZUFBZTt3QkFDN0IsTUFBTXZDO29CQUNSO29CQUVBLG9CQUFvQjtvQkFDcEIsTUFBTSxJQUFJMEMsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBU0gsYUFBYUM7Z0JBQ2hFLE9BQU87b0JBQ0wsTUFBTXpDO2dCQUNSO1lBQ0Y7UUFDRjtRQUVBLE1BQU0sSUFBSTVCLFNBQVMsOEJBQThCO0lBQ25EO0lBRUE7O0dBRUMsR0FDRCxtQkFBMkIwRSxPQUFlLEVBQVU7UUFDbEQsSUFBSSxPQUFPQSxZQUFZLFVBQVU7WUFDL0IsT0FBT0E7UUFDVDtRQUVBLDJCQUEyQjtRQUMzQixNQUFNbEIsUUFBUWtCLFFBQVFqQixLQUFLLENBQUM7UUFDNUIsTUFBTWtCLFlBQVksSUFBSUM7UUFDdEIsTUFBTUMsb0JBQThCLEVBQUU7UUFFdEMsS0FBSyxNQUFNbEIsUUFBUUgsTUFBTztZQUN4QixNQUFNc0IsY0FBY25CLEtBQUtDLElBQUk7WUFFN0IsMkNBQTJDO1lBQzNDLElBQUlrQixnQkFBZ0IsSUFBSTtnQkFDdEJELGtCQUFrQkUsSUFBSSxDQUFDcEI7Z0JBQ3ZCO1lBQ0Y7WUFFQSw4Q0FBOEM7WUFDOUMsSUFBSSxDQUFDZ0IsVUFBVUssR0FBRyxDQUFDRixjQUFjO2dCQUMvQkgsVUFBVU0sR0FBRyxDQUFDSDtnQkFDZEQsa0JBQWtCRSxJQUFJLENBQUNwQjtZQUN6QjtRQUNGO1FBRUEsT0FBT2tCLGtCQUFrQkssSUFBSSxDQUFDO0lBQ2hDO0lBRUE7O0dBRUMsR0FDRCxlQUF1QlIsT0FBWSxFQUFXO1FBQzVDLElBQUksQ0FBQ1UsTUFBTUMsT0FBTyxDQUFDWCxVQUFVLE9BQU87UUFFcEMsT0FBT0EsUUFBUVksSUFBSSxDQUFDQyxDQUFBQTtZQUNsQixJQUFJLENBQUNBLFFBQVEsT0FBT0EsU0FBUyxVQUFVLE9BQU87WUFFOUMsTUFBTUMsT0FBT2xFLE9BQU9rRSxJQUFJLENBQUNEO1lBQ3pCLE1BQU1FLFVBQVVELEtBQUtGLElBQUksQ0FBQ0ksQ0FBQUEsTUFBT0EsSUFBSTdCLFVBQVUsQ0FBQztZQUNoRCxNQUFNOEIsV0FBV0gsS0FBS0YsSUFBSSxDQUFDSSxDQUFBQSxNQUFPQSxJQUFJN0IsVUFBVSxDQUFDO1lBRWpELE9BQU80QixXQUFXRTtRQUNwQjtJQUNGO0lBRUE7O0dBRUMsR0FDRCxpQkFBeUI1RCxJQUFTLEVBQWU7UUFDL0MsSUFBSSxDQUFDQSxRQUFRLE9BQU9BLFNBQVMsVUFBVTtZQUNyQyw4REFBOEQ7WUFDOUQsT0FBTztnQkFDTDVCLE1BQU07Z0JBQ055RixhQUFhO2dCQUNibEIsU0FBU3RDLE9BQU9MO2dCQUNoQjhELFVBQVU7b0JBQUVDLFdBQVcsSUFBSUM7Z0JBQU87WUFDcEM7UUFDRjtRQUVBLG9EQUFvRDtRQUNwRCxJQUFJaEUsS0FBSzVCLElBQUksSUFBSTRCLEtBQUs2RCxXQUFXLElBQUk3RCxLQUFLMkMsT0FBTyxLQUFLc0IsV0FBVztZQUMvRCxPQUFPO2dCQUNMN0YsTUFBTTRCLEtBQUs1QixJQUFJO2dCQUNmeUYsYUFBYTdELEtBQUs2RCxXQUFXO2dCQUM3QmxCLFNBQVMzQyxLQUFLNkQsV0FBVyxLQUFLLFNBQVMsSUFBSSxDQUFDbkIsa0JBQWtCLENBQUMxQyxLQUFLMkMsT0FBTyxJQUFJM0MsS0FBSzJDLE9BQU87Z0JBQzNGbUIsVUFBVTlELEtBQUs4RCxRQUFRLElBQUk7b0JBQUVDLFdBQVcsSUFBSUM7Z0JBQU87WUFDckQ7UUFDRjtRQUVBLCtDQUErQztRQUMvQyxJQUFJckIsVUFBVTNDLEtBQUsyQyxPQUFPLElBQUkzQyxLQUFLN0IsT0FBTyxJQUFJNkIsS0FBS2YsUUFBUSxJQUFJZSxLQUFLSixJQUFJLElBQUlJLEtBQUtrRSxNQUFNLElBQUlsRTtRQUMzRixJQUFJNkQsY0FBYzdELEtBQUs2RCxXQUFXLElBQUk3RCxLQUFLbUUsTUFBTSxJQUFJO1FBQ3JELElBQUkvRixPQUFPNEIsS0FBSzVCLElBQUksSUFBSTtRQUV4QixrRUFBa0U7UUFDbEUsSUFBSTRCLEtBQUtrRSxNQUFNLElBQUksT0FBT2xFLEtBQUtrRSxNQUFNLEtBQUssVUFBVTtZQUNsRCxJQUFJO2dCQUNGLE1BQU1FLGVBQWVyRixLQUFLa0IsS0FBSyxDQUFDRCxLQUFLa0UsTUFBTTtnQkFDM0MsSUFBSUUsZ0JBQWdCLE9BQU9BLGlCQUFpQixVQUFVO29CQUNwRCxpRUFBaUU7b0JBQ2pFekIsVUFBVXlCLGFBQWF6QixPQUFPLElBQUl5QjtvQkFDbENQLGNBQWNPLGFBQWFQLFdBQVcsSUFBSUE7b0JBQzFDekYsT0FBT2dHLGFBQWFoRyxJQUFJLElBQUlBO2dCQUM5QjtZQUNGLEVBQUUsT0FBT3lCLE9BQU87Z0JBQ2QseURBQXlEO2dCQUN6RGhCLFFBQVFvRCxJQUFJLENBQUMsdUNBQXVDcEM7WUFDdEQ7UUFDRjtRQUVBLGlGQUFpRjtRQUNqRixJQUFJLElBQUksQ0FBQ3VELGNBQWMsQ0FBQ1QsVUFBVTtZQUNoQ2tCLGNBQWM7UUFDaEIsT0FBTyxJQUFJUixNQUFNQyxPQUFPLENBQUNYLFVBQVU7WUFDakMsd0RBQXdEO1lBQ3hEa0IsY0FBYztRQUNoQjtRQUVBLHVCQUF1QjtRQUN2QixJQUFJLENBQUM7WUFBQztZQUFRO1lBQVE7WUFBUztZQUFTO1lBQVM7U0FBUSxDQUFDdkQsUUFBUSxDQUFDdUQsY0FBYztZQUMvRUEsY0FBYztRQUNoQjtRQUVBLGdCQUFnQjtRQUNoQixJQUFJLENBQUM7WUFBQztZQUFXO1NBQVEsQ0FBQ3ZELFFBQVEsQ0FBQ2xDLE9BQU87WUFDeENBLE9BQU87UUFDVDtRQUVBLE9BQU87WUFDTEE7WUFDQXlGO1lBQ0FsQixTQUFTa0IsZ0JBQWdCLFNBQVMsSUFBSSxDQUFDbkIsa0JBQWtCLENBQUNDLFdBQVdBO1lBQ3JFbUIsVUFBVTlELEtBQUs4RCxRQUFRLElBQUk7Z0JBQ3pCQyxXQUFXLElBQUlDO2dCQUNmSyxRQUFRO2dCQUNSQyxrQkFBa0J0RTtZQUNwQjtRQUNGO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEdUUsU0FBZTtRQUNiLDREQUE0RDtRQUM1RDFGLFFBQVFDLEdBQUcsQ0FBQztJQUNkO0lBRUE7O0dBRUMsR0FDRCxNQUFNMEYsY0FBZ0M7UUFDcEMsSUFBSTtZQUNGLE1BQU12RixXQUFXLE1BQU1DLE1BQU0sR0FBMEIsT0FBdkIsSUFBSSxDQUFDTixNQUFNLENBQUNGLFVBQVUsRUFBQyxZQUFVO2dCQUMvRFMsUUFBUTtnQkFDUnNGLFFBQVFDLFlBQVkvRixPQUFPLENBQUM7WUFDOUI7WUFFQSxPQUFPTSxTQUFTUyxFQUFFO1FBQ3BCLEVBQUUsVUFBTTtZQUNOLE9BQU87UUFDVDtJQUNGO0lBbFZBLFlBQVlkLE1BQXVCLENBQUU7UUFDbkMsSUFBSSxDQUFDQSxNQUFNLEdBQUc7WUFDWkQsU0FBUztZQUNUeUQsZUFBZTtZQUNmQyxZQUFZO1lBQ1osR0FBR3pELE1BQU07UUFDWDtJQUNGO0FBNFVGO0FBRUEsaURBQWlEO0FBQzFDLFNBQVMrRixnQkFBZ0IvRixNQUF1QjtJQUNyRCxPQUFPLElBQUlMLFVBQVVLO0FBQ3ZCO0FBRUEsZ0JBQWdCO0FBQ1QsTUFBTWdHLG1CQUFtQjtJQUM5QixNQUFNQyxTQUFTRixnQkFBZ0I7UUFDN0JqRyxZQUFZb0csT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxlQUFlO1FBQ3ZDdkUsY0FBY3FFLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0UsaUJBQWlCO1FBQzNDdEcsU0FBUztRQUNUeUQsZUFBZTtRQUNmQyxZQUFZO0lBQ2Q7SUFFQSx3QkFBd0I7SUFDeEIsTUFBTTdELGNBQWM7UUFDbEIsSUFBSTtZQUNGLE1BQU1DLFVBQXNCO2dCQUMxQnlHLFVBQVU7Z0JBQ1YvRyxTQUFTO2dCQUNUcUMsV0FBVztnQkFDWHVELFdBQVcsSUFBSUM7WUFDakI7WUFFQSxNQUFNL0UsV0FBVyxNQUFNNEYsT0FBTzFDLG9CQUFvQixDQUFDMUQ7WUFDbkRJLFFBQVFDLEdBQUcsQ0FBQyxhQUFhRztRQUMzQixFQUFFLE9BQU9ZLE9BQU87WUFDZCxJQUFJQSxpQkFBaUI1QixVQUFVO2dCQUM3QlksUUFBUWdCLEtBQUssQ0FBQyxjQUFjQSxNQUFNMUIsT0FBTyxFQUFFMEIsTUFBTXpCLElBQUk7WUFDdkQsT0FBTztnQkFDTFMsUUFBUWdCLEtBQUssQ0FBQyxxQkFBcUJBO1lBQ3JDO1FBQ0Y7SUFDRjtJQUVBLDJCQUEyQjtJQUMzQixNQUFNVSxpQkFBaUI7UUFDckIsSUFBSTtZQUNGLE1BQU1DLFlBQVk7WUFFbEIsV0FBVyxNQUFNdkIsWUFBWTRGLE9BQU90RSxjQUFjLENBQUNDLFdBQVk7Z0JBQzdEM0IsUUFBUUMsR0FBRyxDQUFDLHVCQUF1Qkc7Z0JBRW5DLElBQUlBLFNBQVNiLElBQUksS0FBSyxTQUFTO29CQUM3QjtnQkFDRjtZQUNGO1FBQ0YsRUFBRSxPQUFPeUIsT0FBTztZQUNkaEIsUUFBUWdCLEtBQUssQ0FBQyxvQkFBb0JBO1FBQ3BDO0lBQ0Y7SUFFQSxPQUFPO1FBQUVyQjtRQUFhK0I7SUFBZTtBQUN2QyxFQUFFO0FBRUYsMENBQTBDO0FBQ25DLE1BQU00RSxXQUFXO0lBQ3RCOztHQUVDLEdBQ0RDLGFBQVl2RixLQUFlO1FBQ3pCLE9BQVFBLE1BQU16QixJQUFJO1lBQ2hCLEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNULEtBQUs7Z0JBQ0gsT0FBTztZQUNUO2dCQUNFLE9BQU87UUFDWDtJQUNGO0lBRUE7O0dBRUMsR0FDRGlILGtCQUFpQnBHLFFBQXFCO1FBQ3BDLE9BQU9BLFNBQVNiLElBQUksS0FBSztJQUMzQjtJQUVBOztHQUVDLEdBQ0RrSCxnQkFBZXJHLFFBQXFCO1FBQ2xDLE9BQU9BLFNBQVNiLElBQUksS0FBSztJQUMzQjtJQUVBOztHQUVDLEdBQ0RtSCxtQkFBa0J0RyxRQUFxQjtZQUM5QkE7UUFBUCxPQUFPQSxFQUFBQSxxQkFBQUEsU0FBUzZFLFFBQVEsY0FBakI3RSx5Q0FBQUEsbUJBQW1CdUcsY0FBYyxLQUFJO0lBQzlDO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiQzpcXEVidHRpa2FyIEludGVsbGlnZW5jZSBQcm9qZWN0c1xcVGVzdC1DaGF0LUFwcFxcbGliXFxuOG4tY2xpZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbjhuIFdlYmhvb2sgQ2xpZW50XG4gKiBIYW5kbGVzIGNvbW11bmljYXRpb24gd2l0aCBuOG4gd29ya2Zsb3dzIHZpYSB3ZWJob29rIGFuZCBzdHJlYW1pbmcgZW5kcG9pbnRzXG4gKi9cblxuaW1wb3J0IHsgTjhOUmVxdWVzdCwgTjhOUmVzcG9uc2UsIENoYXRFcnJvciB9IGZyb20gJ0AvdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgTjhORXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U6IHN0cmluZyxcbiAgICBwdWJsaWMgdHlwZTogJ25ldHdvcmsnIHwgJ3RpbWVvdXQnIHwgJ3NlcnZlcicgfCAndmFsaWRhdGlvbicsXG4gICAgcHVibGljIGRldGFpbHM/OiBhbnlcbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ044TkVycm9yJztcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE44TkNsaWVudENvbmZpZyB7XG4gIHdlYmhvb2tVcmw6IHN0cmluZztcbiAgc3RyZWFtaW5nVXJsOiBzdHJpbmc7XG4gIHRpbWVvdXQ/OiBudW1iZXI7XG4gIHJldHJ5QXR0ZW1wdHM/OiBudW1iZXI7XG4gIHJldHJ5RGVsYXk/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBOOE5DbGllbnQge1xuICBwcml2YXRlIGNvbmZpZzogUmVxdWlyZWQ8TjhOQ2xpZW50Q29uZmlnPjtcblxuICBjb25zdHJ1Y3Rvcihjb25maWc6IE44TkNsaWVudENvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgdGltZW91dDogMTIwMDAwLCAvLyBJbmNyZWFzZWQgdG8gMiBtaW51dGVzIGZvciBBSSBwcm9jZXNzaW5nXG4gICAgICByZXRyeUF0dGVtcHRzOiAzLFxuICAgICAgcmV0cnlEZWxheTogMTAwMCxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIG1lc3NhZ2UgdG8gbjhuIHdlYmhvb2tcbiAgICovXG4gIGFzeW5jIHNlbmRNZXNzYWdlKHJlcXVlc3Q6IE44TlJlcXVlc3QpOiBQcm9taXNlPE44TlJlc3BvbnNlPiB7XG4gICAgY29uc3QgeyB3ZWJob29rVXJsLCB0aW1lb3V0IH0gPSB0aGlzLmNvbmZpZztcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJz09PSBOOE4gV0VCSE9PSyBERUJVRyA9PT0nKTtcbiAgICAgIGNvbnNvbGUubG9nKCdXZWJob29rIFVSTDonLCB3ZWJob29rVXJsKTtcbiAgICAgIGNvbnNvbGUubG9nKCdSZXF1ZXN0IHBheWxvYWQ6JywgSlNPTi5zdHJpbmdpZnkocmVxdWVzdCwgbnVsbCwgMikpO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHdlYmhvb2tVcmwsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZSBoZWFkZXJzOicsIE9iamVjdC5mcm9tRW50cmllcyhyZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKSkpO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVzcG9uc2UgYm9keTonLCBlcnJvclRleHQpO1xuICAgICAgICB0aHJvdyBuZXcgTjhORXJyb3IoXG4gICAgICAgICAgYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCxcbiAgICAgICAgICAnc2VydmVyJyxcbiAgICAgICAgICB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLCBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LCBib2R5OiBlcnJvclRleHQgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZVRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBjb25zb2xlLmxvZygnUmF3IHJlc3BvbnNlOicsIHJlc3BvbnNlVGV4dCk7XG4gICAgICBcbiAgICAgIGxldCBkYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KTtcbiAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1Jlc3BvbnNlIGlzIG5vdCBKU09OLCB0cmVhdGluZyBhcyBwbGFpbiB0ZXh0Jyk7XG4gICAgICAgIGRhdGEgPSByZXNwb25zZVRleHQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdQYXJzZWQgcmVzcG9uc2UgZGF0YTonLCBkYXRhKTtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFJlc3BvbnNlID0gdGhpcy52YWxpZGF0ZVJlc3BvbnNlKGRhdGEpO1xuICAgICAgY29uc29sZS5sb2coJ1ZhbGlkYXRlZCByZXNwb25zZTonLCB2YWxpZGF0ZWRSZXNwb25zZSk7XG4gICAgICBjb25zb2xlLmxvZygnPT09IEVORCBOOE4gV0VCSE9PSyBERUJVRyA9PT0nKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHZhbGlkYXRlZFJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCc9PT0gTjhOIFdFQkhPT0sgRVJST1IgPT09Jyk7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZXRhaWxzOicsIGVycm9yKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHR5cGU6JywgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLmNvbnN0cnVjdG9yLm5hbWUgOiB0eXBlb2YgZXJyb3IpO1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbWVzc2FnZTonLCBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcikpO1xuICAgICAgY29uc29sZS5lcnJvcignPT09IEVORCBOOE4gV0VCSE9PSyBFUlJPUiA9PT0nKTtcbiAgICAgIFxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdUaW1lb3V0RXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgIHRocm93IG5ldyBOOE5FcnJvcignUmVxdWVzdCB0aW1lb3V0JywgJ3RpbWVvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2ZldGNoJykgfHwgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnbmV0d29yaycpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE44TkVycm9yKCdOZXR3b3JrIGVycm9yJywgJ25ldHdvcmsnLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCBzdHJlYW1pbmcgY29ubmVjdGlvbiBmb3IgcmVhbC10aW1lIHVwZGF0ZXNcbiAgICovXG4gIGFzeW5jICpzdHJlYW1NZXNzYWdlcyhzZXNzaW9uSWQ6IHN0cmluZyk6IEFzeW5jR2VuZXJhdG9yPE44TlJlc3BvbnNlLCB2b2lkLCB1bmtub3duPiB7XG4gICAgY29uc3QgeyBzdHJlYW1pbmdVcmwgfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoc3RyZWFtaW5nVXJsKTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnc2Vzc2lvbklkJywgc2Vzc2lvbklkKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQWNjZXB0JzogJ3RleHQvZXZlbnQtc3RyZWFtJyxcbiAgICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZScsXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgTjhORXJyb3IoXG4gICAgICAgICAgYFN0cmVhbWluZyBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWAsXG4gICAgICAgICAgJ3NlcnZlcicsXG4gICAgICAgICAgeyBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHk/LmdldFJlYWRlcigpO1xuICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IE44TkVycm9yKCdObyByZXNwb25zZSBib2R5JywgJ3NlcnZlcicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICBsZXQgYnVmZmVyID0gJyc7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICAgICAgXG4gICAgICAgICAgYnVmZmVyICs9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgICBjb25zdCBsaW5lcyA9IGJ1ZmZlci5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gS2VlcCB0aGUgbGFzdCBpbmNvbXBsZXRlIGxpbmUgaW4gYnVmZmVyXG4gICAgICAgICAgYnVmZmVyID0gbGluZXMucG9wKCkgfHwgJyc7XG4gICAgICAgICAgXG4gICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICBpZiAobGluZS50cmltKCkgPT09ICcnKSBjb250aW51ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aCgnZGF0YTogJykpIHtcbiAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGxpbmUuc2xpY2UoNik7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gJ1tET05FXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMudmFsaWRhdGVSZXNwb25zZShwYXJzZWQpO1xuICAgICAgICAgICAgICAgIHlpZWxkIHJlc3BvbnNlO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBhcnNlIHN0cmVhbWluZyBkYXRhOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE44TkVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBuZXcgTjhORXJyb3IoXG4gICAgICAgICdTdHJlYW1pbmcgY29ubmVjdGlvbiBmYWlsZWQnLFxuICAgICAgICAnbmV0d29yaycsXG4gICAgICAgIGVycm9yXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIG1lc3NhZ2Ugd2l0aCByZXRyeSBsb2dpY1xuICAgKi9cbiAgYXN5bmMgc2VuZE1lc3NhZ2VXaXRoUmV0cnkocmVxdWVzdDogTjhOUmVxdWVzdCk6IFByb21pc2U8TjhOUmVzcG9uc2U+IHtcbiAgICBjb25zdCB7IHJldHJ5QXR0ZW1wdHMsIHJldHJ5RGVsYXkgfSA9IHRoaXMuY29uZmlnO1xuICAgIFxuICAgIGZvciAobGV0IGF0dGVtcHQgPSAxOyBhdHRlbXB0IDw9IHJldHJ5QXR0ZW1wdHM7IGF0dGVtcHQrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZE1lc3NhZ2UocmVxdWVzdCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBOOE5FcnJvcikge1xuICAgICAgICAgIC8vIERvbid0IHJldHJ5IHZhbGlkYXRpb24gZXJyb3JzXG4gICAgICAgICAgaWYgKGVycm9yLnR5cGUgPT09ICd2YWxpZGF0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIERvbid0IHJldHJ5IG9uIGZpbmFsIGF0dGVtcHRcbiAgICAgICAgICBpZiAoYXR0ZW1wdCA9PT0gcmV0cnlBdHRlbXB0cykge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFdhaXQgYmVmb3JlIHJldHJ5XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHJldHJ5RGVsYXkgKiBhdHRlbXB0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdGhyb3cgbmV3IE44TkVycm9yKCdNYXggcmV0cnkgYXR0ZW1wdHMgcmVhY2hlZCcsICduZXR3b3JrJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGR1cGxpY2F0ZSBjb250ZW50IGZyb20gcmVzcG9uc2VcbiAgICovXG4gIHByaXZhdGUgZGVkdXBsaWNhdGVDb250ZW50KGNvbnRlbnQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHR5cGVvZiBjb250ZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgLy8gU3BsaXQgY29udGVudCBpbnRvIGxpbmVzXG4gICAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCBzZWVuTGluZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBjb25zdCBkZWR1cGxpY2F0ZWRMaW5lczogc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIGNvbnN0IHRyaW1tZWRMaW5lID0gbGluZS50cmltKCk7XG4gICAgICBcbiAgICAgIC8vIFNraXAgZW1wdHkgbGluZXMgZm9yIGRlZHVwbGljYXRpb24gY2hlY2tcbiAgICAgIGlmICh0cmltbWVkTGluZSA9PT0gJycpIHtcbiAgICAgICAgZGVkdXBsaWNhdGVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIHdlIGhhdmVuJ3Qgc2VlbiB0aGlzIGxpbmUgYmVmb3JlLCBhZGQgaXRcbiAgICAgIGlmICghc2VlbkxpbmVzLmhhcyh0cmltbWVkTGluZSkpIHtcbiAgICAgICAgc2VlbkxpbmVzLmFkZCh0cmltbWVkTGluZSk7XG4gICAgICAgIGRlZHVwbGljYXRlZExpbmVzLnB1c2gobGluZSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBkZWR1cGxpY2F0ZWRMaW5lcy5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgaWYgY29udGVudCBpcyBtaXhlZCBmb3JtYXQgKGNvbnRhaW5zIHRleHQgYW5kIGNoYXJ0IGtleXMpXG4gICAqL1xuICBwcml2YXRlIGlzTWl4ZWRDb250ZW50KGNvbnRlbnQ6IGFueSk6IGJvb2xlYW4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjb250ZW50KSkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIHJldHVybiBjb250ZW50LnNvbWUoaXRlbSA9PiB7XG4gICAgICBpZiAoIWl0ZW0gfHwgdHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gICAgICBcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpdGVtKTtcbiAgICAgIGNvbnN0IGhhc1RleHQgPSBrZXlzLnNvbWUoa2V5ID0+IGtleS5zdGFydHNXaXRoKCd0ZXh0JykpO1xuICAgICAgY29uc3QgaGFzQ2hhcnQgPSBrZXlzLnNvbWUoa2V5ID0+IGtleS5zdGFydHNXaXRoKCdjaGFydCcpKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGhhc1RleHQgfHwgaGFzQ2hhcnQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgbjhuIHJlc3BvbnNlIGZvcm1hdFxuICAgKi9cbiAgcHJpdmF0ZSB2YWxpZGF0ZVJlc3BvbnNlKGRhdGE6IGFueSk6IE44TlJlc3BvbnNlIHtcbiAgICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBJZiB3ZSBnZXQgYSBzaW1wbGUgcmVzcG9uc2UsIHdyYXAgaXQgaW4gb3VyIGV4cGVjdGVkIGZvcm1hdFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2ZpbmFsJyxcbiAgICAgICAgbWVzc2FnZVR5cGU6ICd0ZXh0JyxcbiAgICAgICAgY29udGVudDogU3RyaW5nKGRhdGEpLFxuICAgICAgICBtZXRhZGF0YTogeyB0aW1lc3RhbXA6IG5ldyBEYXRlKCkgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiByZXNwb25zZSBhbHJlYWR5IGhhcyBvdXIgZXhwZWN0ZWQgZm9ybWF0XG4gICAgaWYgKGRhdGEudHlwZSAmJiBkYXRhLm1lc3NhZ2VUeXBlICYmIGRhdGEuY29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBkYXRhLnR5cGUsXG4gICAgICAgIG1lc3NhZ2VUeXBlOiBkYXRhLm1lc3NhZ2VUeXBlLFxuICAgICAgICBjb250ZW50OiBkYXRhLm1lc3NhZ2VUeXBlID09PSAndGV4dCcgPyB0aGlzLmRlZHVwbGljYXRlQ29udGVudChkYXRhLmNvbnRlbnQpIDogZGF0YS5jb250ZW50LFxuICAgICAgICBtZXRhZGF0YTogZGF0YS5tZXRhZGF0YSB8fCB7IHRpbWVzdGFtcDogbmV3IERhdGUoKSB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB2YXJpb3VzIHBvc3NpYmxlIG44biByZXNwb25zZSBmb3JtYXRzXG4gICAgbGV0IGNvbnRlbnQgPSBkYXRhLmNvbnRlbnQgfHwgZGF0YS5tZXNzYWdlIHx8IGRhdGEucmVzcG9uc2UgfHwgZGF0YS50ZXh0IHx8IGRhdGEub3V0cHV0IHx8IGRhdGE7XG4gICAgbGV0IG1lc3NhZ2VUeXBlID0gZGF0YS5tZXNzYWdlVHlwZSB8fCBkYXRhLmZvcm1hdCB8fCAndGV4dCc7XG4gICAgbGV0IHR5cGUgPSBkYXRhLnR5cGUgfHwgJ2ZpbmFsJztcbiAgICBcbiAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBuOG4gb3V0cHV0IGZpZWxkIHRoYXQgY29udGFpbnMgSlNPTiBzdHJpbmdcbiAgICBpZiAoZGF0YS5vdXRwdXQgJiYgdHlwZW9mIGRhdGEub3V0cHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyc2VkT3V0cHV0ID0gSlNPTi5wYXJzZShkYXRhLm91dHB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRPdXRwdXQgJiYgdHlwZW9mIHBhcnNlZE91dHB1dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgb3V0cHV0IGNvbnRhaW5zIGEgdmFsaWQgSlNPTiBvYmplY3QsIHVzZSBpdCBhcyB0aGUgYmFzZVxuICAgICAgICAgIGNvbnRlbnQgPSBwYXJzZWRPdXRwdXQuY29udGVudCB8fCBwYXJzZWRPdXRwdXQ7XG4gICAgICAgICAgbWVzc2FnZVR5cGUgPSBwYXJzZWRPdXRwdXQubWVzc2FnZVR5cGUgfHwgbWVzc2FnZVR5cGU7XG4gICAgICAgICAgdHlwZSA9IHBhcnNlZE91dHB1dC50eXBlIHx8IHR5cGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIElmIHBhcnNpbmcgZmFpbHMsIHRyZWF0IG91dHB1dCBhcyByZWd1bGFyIHRleHQgY29udGVudFxuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBuOG4gb3V0cHV0IGFzIEpTT046JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBtaXhlZCBjb250ZW50IHJlc3BvbnNlIChhcnJheSB3aXRoIHRleHQvY2hhcnQgY29tYmluYXRpb25zKVxuICAgIGlmICh0aGlzLmlzTWl4ZWRDb250ZW50KGNvbnRlbnQpKSB7XG4gICAgICBtZXNzYWdlVHlwZSA9ICdtaXhlZCc7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnQpKSB7XG4gICAgICAvLyBJZiBpdCdzIGFuIGFycmF5IGJ1dCBub3QgbWl4ZWQgY29udGVudCwgdHJlYXQgYXMgSlNPTlxuICAgICAgbWVzc2FnZVR5cGUgPSAnanNvbic7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgbWVzc2FnZVR5cGVcbiAgICBpZiAoIVsndGV4dCcsICdqc29uJywgJ2ltYWdlJywgJ2NoYXJ0JywgJ2Vycm9yJywgJ21peGVkJ10uaW5jbHVkZXMobWVzc2FnZVR5cGUpKSB7XG4gICAgICBtZXNzYWdlVHlwZSA9ICd0ZXh0JztcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSB0eXBlXG4gICAgaWYgKCFbJ2ludGVyaW0nLCAnZmluYWwnXS5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgdHlwZSA9ICdmaW5hbCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGUsXG4gICAgICBtZXNzYWdlVHlwZSxcbiAgICAgIGNvbnRlbnQ6IG1lc3NhZ2VUeXBlID09PSAndGV4dCcgPyB0aGlzLmRlZHVwbGljYXRlQ29udGVudChjb250ZW50KSA6IGNvbnRlbnQsXG4gICAgICBtZXRhZGF0YTogZGF0YS5tZXRhZGF0YSB8fCB7IFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgIHNvdXJjZTogJ244bi13ZWJob29rJyxcbiAgICAgICAgb3JpZ2luYWxSZXNwb25zZTogZGF0YVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIG9uZ29pbmcgcmVxdWVzdFxuICAgKi9cbiAgY2FuY2VsKCk6IHZvaWQge1xuICAgIC8vIFJlcXVlc3RzIG5vdyB1c2UgQWJvcnRTaWduYWwudGltZW91dCgpIHdoaWNoIGF1dG8tY2FuY2Vsc1xuICAgIGNvbnNvbGUubG9nKCdDYW5jZWwgcmVxdWVzdGVkIC0gdXNpbmcgdGltZW91dC1iYXNlZCBjYW5jZWxsYXRpb24nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWFsdGggY2hlY2sgZW5kcG9pbnRcbiAgICovXG4gIGFzeW5jIGhlYWx0aENoZWNrKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuY29uZmlnLndlYmhvb2tVcmx9L2hlYWx0aGAsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KDUwMDApLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiByZXNwb25zZS5vaztcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgY2xpZW50IGluc3RhbmNlc1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU44TkNsaWVudChjb25maWc6IE44TkNsaWVudENvbmZpZyk6IE44TkNsaWVudCB7XG4gIHJldHVybiBuZXcgTjhOQ2xpZW50KGNvbmZpZyk7XG59XG5cbi8vIEV4YW1wbGUgdXNhZ2VcbmV4cG9ydCBjb25zdCBuOG5DbGllbnRFeGFtcGxlID0gKCkgPT4ge1xuICBjb25zdCBjbGllbnQgPSBjcmVhdGVOOE5DbGllbnQoe1xuICAgIHdlYmhvb2tVcmw6IHByb2Nlc3MuZW52Lk44Tl9XRUJIT09LX1VSTCEsXG4gICAgc3RyZWFtaW5nVXJsOiBwcm9jZXNzLmVudi5OOE5fU1RSRUFNSU5HX1VSTCEsXG4gICAgdGltZW91dDogMzAwMDAsXG4gICAgcmV0cnlBdHRlbXB0czogMyxcbiAgICByZXRyeURlbGF5OiAxMDAwXG4gIH0pO1xuXG4gIC8vIEV4YW1wbGU6IFNlbmQgbWVzc2FnZVxuICBjb25zdCBzZW5kTWVzc2FnZSA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVxdWVzdDogTjhOUmVxdWVzdCA9IHtcbiAgICAgICAgdXNlcm5hbWU6ICd1c2VyMTIzJyxcbiAgICAgICAgbWVzc2FnZTogJ0hlbGxvLCBjYW4geW91IGFuYWx5emUgdGhpcyBkYXRhPycsXG4gICAgICAgIHNlc3Npb25JZDogJ3Nlc3Npb24tMTIzJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5zZW5kTWVzc2FnZVdpdGhSZXRyeShyZXF1ZXN0KTtcbiAgICAgIGNvbnNvbGUubG9nKCdSZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE44TkVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ044TiBFcnJvcjonLCBlcnJvci5tZXNzYWdlLCBlcnJvci50eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBFeGFtcGxlOiBTdHJlYW0gbWVzc2FnZXNcbiAgY29uc3Qgc3RyZWFtTWVzc2FnZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlc3Npb25JZCA9ICdzZXNzaW9uLTEyMyc7XG4gICAgICBcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgcmVzcG9uc2Ugb2YgY2xpZW50LnN0cmVhbU1lc3NhZ2VzKHNlc3Npb25JZCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1N0cmVhbWluZyByZXNwb25zZTonLCByZXNwb25zZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ2ZpbmFsJykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1N0cmVhbWluZyBlcnJvcjonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7IHNlbmRNZXNzYWdlLCBzdHJlYW1NZXNzYWdlcyB9O1xufTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGNvbW1vbiBvcGVyYXRpb25zXG5leHBvcnQgY29uc3QgbjhuVXRpbHMgPSB7XG4gIC8qKlxuICAgKiBGb3JtYXQgZXJyb3IgZm9yIHVzZXIgZGlzcGxheVxuICAgKi9cbiAgZm9ybWF0RXJyb3IoZXJyb3I6IE44TkVycm9yKTogc3RyaW5nIHtcbiAgICBzd2l0Y2ggKGVycm9yLnR5cGUpIHtcbiAgICAgIGNhc2UgJ25ldHdvcmsnOlxuICAgICAgICByZXR1cm4gJ05ldHdvcmsgY29ubmVjdGlvbiBmYWlsZWQuIFBsZWFzZSBjaGVjayB5b3VyIGludGVybmV0IGNvbm5lY3Rpb24uJztcbiAgICAgIGNhc2UgJ3RpbWVvdXQnOlxuICAgICAgICByZXR1cm4gJ1JlcXVlc3QgdGltZWQgb3V0LiBUaGUgd29ya2Zsb3cgbWF5IGJlIHRha2luZyBsb25nZXIgdGhhbiBleHBlY3RlZC4nO1xuICAgICAgY2FzZSAnc2VydmVyJzpcbiAgICAgICAgcmV0dXJuICdTZXJ2ZXIgZXJyb3Igb2NjdXJyZWQuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJztcbiAgICAgIGNhc2UgJ3ZhbGlkYXRpb24nOlxuICAgICAgICByZXR1cm4gJ0ludmFsaWQgZGF0YSBmb3JtYXQuIFBsZWFzZSBjb250YWN0IHN1cHBvcnQuJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAnQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZC4gUGxlYXNlIHRyeSBhZ2Fpbi4nO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgcmVzcG9uc2UgaXMgaW50ZXJpbSBtZXNzYWdlXG4gICAqL1xuICBpc0ludGVyaW1NZXNzYWdlKHJlc3BvbnNlOiBOOE5SZXNwb25zZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiByZXNwb25zZS50eXBlID09PSAnaW50ZXJpbSc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHJlc3BvbnNlIGlzIGZpbmFsIG1lc3NhZ2VcbiAgICovXG4gIGlzRmluYWxNZXNzYWdlKHJlc3BvbnNlOiBOOE5SZXNwb25zZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiByZXNwb25zZS50eXBlID09PSAnZmluYWwnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHByb2Nlc3NpbmcgdGltZSBmcm9tIG1ldGFkYXRhXG4gICAqL1xuICBnZXRQcm9jZXNzaW5nVGltZShyZXNwb25zZTogTjhOUmVzcG9uc2UpOiBudW1iZXIgfCBudWxsIHtcbiAgICByZXR1cm4gcmVzcG9uc2UubWV0YWRhdGE/LnByb2Nlc3NpbmdUaW1lIHx8IG51bGw7XG4gIH1cbn07Il0sIm5hbWVzIjpbIk44TkVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwidHlwZSIsImRldGFpbHMiLCJuYW1lIiwiTjhOQ2xpZW50Iiwic2VuZE1lc3NhZ2UiLCJyZXF1ZXN0Iiwid2ViaG9va1VybCIsInRpbWVvdXQiLCJjb25maWciLCJjb25zb2xlIiwibG9nIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsInN0YXR1cyIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsIm9rIiwiZXJyb3JUZXh0IiwidGV4dCIsImVycm9yIiwic3RhdHVzVGV4dCIsInJlc3BvbnNlVGV4dCIsImRhdGEiLCJwYXJzZSIsInBhcnNlRXJyb3IiLCJ2YWxpZGF0ZWRSZXNwb25zZSIsInZhbGlkYXRlUmVzcG9uc2UiLCJTdHJpbmciLCJpbmNsdWRlcyIsInN0cmVhbU1lc3NhZ2VzIiwic2Vzc2lvbklkIiwic3RyZWFtaW5nVXJsIiwidXJsIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwic2V0IiwidG9TdHJpbmciLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJidWZmZXIiLCJkb25lIiwidmFsdWUiLCJyZWFkIiwiZGVjb2RlIiwic3RyZWFtIiwibGluZXMiLCJzcGxpdCIsInBvcCIsImxpbmUiLCJ0cmltIiwic3RhcnRzV2l0aCIsInNsaWNlIiwicGFyc2VkIiwid2FybiIsInJlbGVhc2VMb2NrIiwic2VuZE1lc3NhZ2VXaXRoUmV0cnkiLCJyZXRyeUF0dGVtcHRzIiwicmV0cnlEZWxheSIsImF0dGVtcHQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJkZWR1cGxpY2F0ZUNvbnRlbnQiLCJjb250ZW50Iiwic2VlbkxpbmVzIiwiU2V0IiwiZGVkdXBsaWNhdGVkTGluZXMiLCJ0cmltbWVkTGluZSIsInB1c2giLCJoYXMiLCJhZGQiLCJqb2luIiwiaXNNaXhlZENvbnRlbnQiLCJBcnJheSIsImlzQXJyYXkiLCJzb21lIiwiaXRlbSIsImtleXMiLCJoYXNUZXh0Iiwia2V5IiwiaGFzQ2hhcnQiLCJtZXNzYWdlVHlwZSIsIm1ldGFkYXRhIiwidGltZXN0YW1wIiwiRGF0ZSIsInVuZGVmaW5lZCIsIm91dHB1dCIsImZvcm1hdCIsInBhcnNlZE91dHB1dCIsInNvdXJjZSIsIm9yaWdpbmFsUmVzcG9uc2UiLCJjYW5jZWwiLCJoZWFsdGhDaGVjayIsInNpZ25hbCIsIkFib3J0U2lnbmFsIiwiY3JlYXRlTjhOQ2xpZW50IiwibjhuQ2xpZW50RXhhbXBsZSIsImNsaWVudCIsInByb2Nlc3MiLCJlbnYiLCJOOE5fV0VCSE9PS19VUkwiLCJOOE5fU1RSRUFNSU5HX1VSTCIsInVzZXJuYW1lIiwibjhuVXRpbHMiLCJmb3JtYXRFcnJvciIsImlzSW50ZXJpbU1lc3NhZ2UiLCJpc0ZpbmFsTWVzc2FnZSIsImdldFByb2Nlc3NpbmdUaW1lIiwicHJvY2Vzc2luZ1RpbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/n8n-client.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CEbttikar%20Intelligence%20Projects%5C%5CTest-Chat-App%5C%5Capp%5C%5Cproviders.tsx%22%2C%22ids%22%3A%5B%22Providers%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CEbttikar%20Intelligence%20Projects%5C%5CTest-Chat-App%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22app%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Montserrat%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22display%5C%22%3A%5C%22swap%5C%22%2C%5C%22variable%5C%22%3A%5C%22--font-montserrat%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22montserrat%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CEbttikar%20Intelligence%20Projects%5C%5CTest-Chat-App%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CEbttikar%20Intelligence%20Projects%5C%5CTest-Chat-App%5C%5Capp%5C%5Cproviders.tsx%22%2C%22ids%22%3A%5B%22Providers%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CEbttikar%20Intelligence%20Projects%5C%5CTest-Chat-App%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22app%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Montserrat%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22display%5C%22%3A%5C%22swap%5C%22%2C%5C%22variable%5C%22%3A%5C%22--font-montserrat%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22montserrat%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CEbttikar%20Intelligence%20Projects%5C%5CTest-Chat-App%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/providers.tsx */ \"(app-pages-browser)/./app/providers.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.tsx\",\"import\":\"Montserrat\",\"arguments\":[{\"subsets\":[\"latin\"],\"display\":\"swap\",\"variable\":\"--font-montserrat\"}],\"variableName\":\"montserrat\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app\\\\\\\\layout.tsx\\\",\\\"import\\\":\\\"Montserrat\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"],\\\"display\\\":\\\"swap\\\",\\\"variable\\\":\\\"--font-montserrat\\\"}],\\\"variableName\\\":\\\"montserrat\\\"}\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/globals.css */ \"(app-pages-browser)/./app/globals.css\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q0VidHRpa2FyJTIwSW50ZWxsaWdlbmNlJTIwUHJvamVjdHMlNUMlNUNUZXN0LUNoYXQtQXBwJTVDJTVDYXBwJTVDJTVDcHJvdmlkZXJzLnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiUyMlByb3ZpZGVycyUyMiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjJDJTNBJTVDJTVDRWJ0dGlrYXIlMjBJbnRlbGxpZ2VuY2UlMjBQcm9qZWN0cyU1QyU1Q1Rlc3QtQ2hhdC1BcHAlNUMlNUNub2RlX21vZHVsZXMlNUMlNUNuZXh0JTVDJTVDZm9udCU1QyU1Q2dvb2dsZSU1QyU1Q3RhcmdldC5jc3MlM0YlN0IlNUMlMjJwYXRoJTVDJTIyJTNBJTVDJTIyYXBwJTVDJTVDJTVDJTVDbGF5b3V0LnRzeCU1QyUyMiUyQyU1QyUyMmltcG9ydCU1QyUyMiUzQSU1QyUyMk1vbnRzZXJyYXQlNUMlMjIlMkMlNUMlMjJhcmd1bWVudHMlNUMlMjIlM0ElNUIlN0IlNUMlMjJzdWJzZXRzJTVDJTIyJTNBJTVCJTVDJTIybGF0aW4lNUMlMjIlNUQlMkMlNUMlMjJkaXNwbGF5JTVDJTIyJTNBJTVDJTIyc3dhcCU1QyUyMiUyQyU1QyUyMnZhcmlhYmxlJTVDJTIyJTNBJTVDJTIyLS1mb250LW1vbnRzZXJyYXQlNUMlMjIlN0QlNUQlMkMlNUMlMjJ2YXJpYWJsZU5hbWUlNUMlMjIlM0ElNUMlMjJtb250c2VycmF0JTVDJTIyJTdEJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMkMlM0ElNUMlNUNFYnR0aWthciUyMEludGVsbGlnZW5jZSUyMFByb2plY3RzJTVDJTVDVGVzdC1DaGF0LUFwcCU1QyU1Q2FwcCU1QyU1Q2dsb2JhbHMuY3NzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsZ0tBQXlJO0FBQ3pJO0FBQ0Esa2pCQUFpVTtBQUNqVTtBQUNBLDRKQUF3RyIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiLCB3ZWJwYWNrRXhwb3J0czogW1wiUHJvdmlkZXJzXCJdICovIFwiQzpcXFxcRWJ0dGlrYXIgSW50ZWxsaWdlbmNlIFByb2plY3RzXFxcXFRlc3QtQ2hhdC1BcHBcXFxcYXBwXFxcXHByb3ZpZGVycy50c3hcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXEVidHRpa2FyIEludGVsbGlnZW5jZSBQcm9qZWN0c1xcXFxUZXN0LUNoYXQtQXBwXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGZvbnRcXFxcZ29vZ2xlXFxcXHRhcmdldC5jc3M/e1xcXCJwYXRoXFxcIjpcXFwiYXBwXFxcXFxcXFxsYXlvdXQudHN4XFxcIixcXFwiaW1wb3J0XFxcIjpcXFwiTW9udHNlcnJhdFxcXCIsXFxcImFyZ3VtZW50c1xcXCI6W3tcXFwic3Vic2V0c1xcXCI6W1xcXCJsYXRpblxcXCJdLFxcXCJkaXNwbGF5XFxcIjpcXFwic3dhcFxcXCIsXFxcInZhcmlhYmxlXFxcIjpcXFwiLS1mb250LW1vbnRzZXJyYXRcXFwifV0sXFxcInZhcmlhYmxlTmFtZVxcXCI6XFxcIm1vbnRzZXJyYXRcXFwifVwiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcRWJ0dGlrYXIgSW50ZWxsaWdlbmNlIFByb2plY3RzXFxcXFRlc3QtQ2hhdC1BcHBcXFxcYXBwXFxcXGdsb2JhbHMuY3NzXCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CEbttikar%20Intelligence%20Projects%5C%5CTest-Chat-App%5C%5Capp%5C%5Cproviders.tsx%22%2C%22ids%22%3A%5B%22Providers%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CEbttikar%20Intelligence%20Projects%5C%5CTest-Chat-App%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22app%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Montserrat%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22display%5C%22%3A%5C%22swap%5C%22%2C%5C%22variable%5C%22%3A%5C%22--font-montserrat%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22montserrat%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CEbttikar%20Intelligence%20Projects%5C%5CTest-Chat-App%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={432:(e,r,t)=>{var n=t(887);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},887:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(432);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQyw4QkFBOEIsdUJBQXVCLFFBQVEsa0JBQWtCLFdBQVcsZ0JBQWdCLDhCQUE4QixxQkFBcUIsZ0JBQWdCLG1CQUFtQixpQkFBaUIsZ0NBQWdDLFdBQVcsT0FBTywyQkFBMkIsNkJBQTZCLEtBQUssOENBQThDLG9CQUFvQixNQUFNLFNBQVMsT0FBTyxtQkFBbUIsT0FBTyxZQUFZLGdDQUFnQyxjQUFjLE9BQU8sZ0NBQWdDLE9BQU8sZ0NBQWdDLHFDQUFxQyw0Q0FBNEMsMkNBQTJDLFNBQVMsZ0JBQWdCLElBQUksd0JBQXdCLE9BQU8sWUFBWSxPQUFPLHVCQUF1QixxQkFBcUIsT0FBTyx1QkFBdUIsT0FBTyxnQ0FBZ0MsT0FBTyxlQUFlLG9CQUFvQixpQkFBaUIsc0NBQXNDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsdUNBQXVDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsMkNBQTJDLGtCQUFrQiwyQ0FBMkMsS0FBSyw2QkFBNkIsMkJBQTJCLE1BQU0sT0FBTyxlQUFlLEVBQUUsb0JBQW9CLG9CQUFvQixLQUFLLEdBQUcsU0FBUyx3QkFBd0IsT0FBTyxhQUFhLHdDQUF3QyxZQUFZLHNCQUFzQixZQUFZLE9BQU8sNkJBQTZCLHFCQUFxQixPQUFPLHFCQUFxQixPQUFPLE1BQU0sZUFBZSxRQUFRLEdBQUcsU0FBUyxxQkFBcUIsd0NBQXdDLHNCQUFzQixxQkFBcUIsT0FBTyxhQUFhLEdBQUcseUJBQXlCLHlDQUF5QyxhQUFhLFlBQVksd0JBQXdCLE1BQU0sMERBQTBELFlBQVksNkJBQTZCLGtCQUFrQixvQkFBb0IscUJBQXFCLGFBQWEsZ0VBQWdFLFlBQVksT0FBTyxNQUFNLCtDQUErQyxLQUFLLG9DQUFvQyxhQUFhLDRCQUE0QixTQUFTLHlCQUF5QiwrQkFBK0IsVUFBVSxpQkFBaUIsTUFBTSxjQUFjLGtCQUFrQixTQUFTLGdCQUFnQixzQkFBc0IsV0FBVyxzQkFBc0IsU0FBUyxvREFBb0QsaURBQWlELDJDQUEyQyxRQUFRLHNCQUFzQixnQkFBZ0IsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsiQzpcXEVidHRpa2FyIEludGVsbGlnZW5jZSBQcm9qZWN0c1xcVGVzdC1DaGF0LUFwcFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxjb21waWxlZFxcbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cXGhtclxcaG90TW9kdWxlUmVwbGFjZW1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ezQzMjooZSxyLHQpPT57dmFyIG49dCg4ODcpO3ZhciBpPU9iamVjdC5jcmVhdGUobnVsbCk7dmFyIGE9dHlwZW9mIGRvY3VtZW50PT09XCJ1bmRlZmluZWRcIjt2YXIgbz1BcnJheS5wcm90b3R5cGUuZm9yRWFjaDtmdW5jdGlvbiBkZWJvdW5jZShlLHIpe3ZhciB0PTA7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG49dGhpczt2YXIgaT1hcmd1bWVudHM7dmFyIGE9ZnVuY3Rpb24gZnVuY3Rpb25DYWxsKCl7cmV0dXJuIGUuYXBwbHkobixpKX07Y2xlYXJUaW1lb3V0KHQpO3Q9c2V0VGltZW91dChhLHIpfX1mdW5jdGlvbiBub29wKCl7fWZ1bmN0aW9uIGdldEN1cnJlbnRTY3JpcHRVcmwoZSl7dmFyIHI9aVtlXTtpZighcil7aWYoZG9jdW1lbnQuY3VycmVudFNjcmlwdCl7cj1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY31lbHNle3ZhciB0PWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO3ZhciBhPXRbdC5sZW5ndGgtMV07aWYoYSl7cj1hLnNyY319aVtlXT1yfXJldHVybiBmdW5jdGlvbihlKXtpZighcil7cmV0dXJuIG51bGx9dmFyIHQ9ci5zcGxpdCgvKFteXFxcXC9dKylcXC5qcyQvKTt2YXIgaT10JiZ0WzFdO2lmKCFpKXtyZXR1cm5bci5yZXBsYWNlKFwiLmpzXCIsXCIuY3NzXCIpXX1pZighZSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19cmV0dXJuIGUuc3BsaXQoXCIsXCIpLm1hcCgoZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IFJlZ0V4cChcIlwiLmNvbmNhdChpLFwiXFxcXC5qcyRcIiksXCJnXCIpO3JldHVybiBuKHIucmVwbGFjZSh0LFwiXCIuY29uY2F0KGUucmVwbGFjZSgve2ZpbGVOYW1lfS9nLGkpLFwiLmNzc1wiKSkpfSkpfX1mdW5jdGlvbiB1cGRhdGVDc3MoZSxyKXtpZighcil7aWYoIWUuaHJlZil7cmV0dXJufXI9ZS5ocmVmLnNwbGl0KFwiP1wiKVswXX1pZighaXNVcmxSZXF1ZXN0KHIpKXtyZXR1cm59aWYoZS5pc0xvYWRlZD09PWZhbHNlKXtyZXR1cm59aWYoIXJ8fCEoci5pbmRleE9mKFwiLmNzc1wiKT4tMSkpe3JldHVybn1lLnZpc2l0ZWQ9dHJ1ZTt2YXIgdD1lLmNsb25lTm9kZSgpO3QuaXNMb2FkZWQ9ZmFsc2U7dC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsKGZ1bmN0aW9uKCl7aWYodC5pc0xvYWRlZCl7cmV0dXJufXQuaXNMb2FkZWQ9dHJ1ZTtlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSl9KSk7dC5ocmVmPVwiXCIuY29uY2F0KHIsXCI/XCIpLmNvbmNhdChEYXRlLm5vdygpKTtpZihlLm5leHRTaWJsaW5nKXtlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHQsZS5uZXh0U2libGluZyl9ZWxzZXtlLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodCl9fWZ1bmN0aW9uIGdldFJlbG9hZFVybChlLHIpe3ZhciB0O2U9bihlLHtzdHJpcFdXVzpmYWxzZX0pO3Iuc29tZSgoZnVuY3Rpb24obil7aWYoZS5pbmRleE9mKHIpPi0xKXt0PW59fSkpO3JldHVybiB0fWZ1bmN0aW9uIHJlbG9hZFN0eWxlKGUpe2lmKCFlKXtyZXR1cm4gZmFsc2V9dmFyIHI9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7dmFyIHQ9ZmFsc2U7by5jYWxsKHIsKGZ1bmN0aW9uKHIpe2lmKCFyLmhyZWYpe3JldHVybn12YXIgbj1nZXRSZWxvYWRVcmwoci5ocmVmLGUpO2lmKCFpc1VybFJlcXVlc3Qobikpe3JldHVybn1pZihyLnZpc2l0ZWQ9PT10cnVlKXtyZXR1cm59aWYobil7dXBkYXRlQ3NzKHIsbik7dD10cnVlfX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRBbGwoKXt2YXIgZT1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1wiKTtvLmNhbGwoZSwoZnVuY3Rpb24oZSl7aWYoZS52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufXVwZGF0ZUNzcyhlKX0pKX1mdW5jdGlvbiBpc1VybFJlcXVlc3QoZSl7aWYoIS9eW2EtekEtWl1bYS16QS1aXFxkK1xcLS5dKjovLnRlc3QoZSkpe3JldHVybiBmYWxzZX1yZXR1cm4gdHJ1ZX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSxyKXtpZihhKXtjb25zb2xlLmxvZyhcIm5vIHdpbmRvdy5kb2N1bWVudCBmb3VuZCwgd2lsbCBub3QgSE1SIENTU1wiKTtyZXR1cm4gbm9vcH12YXIgdD1nZXRDdXJyZW50U2NyaXB0VXJsKGUpO2Z1bmN0aW9uIHVwZGF0ZSgpe3ZhciBlPXQoci5maWxlbmFtZSk7dmFyIG49cmVsb2FkU3R5bGUoZSk7aWYoci5sb2NhbHMpe2NvbnNvbGUubG9nKFwiW0hNUl0gRGV0ZWN0ZWQgbG9jYWwgY3NzIG1vZHVsZXMuIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpO3JldHVybn1pZihuKXtjb25zb2xlLmxvZyhcIltITVJdIGNzcyByZWxvYWQgJXNcIixlLmpvaW4oXCIgXCIpKX1lbHNle2NvbnNvbGUubG9nKFwiW0hNUl0gUmVsb2FkIGFsbCBjc3NcIik7cmVsb2FkQWxsKCl9fXJldHVybiBkZWJvdW5jZSh1cGRhdGUsNTApfX0sODg3OmU9PntmdW5jdGlvbiBub3JtYWxpemVVcmwoZSl7cmV0dXJuIGUucmVkdWNlKChmdW5jdGlvbihlLHIpe3N3aXRjaChyKXtjYXNlXCIuLlwiOmUucG9wKCk7YnJlYWs7Y2FzZVwiLlwiOmJyZWFrO2RlZmF1bHQ6ZS5wdXNoKHIpfXJldHVybiBlfSksW10pLmpvaW4oXCIvXCIpfWUuZXhwb3J0cz1mdW5jdGlvbihlKXtlPWUudHJpbSgpO2lmKC9eZGF0YTovaS50ZXN0KGUpKXtyZXR1cm4gZX12YXIgcj1lLmluZGV4T2YoXCIvL1wiKSE9PS0xP2Uuc3BsaXQoXCIvL1wiKVswXStcIi8vXCI6XCJcIjt2YXIgdD1lLnJlcGxhY2UobmV3IFJlZ0V4cChyLFwiaVwiKSxcIlwiKS5zcGxpdChcIi9cIik7dmFyIG49dFswXS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xcLiQvLFwiXCIpO3RbMF09XCJcIjt2YXIgaT1ub3JtYWxpemVVcmwodCk7cmV0dXJuIHIrbitpfX19O3ZhciByPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIG49clt0XTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXJbdF09e2V4cG9ydHM6e319O3ZhciBhPXRydWU7dHJ5e2VbdF0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7YT1mYWxzZX1maW5hbGx5e2lmKGEpZGVsZXRlIHJbdF19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXyg0MzIpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return type.displayName || \"Context\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        self,\n        source,\n        getOwner(),\n        maybeKey,\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n      REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        source,\n        self,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFnRDtBQUNoRSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0EsZ0NBQWdDLGtDQUFrQyxPQUFPO0FBQ3pFO0FBQ0EsZ0dBQWdHLFNBQVMsVUFBVSxzRkFBc0YsYUFBYSxVQUFVLFVBQVU7QUFDMU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSxjQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiQzpcXEVidHRpa2FyIEludGVsbGlnZW5jZSBQcm9qZWN0c1xcVGVzdC1DaGF0LUFwcFxcbm9kZV9tb2R1bGVzXFxuZXh0XFxkaXN0XFxjb21waWxlZFxccmVhY3RcXGNqc1xccmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgICBjYXNlIFJFQUNUX0FDVElWSVRZX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiQWN0aXZpdHlcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgKHR5cGUgPSBcIlwiICE9PSB0eXBlID8gXCJGb3J3YXJkUmVmKFwiICsgdHlwZSArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgID8gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITA7XG4gICAgICB9XG4gICAgICBpZiAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGNvbnNvbGU7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuZXJyb3I7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPVxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiZcbiAgICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyAmJlxuICAgICAgICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcbiAgICAgICAgICB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgICAgXCJPYmplY3RcIjtcbiAgICAgICAgSlNDb21waWxlcl90ZW1wX2NvbnN0LmNhbGwoXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRhc2tOYW1lKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSByZXR1cm4gXCI8PlwiO1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRVxuICAgICAgKVxuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHJldHVybiBuYW1lID8gXCI8XCIgKyBuYW1lICsgXCI+XCIgOiBcIjwuLi4+XCI7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBcIjwuLi4+XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE93bmVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGRpc3BhdGNoZXIgPyBudWxsIDogZGlzcGF0Y2hlci5nZXRPd25lcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVbmtub3duT3duZXIoKSB7XG4gICAgICByZXR1cm4gRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KFxuICAgICAgdHlwZSxcbiAgICAgIGtleSxcbiAgICAgIHNlbGYsXG4gICAgICBzb3VyY2UsXG4gICAgICBvd25lcixcbiAgICAgIHByb3BzLFxuICAgICAgZGVidWdTdGFjayxcbiAgICAgIGRlYnVnVGFza1xuICAgICkge1xuICAgICAgc2VsZiA9IHByb3BzLnJlZjtcbiAgICAgIHR5cGUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIF9vd25lcjogb3duZXJcbiAgICAgIH07XG4gICAgICBudWxsICE9PSAodm9pZCAwICE9PSBzZWxmID8gc2VsZiA6IG51bGwpXG4gICAgICAgID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgZ2V0OiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgIH0pXG4gICAgICAgIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHsgZW51bWVyYWJsZTogITEsIHZhbHVlOiBudWxsIH0pO1xuICAgICAgdHlwZS5fc3RvcmUgPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdJbmZvXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnU3RhY2tcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZGVidWdTdGFja1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdUYXNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnVGFza1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKHR5cGUucHJvcHMpLCBPYmplY3QuZnJlZXplKHR5cGUpKTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBqc3hERVZJbXBsKFxuICAgICAgdHlwZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1heWJlS2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNlbGYsXG4gICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgZGVidWdUYXNrXG4gICAgKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjb25maWcuY2hpbGRyZW47XG4gICAgICBpZiAodm9pZCAwICE9PSBjaGlsZHJlbilcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9IDA7XG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPCBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4rK1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpc1N0YXRpY0NoaWxkcmVuXSk7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiBZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuIFVzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIGVsc2UgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4pO1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICBjaGlsZHJlbiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICAgIHJldHVybiBcImtleVwiICE9PSBrO1xuICAgICAgICB9KTtcbiAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9XG4gICAgICAgICAgMCA8IGtleXMubGVuZ3RoXG4gICAgICAgICAgICA/IFwie2tleTogc29tZUtleSwgXCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIlxuICAgICAgICAgICAgOiBcIntrZXk6IHNvbWVLZXl9XCI7XG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dIHx8XG4gICAgICAgICAgKChrZXlzID1cbiAgICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aCA/IFwie1wiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCIgOiBcInt9XCIpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyB7Li4ucHJvcHN9IC8+XFxuUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLFxuICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAga2V5cyxcbiAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gPSAhMCkpO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4gPSBudWxsO1xuICAgICAgdm9pZCAwICE9PSBtYXliZUtleSAmJlxuICAgICAgICAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBtYXliZUtleSkpO1xuICAgICAgaGFzVmFsaWRLZXkoY29uZmlnKSAmJlxuICAgICAgICAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIGNvbmZpZy5rZXkpKTtcbiAgICAgIGlmIChcImtleVwiIGluIGNvbmZpZykge1xuICAgICAgICBtYXliZUtleSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBjb25maWcpXG4gICAgICAgICAgXCJrZXlcIiAhPT0gcHJvcE5hbWUgJiYgKG1heWJlS2V5W3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV0pO1xuICAgICAgfSBlbHNlIG1heWJlS2V5ID0gY29uZmlnO1xuICAgICAgY2hpbGRyZW4gJiZcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIoXG4gICAgICAgICAgbWF5YmVLZXksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZVxuICAgICAgICAgICAgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgOiB0eXBlXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gUmVhY3RFbGVtZW50KFxuICAgICAgICB0eXBlLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgc2VsZixcbiAgICAgICAgc291cmNlLFxuICAgICAgICBnZXRPd25lcigpLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgZGVidWdTdGFjayxcbiAgICAgICAgZGVidWdUYXNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlKSB7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJlxuICAgICAgICBudWxsICE9PSBub2RlICYmXG4gICAgICAgIG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSAmJlxuICAgICAgICBub2RlLl9zdG9yZSAmJlxuICAgICAgICAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgfVxuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIiksXG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksXG4gICAgICBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLFxuICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgICAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gICAgICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSxcbiAgICAgIFJFQUNUX0FDVElWSVRZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuYWN0aXZpdHlcIiksXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGNyZWF0ZVRhc2sgPSBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgPyBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9O1xuICAgIFJlYWN0ID0ge1xuICAgICAgcmVhY3Rfc3RhY2tfYm90dG9tX2ZyYW1lOiBmdW5jdGlvbiAoY2FsbFN0YWNrRm9yRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxTdGFja0ZvckVycm9yKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG4gICAgdmFyIGRpZFdhcm5BYm91dEVsZW1lbnRSZWYgPSB7fTtcbiAgICB2YXIgdW5rbm93bk93bmVyRGVidWdTdGFjayA9IFJlYWN0LnJlYWN0X3N0YWNrX2JvdHRvbV9mcmFtZS5iaW5kKFxuICAgICAgUmVhY3QsXG4gICAgICBVbmtub3duT3duZXJcbiAgICApKCk7XG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnVGFzayA9IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUoVW5rbm93bk93bmVyKSk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEtleVNwcmVhZCA9IHt9O1xuICAgIGV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgIGV4cG9ydHMuanN4REVWID0gZnVuY3Rpb24gKFxuICAgICAgdHlwZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1heWJlS2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNlbGZcbiAgICApIHtcbiAgICAgIHZhciB0cmFja0FjdHVhbE93bmVyID1cbiAgICAgICAgMWU0ID4gUmVhY3RTaGFyZWRJbnRlcm5hbHMucmVjZW50bHlDcmVhdGVkT3duZXJTdGFja3MrKztcbiAgICAgIHJldHVybiBqc3hERVZJbXBsKFxuICAgICAgICB0eXBlLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHNlbGYsXG4gICAgICAgIHRyYWNrQWN0dWFsT3duZXJcbiAgICAgICAgICA/IEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpXG4gICAgICAgICAgOiB1bmtub3duT3duZXJEZWJ1Z1N0YWNrLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyID8gY3JlYXRlVGFzayhnZXRUYXNrTmFtZSh0eXBlKSkgOiB1bmtub3duT3duZXJEZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIkM6XFxFYnR0aWthciBJbnRlbGxpZ2VuY2UgUHJvamVjdHNcXFRlc3QtQ2hhdC1BcHBcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZGlzdFxcY29tcGlsZWRcXHJlYWN0XFxqc3gtZGV2LXJ1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.tsx\",\"import\":\"Montserrat\",\"arguments\":[{\"subsets\":[\"latin\"],\"display\":\"swap\",\"variable\":\"--font-montserrat\"}],\"variableName\":\"montserrat\"}":
/*!*******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app\\layout.tsx","import":"Montserrat","arguments":[{"subsets":["latin"],"display":"swap","variable":"--font-montserrat"}],"variableName":"montserrat"} ***!
  \*******************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'Montserrat', 'Montserrat Fallback'\",\"fontStyle\":\"normal\"},\"className\":\"__className_4bc053\",\"variable\":\"__variable_4bc053\"};\n    if(true) {\n      // 1752723137288\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwiYXBwXFxcXGxheW91dC50c3hcIixcImltcG9ydFwiOlwiTW9udHNlcnJhdFwiLFwiYXJndW1lbnRzXCI6W3tcInN1YnNldHNcIjpbXCJsYXRpblwiXSxcImRpc3BsYXlcIjpcInN3YXBcIixcInZhcmlhYmxlXCI6XCItLWZvbnQtbW9udHNlcnJhdFwifV0sXCJ2YXJpYWJsZU5hbWVcIjpcIm1vbnRzZXJyYXRcIn0iLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0IsU0FBUyx3RUFBd0U7QUFDbkcsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsd01BQXFJLGNBQWMsc0RBQXNEO0FBQ3ZPLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxFYnR0aWthciBJbnRlbGxpZ2VuY2UgUHJvamVjdHNcXFRlc3QtQ2hhdC1BcHBcXG5vZGVfbW9kdWxlc1xcbmV4dFxcZm9udFxcZ29vZ2xlXFx0YXJnZXQuY3NzP3tcInBhdGhcIjpcImFwcFxcbGF5b3V0LnRzeFwiLFwiaW1wb3J0XCI6XCJNb250c2VycmF0XCIsXCJhcmd1bWVudHNcIjpbe1wic3Vic2V0c1wiOltcImxhdGluXCJdLFwiZGlzcGxheVwiOlwic3dhcFwiLFwidmFyaWFibGVcIjpcIi0tZm9udC1tb250c2VycmF0XCJ9XSxcInZhcmlhYmxlTmFtZVwiOlwibW9udHNlcnJhdFwifXxhcHAtcGFnZXMtYnJvd3NlciJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbm1vZHVsZS5leHBvcnRzID0ge1wic3R5bGVcIjp7XCJmb250RmFtaWx5XCI6XCInTW9udHNlcnJhdCcsICdNb250c2VycmF0IEZhbGxiYWNrJ1wiLFwiZm9udFN0eWxlXCI6XCJub3JtYWxcIn0sXCJjbGFzc05hbWVcIjpcIl9fY2xhc3NOYW1lXzRiYzA1M1wiLFwidmFyaWFibGVcIjpcIl9fdmFyaWFibGVfNGJjMDUzXCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3NTI3MjMxMzcyODhcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovRWJ0dGlrYXIgSW50ZWxsaWdlbmNlIFByb2plY3RzL1Rlc3QtQ2hhdC1BcHAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9obXIvaG90TW9kdWxlUmVwbGFjZW1lbnQuanNcIikobW9kdWxlLmlkLCB7XCJwdWJsaWNQYXRoXCI6XCIvX25leHQvXCIsXCJlc01vZHVsZVwiOmZhbHNlLFwibG9jYWxzXCI6dHJ1ZX0pO1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGNzc1JlbG9hZCk7XG4gICAgICBcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app\\\\layout.tsx\",\"import\":\"Montserrat\",\"arguments\":[{\"subsets\":[\"latin\"],\"display\":\"swap\",\"variable\":\"--font-montserrat\"}],\"variableName\":\"montserrat\"}\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CEbttikar%20Intelligence%20Projects%5C%5CTest-Chat-App%5C%5Capp%5C%5Cproviders.tsx%22%2C%22ids%22%3A%5B%22Providers%22%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CEbttikar%20Intelligence%20Projects%5C%5CTest-Chat-App%5C%5Cnode_modules%5C%5Cnext%5C%5Cfont%5C%5Cgoogle%5C%5Ctarget.css%3F%7B%5C%22path%5C%22%3A%5C%22app%5C%5C%5C%5Clayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Montserrat%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22display%5C%22%3A%5C%22swap%5C%22%2C%5C%22variable%5C%22%3A%5C%22--font-montserrat%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22montserrat%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22C%3A%5C%5CEbttikar%20Intelligence%20Projects%5C%5CTest-Chat-App%5C%5Capp%5C%5Cglobals.css%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);